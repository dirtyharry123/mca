diff -purN apex-1.6.8/include/asm-arm/cp15-armv5.h work_1.6.8/include/asm-arm/cp15-armv5.h
--- apex-1.6.8/include/asm-arm/cp15-armv5.h	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/include/asm-arm/cp15-armv5.h	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,96 @@
+/* cp15-armv5.h
+
+   written by Durgesh Pattamatta
+   13 OCT 2008
+
+   Copyright (C) 2008 NXP Semiconductors
+   Copyright (C) 2006 Marc Singer
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+   -----------
+   DESCRIPTION
+   -----------
+
+*/
+
+#if !defined (__CP15_ARMV5_H__)
+#    define   __CP15_ARMV5_H__
+
+	/* ---- Cache control */
+
+#define INVALIDATE_ICACHE\
+  __asm volatile ("mcr p15, 0, %0, c7, c5, 0\n\t" :: "r" (0))
+#define INVALIDATE_ICACHE_VA(a)\
+  __asm volatile ("mcr p15, 0, %0, c7, c5, 1\n\t" :: "r" (a))
+
+#define INVALIDATE_DCACHE\
+  __asm volatile ("mcr p15, 0, %0, c7, c6, 0\n\t" :: "r" (0))
+#define INVALIDATE_DCACHE_VA(a)\
+  __asm volatile ("mcr p15, 0, %0, c7, c6, 1\n\t" :: "r" (a))
+
+#define INVALIDATE_CACHE\
+  __asm volatile ("mcr p15, 0, %0, c7, c7, 0\n\t" :: "r" (0))
+
+#define CLEAN_DCACHE_VA(a)\
+  __asm volatile ("mcr p15, 0, %0, c7, c10, 1\n\t" :: "r" (a))
+#define CLEAN_DCACHE_I(i)\
+  __asm volatile ("mcr p15, 0, %0, c7, c10, 2\n\t" :: "r" (i))
+#define DRAIN_WRITE_BUFFER\
+  __asm volatile ("mcr p15, 0, %0, c7, c10, 4\n\t" :: "r" (0))
+
+#define PREFETCH_ICACHE_VA(a)\
+  __asm volatile ("mcr p15, 0, %0, c7, c13, 1\n\t" :: "r" (a))
+
+#define CLEAN_INV_DCACHE_VA(a)\
+  __asm volatile ("mcr p15, 0, %0, c7, c14, 1\n\t" :: "r" (a))
+#define CLEAN_INV_DCACHE_I(i)\
+  __asm volatile ("mcr p15, 0, %0, c7, c14, 2\n\t" :: "r" (i))
+
+	/* ---- Cache lockdown */
+
+#define UNLOCK_CACHE\
+  __asm volatile ("mcr p15, 0, %0, c9, c0, 0\n\t"\
+		  "mcr p15, 0, %0, c9, c0, 1\n\t" :: "r" (0xfff0))
+
+	/* ---- TLB control */
+
+#define INVALIDATE_TLB\
+  __asm volatile ("mcr p15, 0, %0, c8, c7, 0\n\t" :: "r" (0))
+#define INVALIDATE_ITLB\
+  __asm volatile ("mcr p15, 0, %0, c8, c5, 0\n\t" :: "r" (0))
+#define INVALIDATE_ITLB_VA(a)\
+  __asm volatile ("mcr p15, 0, %0, c8, c5, 1\n\t" :: "r" (a))
+#define INVALIDATE_DTLB\
+  __asm volatile ("mcr p15, 0, %0, c8, c6, 0\n\t" :: "r" (0))
+#define INVALIDATE_DTLB_VA(a)\
+  __asm volatile ("mcr p15, 0, %0, c8, c6, 1\n\t" :: "r" (a))
+
+
+#define _DLEN(l)	((l>>(12+0))&3)
+#define _DSIZE(l)	((l>>(12+6))&0xF)
+#define _DASSOC(l)	((l>>(12+3))&7)
+#define _DM(l)		((l>>(12+2))&1)
+
+
+#define CLEANALL_DCACHE\
+  ({ unsigned long cache; int set, index; int linelen; int assoc;\
+    __asm volatile ("mrc p15, 0, %0, c0, c0, 1" : "=r" (cache));\
+    linelen = _DLEN(cache) + 3;\
+    assoc = 32 - _DASSOC(cache);\
+/*    if (DM(l)) */ \
+/*      assoc = 3*assoc/2; */ \
+    for (set = 1<<(_DSIZE(cache) + 6 - _DASSOC(cache) - _DLEN(cache)); \
+	 set--; )\
+      for (index = 1<<_DASSOC(cache); index--;) {\
+	 __asm volatile ("mcr p15, 0, %0, c7, c10, 2" \
+			:: "r" ((index<<assoc)|(set<<linelen))); } })
+
+	/* ---- Some function are not available */
+
+
+
+#endif  /* __CP15_ARMV5_H__ */
diff -purN apex-1.6.8/include/asm-arm/cp15.h work_1.6.8/include/asm-arm/cp15.h
--- apex-1.6.8/include/asm-arm/cp15.h	2009-01-23 09:27:42.000000000 -0800
+++ work_1.6.8/include/asm-arm/cp15.h	2010-01-22 14:23:30.000000000 -0800
@@ -89,6 +89,8 @@
 
 #if defined (CONFIG_CPU_ARMV5TE)
 # include <asm/cp15-armv5te.h>
+#elif defined (CONFIG_CPU_ARMV5)
+# include <asm/cp15-armv5.h>
 #endif
 
 #if defined (CONFIG_CPU_ARMV6)
diff -purN apex-1.6.8/include/drv-nand-base.h work_1.6.8/include/drv-nand-base.h
--- apex-1.6.8/include/drv-nand-base.h	2009-01-23 09:27:42.000000000 -0800
+++ work_1.6.8/include/drv-nand-base.h	2010-01-22 14:23:30.000000000 -0800
@@ -72,5 +72,26 @@
 
 #endif
 
+#if defined (CONFIG_DRIVER_NAND_TYPE_MICRON)
+
+#define NAND_Reset			(0xff)
+#define NAND_ReadID			(0x90)
+#define NAND_Status			(0x70)
+#define NAND_ReadSetup			(0x00)
+#define NAND_Read			(0x30)
+#define NAND_Erase			(0x60)
+#define NAND_EraseConfirm		(0xd0)
+#define NAND_PageProgram		(0x80)
+#define NAND_PageProgramConfirm		(0x10)
+#define NAND_RandomDataInput		(0x85)
+
+#define NAND_Fail			(1<<0)
+#define NAND_CacheErr			(1<<1)
+#define NAND_CacheReady			(1<<5)
+#define NAND_Ready			(1<<6)
+#define NAND_Writable			(1<<7)
+
+#endif
+
 
 #endif  /* __DRV_NAND_BASE_H__ */
diff -purN apex-1.6.8/include/mmc.h work_1.6.8/include/mmc.h
--- apex-1.6.8/include/mmc.h	2009-01-23 09:27:43.000000000 -0800
+++ work_1.6.8/include/mmc.h	2010-01-22 14:23:30.000000000 -0800
@@ -35,6 +35,7 @@
 #define MMC_SET_RELATIVE_ADDR     3   /* ac   [31:16] RCA        R1  */
 #define MMC_SET_DSR               4   /* bc   [31:16] RCA            */
 #define MMC_SELECT_CARD           7   /* ac   [31:16] RCA        R1  */
+#define MMC_SEND_EXT_CSD          8   /* bc                      R1  */        
 #define MMC_SEND_CSD              9   /* ac   [31:16] RCA        R2  */
 #define MMC_SEND_CID             10   /* ac   [31:16] RCA        R2  */
 /* Deprecated */
@@ -83,6 +84,7 @@
   /* class 8 */
 /* This is basically the same command as for MMC with some quirks. */
 #define SD_SEND_RELATIVE_ADDR     3   /* ac                      R6  */
+#define SD_CMD8                   8   /* bcr  [31:0]  OCR        R3  */        
 
   /* Application commands */
 #define SD_APP_SET_BUS_WIDTH      6   /* ac   [1:0]   bus width  R1	  */
@@ -128,6 +130,16 @@
 #define R1_READY_FOR_DATA	(1 << 8)	/* sx, a */
 #define R1_APP_CMD		(1 << 5)	/* sr, c */
 
+#define MMC_IDLE_ST             0   /* Idle state */
+#define MMC_READY_ST            1   /* Ready state */
+#define MMC_IDENT_ST            2   /* Identification State */
+#define MMC_STBY_ST             3   /* standby state */
+#define MMC_TRAN_ST             4   /* transfer state */
+#define MMC_DATA_ST             5   /* Sending-data State */
+#define MMC_RCV_ST              6   /* Receive-data State */
+#define MMC_PRG_ST              7   /* Programming State */
+#define MMC_DIS_ST              8   /* Disconnect State */
+
 #define MMC_VDD_145_150	0x00000001	/* VDD voltage 1.45 - 1.50 */
 #define MMC_VDD_150_155	0x00000002	/* VDD voltage 1.50 - 1.55 */
 #define MMC_VDD_155_160	0x00000004	/* VDD voltage 1.55 - 1.60 */
@@ -153,6 +165,7 @@
 #define MMC_VDD_34_35	0x00400000	/* VDD voltage 3.4 ~ 3.5 */
 #define MMC_VDD_35_36	0x00800000	/* VDD voltage 3.5 ~ 3.6 */
 #define OCR_ALL_READY	0x80000000	/* Card Power up status bit */
+#define OCR_HC_CCS    0x40000000  /* High capacity card */
 
 /*
  * Card Command Classes (CCC)
@@ -203,6 +216,7 @@
 #define CLOCK_DETECT		(300*1024)	 /* Clock rate during detect */
 #define CLOCK_DATA		(20*1024*1024)	 /* Clock rate during I/O */
 
+#if defined(CONFIG_DRIVER_LH_MMC)
 #define MMC_CLKC_START_CLK	(1<<1)
 #define MMC_CLKC_STOP_CLK	(1<<0)
 
@@ -244,6 +258,7 @@
 #define MMC_CMDCON_RESPONSE_R2	 (2 << MMC_CMDCON_RESPONSE_FORMAT_SHIFT) // 136
 #define MMC_CMDCON_RESPONSE_R3	 (3 << MMC_CMDCON_RESPONSE_FORMAT_SHIFT) //  48
 
+
 /*  HCLK is usually 99993600 */
 
 #define MMC_RATE_IO_V		(0)			/* 0 -> MCLK/1  */
@@ -256,11 +271,13 @@
 //#define MMC_READ_TO_V		(0x7fff)
 #define MMC_READ_TO_V		(0xffff)
 
-#define MS_ACQUIRE_DELAY	(10)
+#endif  /*CONFIG_DRIVER_LH_MMC*/
 
 
+#define MS_ACQUIRE_DELAY	(10)
 #define MMC_OCR_ARG_MAX		(0x00ffff00)
 
+#define CMD_BIT_AUTO_STOP	 (1<<26)
 #define CMD_BIT_APP		 (1<<23)
 #define CMD_BIT_INIT		 (1<<22)
 #define CMD_BIT_BUSY		 (1<<21)
@@ -279,22 +296,31 @@
 
 #define CMD_IDLE	 CMD(MMC_GO_IDLE_STATE,0) | CMD_BIT_LS	 | CMD_BIT_INIT
 #define CMD_SD_OP_COND	 CMD(SD_APP_OP_COND,1)      | CMD_BIT_LS | CMD_BIT_APP
+#define CMD_SD_SEND_IF_COND	 CMD(SD_CMD8,1)      | CMD_BIT_LS 
 #define CMD_MMC_OP_COND	 CMD(MMC_SEND_OP_COND,3)    | CMD_BIT_LS | CMD_BIT_INIT
 #define CMD_ALL_SEND_CID CMD(MMC_ALL_SEND_CID,2)    | CMD_BIT_LS
 #define CMD_MMC_SET_RCA	 CMD(MMC_SET_RELATIVE_ADDR,1) | CMD_BIT_LS
 #define CMD_SD_SEND_RCA	 CMD(SD_SEND_RELATIVE_ADDR,1) | CMD_BIT_LS
-#define CMD_SEND_CSD	 CMD(MMC_SEND_CSD,2)
+#define CMD_SEND_CSD	 CMD(MMC_SEND_CSD,2) | CMD_BIT_LS
+#define CMD_SEND_EXT_CSD	 CMD(MMC_SEND_EXT_CSD,1) | CMD_BIT_LS | CMD_BIT_DATA
 #define CMD_DESELECT_CARD CMD(MMC_SELECT_CARD,0)
 #define CMD_SELECT_CARD	 CMD(MMC_SELECT_CARD,1)
 #define CMD_SET_BLOCKLEN CMD(MMC_SET_BLOCKLEN,1)
+#define CMD_SEND_STATUS  CMD(MMC_SEND_STATUS,1)
 #define CMD_READ_SINGLE  CMD(MMC_READ_SINGLE_BLOCK,1) | CMD_BIT_DATA
-#define CMD_READ_MULTIPLE CMD(MMC_READ_MULTIPLE_BLOCK,1) | CMD_BIT_DATA
+#define CMD_READ_MULTIPLE CMD(MMC_READ_MULTIPLE_BLOCK,1) | CMD_BIT_DATA | CMD_BIT_AUTO_STOP
 #define CMD_SD_SET_WIDTH CMD(SD_APP_SET_BUS_WIDTH,1)| CMD_BIT_APP
 #define CMD_STOP	 CMD(MMC_STOP_TRANSMISSION,1) | CMD_BIT_BUSY
 #define CMD_WRITE_SINGLE CMD(MMC_WRITE_BLOCK,1) | CMD_BIT_DATA | CMD_BIT_WRITE
 
 #define MMC_SECTOR_SIZE 512	/* *** FIXME: should come from card */
 
+/* card type defines */
+#define CARD_TYPE_SD    (1 << 0)
+#define CARD_TYPE_4BIT  (1 << 1)
+#define CARD_TYPE_8BIT  (1 << 2)
+#define CARD_TYPE_HC    (OCR_HC_CCS) /* high capacity card > 2GB */  
+
 /* ----- Types */
 
 struct mmc_info {
@@ -303,6 +329,7 @@ struct mmc_info {
   char csd[16];			/* CSD of acquired card */
   int acquire_time;		/* Count of delays to acquire card */
   int cmdcon_sd;		/* cmdcon bits for data IO */
+  int card_type; 
   int rca;			/* Relative address assigned to card */
   int acquired;                 /* Boolean for marking that card has been acquired */
 
@@ -317,6 +344,7 @@ struct mmc_info {
 		/* *** FIXME: should be in .xbss section */
 //  char rgb[512*2];		/* Sector buffer(s) */
   unsigned long ib;		/* Index of cached data */
+  int speed;
 };
 
 /* ----- Globals */
diff -purN apex-1.6.8/include/network.h work_1.6.8/include/network.h
--- apex-1.6.8/include/network.h	2009-01-23 09:27:43.000000000 -0800
+++ work_1.6.8/include/network.h	2010-01-22 14:23:30.000000000 -0800
@@ -55,6 +55,24 @@ struct header_arp {
   u8 target_protocol_address[4];
 } __attribute__((packed));
 
+struct header_bootp {
+  u8 op;
+  u8 htype;
+  u8 hlen;
+  u8 hops;
+  u32 xid;
+  u16 secs;
+  u16 flags;
+  u8 ciaddr[4];
+  u8 yiaddr[4];
+  u8 siaddr[4];
+  u8 giaddr[4];
+  u8 chaddr[16];
+  u8 sname[64];
+  u8 file[128];
+  u8 vend[64]; /* This field is not part of DHCP */
+}  __attribute__((packed));
+
 struct header_ipv4 {
   u8  version_ihl;		/* version (4 lsb) and header length (4 msb) */
   u8  tos;			/* type of service */
@@ -148,6 +166,9 @@ struct addrinfo {
 #define ARP_REVERSEREPLY	4
 #define ARP_NAK			10
 
+#define PORT_BOOTP_SERVER	67
+#define PORT_BOOTP_CLIENT	68
+
 #define ICMP_TYPE_ECHO		8
 #define ICMP_TYPE_ECHO_REPLY	0
 
@@ -185,6 +206,12 @@ struct addrinfo {
 			  + sizeof (struct header_ethernet)\
 			  + sizeof (struct header_ipv4)))
 
+#define BOOTP_F(f)	((struct header_bootp*)\
+			 (f->rgb\
+			  + sizeof (struct header_ethernet)\
+			  + sizeof (struct header_ipv4)\
+			  + sizeof (struct header_udp)))
+
 #define ICMP_F(f)	((struct header_icmp*)\
 			 (f->rgb\
 			  + sizeof (struct header_ethernet)\
diff -purN apex-1.6.8/src/apex/command.c work_1.6.8/src/apex/command.c
--- apex-1.6.8/src/apex/command.c	2009-01-23 09:27:43.000000000 -0800
+++ work_1.6.8/src/apex/command.c	2010-01-22 14:23:30.000000000 -0800
@@ -51,7 +51,8 @@ const char* error_description;
 static char* expand_variables (const char* rgbSrc)
 {
   const char* pchSrc;
-  static char __xbss(command) rgb[CB_COMMAND_MAX];
+  static char __xbss(command) s_rgb[CB_COMMAND_MAX];
+  char rgb[CB_COMMAND_MAX];
   char* pch = rgb;
   char* pchKey = NULL;
   int state = 0;
@@ -107,7 +108,11 @@ static char* expand_variables (const cha
     if (!*pchSrc)
       break;
   }
-  return fChanged && state == 0 ? rgb : NULL;
+  if (fChanged && (state == 0)) {
+	strcpy (s_rgb, rgb); 
+	return s_rgb;
+  }
+  return NULL;
 }
 #endif
 
@@ -131,13 +136,19 @@ int parse_command (char* rgb, int* pargc
   int result = 0;
 
 #if defined (USE_EXPAND_VARIABLES)
-  pb = expand_variables (rgb);
-  if (pb) {
-    rgb = pb;
-    printf ("# %s\n", pb);
+  /* do expansion atleast 3 times */
+  cb = 3;
+  while (cb--) {
+    pb = expand_variables (rgb);
+    if (pb) {
+      rgb = pb;
+      printf ("# %s\n", pb);
+    }
+    else {
+      pb = rgb;
+      break;
+    }
   }
-  else
-    pb = rgb;
 #else
   pb = rgb;
 #endif
diff -purN apex-1.6.8/src/arch-arm/entry/apex.lds.S work_1.6.8/src/arch-arm/entry/apex.lds.S
--- apex-1.6.8/src/arch-arm/entry/apex.lds.S	2009-01-23 09:27:43.000000000 -0800
+++ work_1.6.8/src/arch-arm/entry/apex.lds.S	2010-01-22 14:23:30.000000000 -0800
@@ -177,6 +177,8 @@ SECTIONS
 	APEX_VMA_COPY_END = .;
 	. = ALIGN (4);
 	APEX_VMA_PROBE_END = .;
+	APEX_IMAGE_SIZE = APEX_VMA_COPY_END - APEX_VMA_COPY_START;
+	APEX_IMAGE_512_SIZE = (APEX_IMAGE_SIZE + 511) & ~ 511;
 	/* The next word is the location we'll be writing to when
 	   probing.  See note in drv-mem.c. */
 	APEX_VMA_STACKS_START = .;
diff -purN apex-1.6.8/src/arch-arm/entry/reset.c work_1.6.8/src/arch-arm/entry/reset.c
--- apex-1.6.8/src/arch-arm/entry/reset.c	2009-01-23 09:27:43.000000000 -0800
+++ work_1.6.8/src/arch-arm/entry/reset.c	2010-01-22 14:23:30.000000000 -0800
@@ -61,7 +61,7 @@ extern void reset_finish (void);
 
 void __naked __section (.entry) entry (void)
 {
-#if defined (CONFIG_ENV_LINK)
+#if defined (CONFIG_ENV_LINK) || defined (CONFIG_ARCH_LPC313X)
   /* Presently, we only need to skip something if there is an
      environment link. */
   __asm volatile ("b reset\n\t");
diff -purN apex-1.6.8/src/arch-arm/Kconfig work_1.6.8/src/arch-arm/Kconfig
--- apex-1.6.8/src/arch-arm/Kconfig	2009-01-23 09:27:43.000000000 -0800
+++ work_1.6.8/src/arch-arm/Kconfig	2010-01-22 14:23:30.000000000 -0800
@@ -82,6 +82,9 @@ config ARCH_MX3
 config ARCH_ORION5X
 	bool "Marvell Orion5x (Feroceon)"
 
+config ARCH_LPC313X
+	bool "NXP LPC313x"
+
 endchoice
 
 config EXPERIMENTAL
@@ -344,6 +347,7 @@ source src/mach-ixp42x/Kconfig
 source src/mach-s3c2410/Kconfig
 source src/mach-mx3/Kconfig
 source src/mach-orion5x/Kconfig
+source src/mach-lpc313x/Kconfig
 
 source src/apex/Kconfig
 
@@ -372,7 +376,7 @@ config ENV
 
 config ENV_LINK
 	bool "Assist user-mode access to the environment"
-	depends on ENV && !CONFIG_SMALL
+	depends on ENV && !CONFIG_SMALL && !ARCH_LPC313X
 	default y
 	help
 	  This option puts a marker and a string near the beginning of
Binary files apex-1.6.8/src/arch-arm/rom/apex.bin and work_1.6.8/src/arch-arm/rom/apex.bin differ
diff -purN apex-1.6.8/src/drivers/drv-cs8900.c work_1.6.8/src/drivers/drv-cs8900.c
--- apex-1.6.8/src/drivers/drv-cs8900.c	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/drivers/drv-cs8900.c	2010-02-24 16:50:06.000000000 -0800
@@ -0,0 +1,489 @@
+/*
+ * Cirrus Logic CS8900A Ethernet
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <apex.h>
+#include <config.h>
+#include <driver.h>
+#include <service.h>
+#include <command.h>
+#include <error.h>
+#include <linux/string.h>
+#include <asm/reg.h>
+#include <linux/kernel.h>
+
+#include <mach/drv-cs8900.h>
+
+#undef DEBUG
+
+#define DRIVER_NAME		 "eth-cs8900"
+
+#define  C_RX_BUFFER		 4
+#define CB_RX_BUFFER		 (1536 + 6)
+
+#if defined (CONFIG_ETHERNET)
+extern char host_mac_address[6];
+#endif
+
+static int initialized;
+static unsigned long phy_id;	/* ID read from PHY */
+static int head_rx;		/* Next buffer to accept a receive packet */
+static int count_rx;		/* Number of received packets buffered */
+static char __xbss(ethernet) rgbRxBuffer[C_RX_BUFFER * CB_RX_BUFFER];
+
+/* 16 bit aligned registers, 16 bit wide */
+#define CS8900_BUS16_0  *(volatile u8 *)(CS8900_BASE+0x00)
+#define CS8900_BUS16_1  *(volatile u8 *)(CS8900_BASE+0x01)
+
+#if !defined (CS8900_IO_OVERRIDE)
+#define CS_REG16    __REG16
+#endif /* CS8900_IO_OVERRIDE */
+#define CS8900_RxDATA   CS_REG16(CS8900_BASE+0x00)
+#define CS8900_TxDATA   __REG16(CS8900_BASE+0x00)
+#define CS8900_TxCMD    __REG16(CS8900_BASE+0x04)
+#define CS8900_TxLEN    __REG16(CS8900_BASE+0x06)
+#define CS8900_ISQ      CS_REG16(CS8900_BASE+0x08)
+#define CS8900_PPTR     __REG16(CS8900_BASE+0x0a)
+#define CS8900_PDATA    CS_REG16(CS8900_BASE+0x0c)
+#define CS8900_PDATA_W  __REG16(CS8900_BASE+0x0c)
+#define ISQ_RxEvent     0x04
+#define ISQ_TxEvent     0x08
+#define ISQ_BufEvent    0x0C
+#define ISQ_RxMissEvent 0x10
+#define ISQ_TxColEvent  0x12
+#define ISQ_EventMask   0x3F
+/* packet page register offsets */
+/* bus interface registers */
+#define PP_ChipID              0x0000	/* Chip identifier - must be 0x630E */
+#define PP_ChipRev             0x0002	/* Chip revision, model codes */
+#define PP_IntReg              0x0022	/* Interrupt configuration */
+#define PP_IntReg_IRQ0         0x0000	/* Use INTR0 pin */
+#define PP_IntReg_IRQ1         0x0001	/* Use INTR1 pin */
+#define PP_IntReg_IRQ2         0x0002	/* Use INTR2 pin */
+#define PP_IntReg_IRQ3         0x0003	/* Use INTR3 pin */
+/* status and control registers */
+#define PP_RxCFG     0x0102	/* Receiver configuration */
+#define PP_RxCFG_Skip1         0x0040	/* Skip (i.e. discard) current frame */
+#define PP_RxCFG_Stream        0x0080	/* Enable streaming mode */
+#define PP_RxCFG_RxOK          0x0100	/* RxOK interrupt enable */
+#define PP_RxCFG_RxDMAonly     0x0200	/* Use RxDMA for all frames */
+#define PP_RxCFG_AutoRxDMA     0x0400	/* Select RxDMA automatically */
+#define PP_RxCFG_BufferCRC     0x0800	/* Include CRC characters in frame */
+#define PP_RxCFG_CRC           0x1000	/* Enable interrupt on CRC error */
+#define PP_RxCFG_RUNT          0x2000	/* Enable interrupt on RUNT frames */
+#define PP_RxCFG_EXTRA         0x4000	/* Enable interrupt on frames with extra data */
+#define PP_RxCTL     0x0104	/* Receiver control */
+#define PP_RxCTL_IAHash        0x0040	/* Accept frames that match hash */
+#define PP_RxCTL_Promiscuous   0x0080	/* Accept any frame */
+#define PP_RxCTL_RxOK          0x0100	/* Accept well formed frames */
+#define PP_RxCTL_Multicast     0x0200	/* Accept multicast frames */
+#define PP_RxCTL_IA            0x0400	/* Accept frame that matches IA */
+#define PP_RxCTL_Broadcast     0x0800	/* Accept broadcast frames */
+#define PP_RxCTL_CRC           0x1000	/* Accept frames with bad CRC */
+#define PP_RxCTL_RUNT          0x2000	/* Accept runt frames */
+#define PP_RxCTL_EXTRA         0x4000	/* Accept frames that are too long */
+#define PP_TxCFG     0x0106	/* Transmit configuration */
+#define PP_TxCFG_CRS           0x0040	/* Enable interrupt on loss of carrier */
+#define PP_TxCFG_SQE           0x0080	/* Enable interrupt on Signal Quality Error */
+#define PP_TxCFG_TxOK          0x0100	/* Enable interrupt on successful xmits */
+#define PP_TxCFG_Late          0x0200	/* Enable interrupt on "out of window" */
+#define PP_TxCFG_Jabber        0x0400	/* Enable interrupt on jabber detect */
+#define PP_TxCFG_Collision     0x0800	/* Enable interrupt if collision */
+#define PP_TxCFG_16Collisions  0x8000	/* Enable interrupt if > 16 collisions */
+#define PP_TxCmd     0x0108	/* Transmit command status */
+#define PP_TxCmd_TxStart_5     0x0000	/* Start after 5 bytes in buffer */
+#define PP_TxCmd_TxStart_381   0x0040	/* Start after 381 bytes in buffer */
+#define PP_TxCmd_TxStart_1021  0x0080	/* Start after 1021 bytes in buffer */
+#define PP_TxCmd_TxStart_Full  0x00C0	/* Start after all bytes loaded */
+#define PP_TxCmd_Force         0x0100	/* Discard any pending packets */
+#define PP_TxCmd_OneCollision  0x0200	/* Abort after a single collision */
+#define PP_TxCmd_NoCRC         0x1000	/* Do not add CRC */
+#define PP_TxCmd_NoPad         0x2000	/* Do not pad short packets */
+#define PP_BufCFG    0x010A	/* Buffer configuration */
+#define PP_BufCFG_SWI          0x0040	/* Force interrupt via software */
+#define PP_BufCFG_RxDMA        0x0080	/* Enable interrupt on Rx DMA */
+#define PP_BufCFG_TxRDY        0x0100	/* Enable interrupt when ready for Tx */
+#define PP_BufCFG_TxUE         0x0200	/* Enable interrupt in Tx underrun */
+#define PP_BufCFG_RxMiss       0x0400	/* Enable interrupt on missed Rx packets */
+#define PP_BufCFG_Rx128        0x0800	/* Enable Rx interrupt after 128 bytes */
+#define PP_BufCFG_TxCol        0x1000	/* Enable int on Tx collision ctr overflow */
+#define PP_BufCFG_Miss         0x2000	/* Enable int on Rx miss ctr overflow */
+#define PP_BufCFG_RxDest       0x8000	/* Enable int on Rx dest addr match */
+#define PP_LineCTL   0x0112	/* Line control */
+#define PP_LineCTL_Rx          0x0040	/* Enable receiver */
+#define PP_LineCTL_Tx          0x0080	/* Enable transmitter */
+#define PP_LineCTL_AUIonly     0x0100	/* AUI interface only */
+#define PP_LineCTL_AutoAUI10BT 0x0200	/* Autodetect AUI or 10BaseT interface */
+#define PP_LineCTL_ModBackoffE 0x0800	/* Enable modified backoff algorithm */
+#define PP_LineCTL_PolarityDis 0x1000	/* Disable Rx polarity autodetect */
+#define PP_LineCTL_2partDefDis 0x2000	/* Disable two-part defferal */
+#define PP_LineCTL_LoRxSquelch 0x4000	/* Reduce receiver squelch threshold */
+#define PP_SelfCTL   0x0114	/* Chip self control */
+#define PP_SelfCTL_Reset       0x0040	/* Self-clearing reset */
+#define PP_SelfCTL_SWSuspend   40x0100	/* Initiate suspend mode */
+#define PP_SelfCTL_HWSleepE    0x0200	/* Enable SLEEP input */
+#define PP_SelfCTL_HWStandbyE  0x0400	/* Enable standby mode */
+#define PP_SelfCTL_HC0E        0x1000	/* use HCB0 for LINK LED */
+#define PP_SelfCTL_HC1E        0x2000	/* use HCB1 for BSTATUS LED */
+#define PP_SelfCTL_HCB0        0x4000	/* control LINK LED if HC0E set */
+#define PP_SelfCTL_HCB1        0x8000	/* control BSTATUS LED if HC1E set */
+#define PP_BusCTL    0x0116	/* Bus control */
+#define PP_BusCTL_ResetRxDMA   0x0040	/* Reset RxDMA pointer */
+#define PP_BusCTL_DMAextend    0x0100	/* Extend DMA cycle */
+#define PP_BusCTL_UseSA        0x0200	/* Assert MEMCS16 on address decode */
+#define PP_BusCTL_MemoryE      0x0400	/* Enable memory mode */
+#define PP_BusCTL_DMAburst     0x0800	/* Limit DMA access burst */
+#define PP_BusCTL_IOCHRDYE     0x1000	/* Set IOCHRDY high impedence */
+#define PP_BusCTL_RxDMAsize    0x2000	/* Set DMA buffer size 64KB */
+#define PP_BusCTL_EnableIRQ    0x8000	/* Generate interrupt on interrupt event */
+#define PP_TestCTL   0x0118	/* Test control */
+#define PP_TestCTL_DisableLT   0x0080	/* Disable link status */
+#define PP_TestCTL_ENDECloop   0x0200	/* Internal loopback */
+#define PP_TestCTL_AUIloop     0x0400	/* AUI loopback */
+#define PP_TestCTL_DisBackoff  0x0800	/* Disable backoff algorithm */
+#define PP_TestCTL_FDX         0x4000	/* Enable full duplex mode */
+#define PP_ISQ       0x0120	/* Interrupt Status Queue */
+#define PP_RER       0x0124	/* Receive event */
+#define PP_RER_IAHash          0x0040	/* Frame hash match */
+#define PP_RER_Dribble         0x0080	/* Frame had 1-7 extra bits after last byte */
+#define PP_RER_RxOK            0x0100	/* Frame received with no errors */
+#define PP_RER_Hashed          0x0200	/* Frame address hashed OK */
+#define PP_RER_IA              0x0400	/* Frame address matched IA */
+#define PP_RER_Broadcast       0x0800	/* Broadcast frame */
+#define PP_RER_CRC             0x1000	/* Frame had CRC error */
+#define PP_RER_RUNT            0x2000	/* Runt frame */
+#define PP_RER_EXTRA           0x4000	/* Frame was too long */
+#define PP_TER       0x0128	/* Transmit event */
+#define PP_TER_CRS             0x0040	/* Carrier lost */
+#define PP_TER_SQE             0x0080	/* Signal Quality Error */
+#define PP_TER_TxOK            0x0100	/* Packet sent without error */
+#define PP_TER_Late            0x0200	/* Out of window */
+#define PP_TER_Jabber          0x0400	/* Stuck transmit? */
+#define PP_TER_NumCollisions   0x7800	/* Number of collisions */
+#define PP_TER_16Collisions    0x8000	/* > 16 collisions */
+#define PP_BER       0x012C	/* Buffer event */
+#define PP_BER_SWint           0x0040	/* Software interrupt */
+#define PP_BER_RxDMAFrame      0x0080	/* Received framed DMAed */
+#define PP_BER_Rdy4Tx          0x0100	/* Ready for trsansmission */
+#define PP_BER_TxUnderrun      0x0200	/* Transmit underrun */
+#define PP_BER_RxMiss          0x0400	/* Received frame missed */
+#define PP_BER_Rx128           0x0800	/* 128 bytes received */
+#define PP_BER_RxDest          0x8000	/* Received framed passed address filter */
+#define PP_RxMiss    0x0130	/*  Receiver miss counter */
+#define PP_TxCol     0x0132	/*  Transmit collision counter */
+#define PP_LineSTAT  0x0134	/* Line status */
+#define PP_LineSTAT_LinkOK     0x0080	/* Line is connected and working */
+#define PP_LineSTAT_AUI        0x0100	/* Connected via AUI */
+#define PP_LineSTAT_10BT       0x0200	/* Connected via twisted pair */
+#define PP_LineSTAT_Polarity   0x1000	/* Line polarity OK (10BT only) */
+#define PP_LineSTAT_CRS        0x4000	/* Frame being received */
+#define PP_SelfSTAT  0x0136	/* Chip self status */
+#define PP_SelfSTAT_33VActive  0x0040	/* supply voltage is 3.3V */
+#define PP_SelfSTAT_InitD      0x0080	/* Chip initialization complete */
+#define PP_SelfSTAT_SIBSY      0x0100	/* EEPROM is busy */
+#define PP_SelfSTAT_EEPROM     0x0200	/* EEPROM present */
+#define PP_SelfSTAT_EEPROM_OK  0x0400	/* EEPROM checks out */
+#define PP_SelfSTAT_ELPresent  0x0800	/* External address latch logic available */
+#define PP_SelfSTAT_EEsize     0x1000	/* Size of EEPROM */
+#define PP_BusSTAT   0x0138	/* Bus status */
+#define PP_BusSTAT_TxBid       0x0080	/* Tx error */
+#define PP_BusSTAT_TxRDY       0x0100	/* Ready for Tx data */
+#define PP_TDR       0x013C	/* AUI Time Domain Reflectometer */
+/* initiate transmit registers */
+#define PP_TxCommand 0x0144	/* Tx Command */
+#define PP_TxLength  0x0146	/* Tx Length */
+/* address filter registers */
+#define PP_LAF       0x0150	/* Logical address filter (6 bytes) */
+#define PP_IA        0x0158	/* Individual address (MAC) */
+/* EEPROM Kram */
+#define SI_BUSY 0x0100
+#define PP_EECMD 0x0040		/*  NVR Interface Command register */
+#define PP_EEData 0x0042	/*  NVR Interface Data Register */
+#define EEPROM_WRITE_EN		0x00F0
+#define EEPROM_WRITE_DIS	0x0000
+#define EEPROM_WRITE_CMD	0x0100
+#define EEPROM_READ_CMD		0x0200
+#define EEPROM_ERASE_CMD	0x0300
+/* packet page register access functions */
+static unsigned short get_reg_init_bus(int regno)
+{
+	/* force 16 bit busmode */
+	volatile unsigned char c;
+	c = CS8900_BUS16_0;
+	c = CS8900_BUS16_1;
+	c = CS8900_BUS16_0;
+	c = CS8900_BUS16_1;
+	c = CS8900_BUS16_0;
+
+	CS8900_PPTR = regno;
+	return CS8900_PDATA;
+}
+
+static unsigned short get_reg(int regno)
+{
+	CS8900_PPTR = regno;
+	return CS8900_PDATA;
+}
+
+static void put_reg(int regno, unsigned short val)
+{
+	CS8900_PPTR = regno;
+	CS8900_PDATA_W = val;
+}
+
+static void eth_reset(void)
+{
+	int tmo;
+	unsigned short us;
+
+	/* reset NIC */
+	put_reg(PP_SelfCTL, get_reg(PP_SelfCTL) | PP_SelfCTL_Reset);
+
+	/* wait for 200ms */
+	udelay(200000);
+	/* Wait until the chip is reset */
+	tmo = timer_read();
+	/* wait for 1 secs max */
+	while ((((us = get_reg_init_bus(PP_SelfSTAT)) & PP_SelfSTAT_InitD) == 0)
+	       && (timer_delta(tmo, timer_read()) < 1 * 1000))
+		/*NOP*/;
+}
+
+static void eth_reginit(void)
+{
+	/* receive only error free packets addressed to this card */
+	put_reg(PP_RxCTL, PP_RxCTL_IA | PP_RxCTL_Broadcast | PP_RxCTL_RxOK);
+	/* do not generate any interrupts on receive operations */
+	put_reg(PP_RxCFG, 0);
+	/* do not generate any interrupts on transmit operations */
+	put_reg(PP_TxCFG, 0);
+	/* do not generate any interrupts on buffer operations */
+	put_reg(PP_BufCFG, 0);
+	/* enable transmitter/receiver mode */
+	put_reg(PP_LineCTL, PP_LineCTL_Rx | PP_LineCTL_Tx);
+}
+
+static void cs8900_close(struct descriptor_d *d)
+{
+	/* disable transmitter/receiver mode */
+	put_reg(PP_LineCTL, 0);
+
+	/* "shutdown" to show ChipID or kernel wouldn't find the cs8900 ... */
+	get_reg_init_bus(PP_ChipID);
+	close_helper(d);
+}
+
+static void cs8900_init(void)
+{
+	initialized = 0;
+	/* verify chip id */
+	if ((phy_id = get_reg_init_bus(PP_ChipID)) != 0x630e) {
+		printf("CS8900 Ethernet chip not found?! id:0x%lx\n", phy_id);
+		return;
+	}
+	head_rx = count_rx = 0;
+	initialized = 1;
+	
+	/****#### need to be fixed */ 
+	    host_mac_address[0] = 0x00;
+	host_mac_address[1] = 0x08;
+	host_mac_address[2] = 0xee;
+	host_mac_address[3] = 0x00;
+	host_mac_address[4] = 0x80;
+	host_mac_address[5] = 0x44;
+
+	eth_reset();
+	/* set the ethernet address */
+	put_reg(PP_IA + 0, host_mac_address[0] | (host_mac_address[1] << 8));
+	put_reg(PP_IA + 2, host_mac_address[2] | (host_mac_address[3] << 8));
+	put_reg(PP_IA + 4, host_mac_address[4] | (host_mac_address[5] << 8));
+
+	eth_reginit();
+}
+
+/* Get a data block via Ethernet */
+static int eth_rx(void)
+{
+	int i;
+	u16 rxlen;
+	u16 *addr;
+	u16 status;
+	status = get_reg(PP_RER);
+
+	if ((status & PP_RER_RxOK) == 0)
+		return 0;
+
+	status = CS8900_RxDATA;	/* stat */
+	rxlen = CS8900_RxDATA;	/* len */
+
+	/* printf ("receiving 0x%04x 0x%04x  head %d count %d\n",
+	   status, rxlen, head_rx, count_rx);
+	 */
+
+	if (count_rx < C_RX_BUFFER) {
+
+		addr = (u16 *) (rgbRxBuffer + head_rx * CB_RX_BUFFER + 2);
+		for (i = rxlen >> 1; i > 0; i--)
+			*addr++ = CS8900_RxDATA;
+
+		if (rxlen & 1)
+			*addr++ = CS8900_RxDATA;
+
+		*(u16 *) & rgbRxBuffer[head_rx * CB_RX_BUFFER] = rxlen;
+		head_rx = (head_rx + 1) % C_RX_BUFFER;
+		++count_rx;
+	} else {
+#ifdef DEBUG
+		printf("dropping receive packet\n");
+		
+#endif /* DEBUG */
+		    /* If packet doesn't fit in buffer, skip it */ 
+		    status = get_reg(PP_RxCFG);
+		put_reg(PP_RxCFG, status | PP_RxCFG_Skip1);
+		rxlen = 0;
+	}
+
+	return rxlen;
+}
+
+/* Send a data block via Ethernet. */
+static int cs8900_send(struct descriptor_d *d, const void *packet, size_t size)
+{
+	u16 *addr;
+	unsigned long tmo;
+	unsigned short s;
+	int length = (int)size;	/* this takes care of odd length pkts */
+
+	eth_rx();		/* Receive when we can */
+
+      retry:
+	/* initiate a transmit sequence */
+	CS8900_TxCMD = PP_TxCmd_TxStart_Full;
+	CS8900_TxLEN = length;
+
+	/* Test to see if the chip has allocated memory for the packet */
+	if ((get_reg(PP_BusSTAT) & PP_BusSTAT_TxRDY) == 0) {
+		/* Oops... this should not happen! */
+#ifdef DEBUG
+		printf("cs: unable to send packet; retrying...\n");
+#endif
+		/* Delay before accessing PHY again */
+		tmo = timer_read();
+		/* wait for 5 secs */
+		while (timer_delta(tmo, timer_read()) < 5 * 1000) ;
+		eth_reset();
+		eth_reginit();
+		goto retry;
+	}
+
+	/* Write the contents of the packet */
+	/* assume even number of bytes */
+	for (addr = (u16 *) packet; length > 0; length -= 2)
+		CS8900_TxDATA = *addr++;
+	
+	    /* wait for transfer to succeed */
+	    tmo = timer_read();
+	while ((s = get_reg(PP_TER) & ~0x1F) == 0) {
+		/* if more than 5 sec break */
+		if (timer_delta(tmo, timer_read()) >= 5 * 1000) {
+			
+#ifdef DEBUG
+			    printf("\ntransmission timeout%d /%d\n", tmo,
+				   timer_read());
+			
+#endif /* DEBUG */
+			    break;
+	}
+	}
+
+	/* nothing */ ;
+	if ((s & (PP_TER_CRS | PP_TER_TxOK)) != PP_TER_TxOK) {
+#ifdef DEBUG
+		printf("\ntransmission error %#x\n", s);
+#endif /* DEBUG */
+	} else {
+		
+#ifdef DEBUG
+		    printf("\ntransmission good %#x len%d\n", s,
+			   (u32) ((u32) addr - (u32) packet));
+		
+#endif /* DEBUG */
+	}
+
+	return 0;
+}
+
+static int cs8900_open(struct descriptor_d *d)
+{
+	return 0;		/* No problems */
+}
+
+static ssize_t cs8900_read(struct descriptor_d *d, void *pv, size_t cb)
+{
+	u16 length;
+	int buffer;
+
+	eth_rx();
+
+	if (count_rx == 0)
+		return 0;
+
+	buffer = (head_rx + C_RX_BUFFER - count_rx) % C_RX_BUFFER;
+
+	length = *(u16 *) & rgbRxBuffer[buffer * CB_RX_BUFFER];
+	if (length > cb)
+		length = cb;
+	memcpy(pv, &rgbRxBuffer[buffer * CB_RX_BUFFER + 2], length);
+
+#ifdef DEBUG
+	printf("RX:%d\n", length);
+	
+#endif	/* DEBUG */
+	--count_rx;
+	    return length;
+}
+static __driver_4 struct driver_d cs8900_driver = {
+	.name = DRIVER_NAME,
+	.description = "CS8900 Ethernet driver",
+	.flags = DRIVER_NET,
+	.open = cs8900_open,
+	.close = cs8900_close,
+	.read = cs8900_read,
+	.write = cs8900_send,
+};
+
+#if !defined (CONFIG_SMALL)
+static void cs8900_report(void)
+{
+	if (!initialized)
+		return;
+
+	printf("  CS8900: Chip_id 0x%lx"
+	       "  mac_addr %02x:%02x:%02x:%02x:%02x:%02x\n",
+	       phy_id,
+	       host_mac_address[0], host_mac_address[1],
+	       host_mac_address[2], host_mac_address[3],
+	       host_mac_address[4], host_mac_address[5]);
+}
+#endif /* CONFIG_SMALL */
+
+static __service_6 struct service_d cs8900_service = {
+	.init = cs8900_init,
+#if !defined (CONFIG_SMALL)
+	.report = cs8900_report,
+#endif
+};
diff -purN apex-1.6.8/src/drivers/drv-dm9000.c work_1.6.8/src/drivers/drv-dm9000.c
--- apex-1.6.8/src/drivers/drv-dm9000.c	2009-01-23 09:27:43.000000000 -0800
+++ work_1.6.8/src/drivers/drv-dm9000.c	2010-01-22 14:23:30.000000000 -0800
@@ -248,7 +248,7 @@ void dm9000_dump (char* rgb)
 
   /* *** FIXME: this shouldn't be in the command conditional */
 #if defined (CONFIG_ETHERNET)
-extern char host_mac_address[];
+extern char host_mac_address[]; 
 #else
 static char host_mac_address[6];
 #endif
@@ -306,6 +306,16 @@ static int cmd_eth (int argc, const char
       }
 
       memcpy (host_mac_address, rgb, 6); /* For networking layer */
+      /* we should set mac address for non-eeprom systems */
+      write_reg (dm, DM9000_PAR, host_mac_address[0]);
+      write_reg (dm, DM9000_PAR+1, host_mac_address[1]);
+      write_reg (dm, DM9000_PAR+2, host_mac_address[2]);
+      write_reg (dm, DM9000_PAR+3, host_mac_address[3]);
+      write_reg (dm, DM9000_PAR+4, host_mac_address[4]);
+      write_reg (dm, DM9000_PAR+5, host_mac_address[5]);
+      /* enable broadcast packets */
+      write_reg (dm, DM9000_MAR+5, 0x80);
+
     }
 
     if (PARTIAL_MATCH (argv[1], "s", "ave") == 0) {
@@ -601,7 +611,7 @@ static ssize_t dm9000_read (struct descr
 
   status = read_reg (g_dm9000_default, DM9000_MRCMDX); /* Dummy read */
   status = read_reg (g_dm9000_default, DM9000_MRCMDX);
-  PRINTF ("packet received, status 0x%x\n", status);
+  //printf ("packet received, status 0x%x\n", status);
 
   if ((status & 0xff) != 1) {     /* Return if the receive buffer not ready */
 //    printf ("early termination on receive\n");
diff -purN apex-1.6.8/src/drivers/drv-nand.c work_1.6.8/src/drivers/drv-nand.c
--- apex-1.6.8/src/drivers/drv-nand.c	2009-01-23 09:27:43.000000000 -0800
+++ work_1.6.8/src/drivers/drv-nand.c	2010-01-22 14:23:30.000000000 -0800
@@ -59,7 +59,7 @@
 #include <drv-nand-base.h>
 #include "mach/drv-nand.h"
 
-//#define TALK
+#define TALK
 
 static void wait_on_busy (void);
 
@@ -76,7 +76,7 @@ static void wait_on_busy (void);
 #if defined (CONFIG_NAND_ADDRESS_BYTES)
 # define NAND_ADDRESSES		CONFIG_DRIVER_NAND_ADDRESS_BYTES
 #else
-# define NAND_ADDRESSES		(2)
+# define NAND_ADDRESSES		(3)
 #endif
 
 #if defined (CONFIG_DRIVER_NAND_TYPE_ST)
@@ -131,7 +131,11 @@ inline void nand_sequential_input (unsig
   }
 
   while (available--)
+#if defined (CONFIG_ARCH_LPC313X)
+    NAND_DATA_W = *((char*) pv++);
+#else
     NAND_DATA = *((char*) pv++);
+#endif
 
   NAND_CLE = NAND_PageProgramConfirm;
 
@@ -177,13 +181,25 @@ inline void nand_sequential_input (unsig
   nand_address (page, 0);
 
   while (index--)	   /* Skip to the portion we don't want to change */
+#if defined (CONFIG_ARCH_LPC313X)
+    NAND_DATA_W = 0xff;
+#else
     NAND_DATA = 0xff;
+#endif
 
   while (available--)
+#if defined (CONFIG_ARCH_LPC313X)
+    NAND_DATA_W = *((char*) pv++);
+#else
     NAND_DATA = *((char*) pv++);
+#endif
 
   while (tail--)	   /* Fill to end of block */
+#if defined (CONFIG_ARCH_LPC313X)
+    NAND_DATA_W = 0xff;
+#else
     NAND_DATA = 0xff;
+#endif
 
   NAND_CLE = NAND_AutoProgram;
 
@@ -192,6 +208,47 @@ inline void nand_sequential_input (unsig
 
 #endif
 
+#if defined (CONFIG_DRIVER_NAND_TYPE_MICRON)
+inline void nand_address (unsigned long page, int index)
+{
+  NAND_ALE = (index & 0xff);
+  NAND_ALE = ((index >> 8) & 0xff);
+  NAND_ALE = ( page        & 0xff);
+  NAND_ALE = ((page >>  8) & 0xff);
+#if NAND_ADDRESSES > 2
+  NAND_ALE = ((page >> 16) & 0xff);
+#endif
+}
+
+inline void nand_read_setup (unsigned long page, int index)
+{
+  NAND_CLE = NAND_ReadSetup;
+  nand_address (page, index);
+  NAND_CLE = NAND_Read;
+  wait_on_busy ();
+//  NAND_CLE = NAND_Read;	       /* Return to read after status check */
+}
+
+inline void nand_sequential_input (unsigned long page, unsigned long index,
+				   int available, int tail, const void* pv)
+{
+  /* Reset and read to perform I/O on the data region  */
+  NAND_CLE = NAND_PageProgram;
+  nand_address (page, index);
+
+  while (available--)
+#if defined (CONFIG_ARCH_LPC313X)
+    NAND_DATA_W = *((char*) pv++);
+#else
+    NAND_DATA = *((char*) pv++);
+#endif
+
+  NAND_CLE = NAND_PageProgramConfirm;
+
+  wait_on_busy ();
+}
+#endif
+
 struct nand_chip {
   int id_mask;			/* Bits indicating which ID bytes to match */
   unsigned short id[4];
@@ -208,6 +265,10 @@ const static struct nand_chip chips[] = 
   {  (1<<0) | (1<<1) | (1<<2) | (1<<3),
     { 0x20,    0xf1,    0x80,    0x15},	/* ST - 1 GiB (NAND01GW3B2AN6) */
     128*1024*1024, 128*1024, 2048 }, /* Addr 4 */
+  {  (1<<0) | (1<<3),
+    { 0x2c,    0xac,    0x90,    0x15},	/* Micron */
+    512*1024*1024, 128*1024, 2048 }, /* Addr 4 */
+
 };
 
 const static struct nand_chip* chip;
@@ -581,6 +642,34 @@ int cmd_nand (int argc, const char** arg
   }
 #endif
 
+#if defined (CONFIG_DRIVER_NAND_TYPE_MICRON)
+  if (PARTIAL_MATCH (argv[1], "s", "can") == 0) {
+    int index;
+    int cBad = 0;
+
+    NAND_CS_ENABLE;
+    for (index = 0; index < chip->total_size; index += chip->erase_size) {
+      int page = index/chip->page_size;
+      NAND_CLE = NAND_Reset;
+      wait_on_busy ();
+      nand_read_setup(page, 2048); /* Large block */
+      {
+        int f = 0;
+        if (NAND_DATA != 0xFF) {
+          f = 1;
+	}
+	if (f) {
+          printf ("Block %d bad\n", page/64);
+	  ++cBad;
+	}
+      }
+    }
+    NAND_CS_DISABLE;
+    printf ("%d of %ld blocks are bad\n",
+	    cBad, chip->total_size/chip->erase_size);
+  }
+#endif
+
   return 0;
 }
 
diff -purN apex-1.6.8/src/drivers/Kconfig work_1.6.8/src/drivers/Kconfig
--- apex-1.6.8/src/drivers/Kconfig	2009-01-23 09:27:43.000000000 -0800
+++ work_1.6.8/src/drivers/Kconfig	2010-01-22 14:23:30.000000000 -0800
@@ -151,6 +151,11 @@ config DRIVER_NAND_TYPE_ST
 	help
 	  Implements ST compatible command set.
 
+config DRIVER_NAND_TYPE_MICRON
+	bool "Micron NAND Flash"
+	help
+	  Implements Micron compatible command set.
+
 endchoice	
 
 config DRIVER_NAND_ADDRESS_BYTES
@@ -215,6 +220,15 @@ config DRIVER_DM9000
 	  This driver initializes and activates the Davicom DM9000
 	  Ethernet MAC/PHY controller.
 
+config DRIVER_CS8900
+	bool "CS8900 Integrated Ethernet"
+	depends on USES_CS8900
+	select USE_ETHERNET
+	default y
+	help
+	  This driver initializes and activates the CS8900
+	  Ethernet controller.
+
 config DRIVER_IXP4XX_NPE_ETH
 	bool "IXP4xx NPE Ethernet"
 	depends on USES_IXP4XX_NPE_ETH && EXPERIMENTAL
diff -purN apex-1.6.8/src/drivers/Makefile work_1.6.8/src/drivers/Makefile
--- apex-1.6.8/src/drivers/Makefile	2009-01-23 09:27:43.000000000 -0800
+++ work_1.6.8/src/drivers/Makefile	2010-01-22 14:23:30.000000000 -0800
@@ -19,6 +19,7 @@ obj-$(CONFIG_DRIVER_JFFS2)		+= drv-jffs2
 obj-$(CONFIG_DRIVER_NOR_CFI)		+= drv-nor-cfi.o
 obj-$(CONFIG_DRIVER_COMPACTFLASH)	+= drv-cf.o
 obj-$(CONFIG_DRIVER_SMC91X)		+= drv-smc91x.o
+obj-$(CONFIG_DRIVER_CS8900)		+= drv-cs8900.o
 obj-$(CONFIG_CMD_ETH_DM9000)		+= drv-dm9000.o
 obj-$(CONFIG_DRIVER_DM9000)		+= drv-dm9000.o
 obj-$(CONFIG_DRIVER_FIS)		+= drv-fis.o
diff -purN apex-1.6.8/src/mach-lpc313x/cmd-reset.c work_1.6.8/src/mach-lpc313x/cmd-reset.c
--- apex-1.6.8/src/mach-lpc313x/cmd-reset.c	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/cmd-reset.c	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,58 @@
+/* cmd-reset.c
+
+   written by Durgesh Pattamatta
+   1 Nov 2004
+
+   Copyright (C) 2008 NXP Semiconductors
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+   -----------
+   DESCRIPTION
+   -----------
+
+*/
+
+#include <config.h>
+#include <apex.h>
+#include <command.h>
+#include <service.h>
+
+#include "hardware.h"
+
+
+static void cmd_reset (int argc, const char** argv)
+{
+  release_services ();		
+
+  /* Disable watchdog */
+  WDT_TCR = 0;
+  WDT_MCR = WDT_MCR_STOP_MR1 | WDT_MCR_INT_MR1;
+
+  /*  If TC and MR1 are equal a reset is generated. */
+  WDT_PR  = 0x00000002;
+  WDT_TC  = 0x00000FF0;
+  WDT_MR0 = 0x0000F000;
+  WDT_MR1 = 0x00001000;
+  WDT_EMR = WDT_EMR_CTRL1(0x3);
+  /* Enable watchdog timer; assert reset at timer timeout */
+  WDT_TCR = WDT_TCR_CNT_EN;
+
+  while(1);	/* loop forever and wait for reset to happen */
+
+  /*NOTREACHED*/
+}
+
+static __command struct command_d c_reset = {
+  .command = "reset",
+  .func = (command_func_t) cmd_reset,
+  COMMAND_DESCRIPTION ("reset target")
+  COMMAND_HELP(
+"reset\n"
+"  Reset the system.\n"
+"  This will perform an immediate, hard reset of the CPU.\n"
+  )
+};
diff -purN apex-1.6.8/src/mach-lpc313x/drv-crc32.c work_1.6.8/src/mach-lpc313x/drv-crc32.c
--- apex-1.6.8/src/mach-lpc313x/drv-crc32.c	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/drv-crc32.c	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,101 @@
+/* memory.h
+   
+   written by Durgesh Pattamatta
+   10 Oct 2008
+
+   Copyright (C) 2008 NXP Semiconductors
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+   -----------
+   DESCRIPTION
+   -----------
+
+*/
+
+/* ----- Includes */
+
+#include <config.h>
+#include <linux/types.h>
+#include <apex.h>
+#include <command.h>
+#include <driver.h>
+#include <error.h>
+#include <spinner.h>
+#include <mach/hardware.h>
+
+/* ----- Constants */
+#define crc32table  ((const u32*)0x12015CBC)
+
+void crc32_initialise(u32 *crc)
+{
+  *crc = 0xFFFFFFFF;
+}
+
+void crc32_generate(u32 *pcrc, u8 *data, int length)
+{
+  u32 crc = *pcrc;
+
+  while (length--)
+  {
+    crc = crc32table[(crc ^ *data++) & 0xFF] ^(crc >> 8);
+  }
+
+  *pcrc = crc;
+}
+void crc32_complete(u32 *pcrc)
+{
+  *pcrc ^= 0xFFFFFFFF;
+}
+
+u32 crc32_compute(u8 *data, int length)
+{
+  u32 crc ;
+
+  crc32_initialise(&crc);
+  crc32_generate(&crc, data, length);
+  crc32_complete(&crc);
+  return crc;
+}
+
+int cmd_crc (int argc, const char** argv)
+{
+  struct descriptor_d d;
+  int result = 0;
+  unsigned long crc = 0;
+  ssize_t cb;
+
+  if (argc < 2)
+    return ERROR_PARAM;
+
+  if (   (result = parse_descriptor (argv[1], &d))
+      || (result = open_descriptor (&d))) {
+    printf ("Unable to open '%s'\n", argv[1]);
+    goto fail;
+  }
+
+  cb = d.length - d.index;
+
+  crc = crc32_compute ((u8*)d.start, cb);
+
+  printf ("\rcrc32 0x%lx (%lu) over %d (0x%x) bytes\n", crc, crc, cb, cb);
+
+ fail:
+  close_descriptor (&d);
+
+  return result;
+}
+
+static __command struct command_d c_crc = {
+  .command = "crc",
+  .func = cmd_crc,
+  COMMAND_DESCRIPTION ("compute crc32 checksum using lpc313x tables")
+  COMMAND_HELP(
+"checksum REGION\n"
+"  Calculate a CRC32 checksum over REGION.\n"
+  )
+
+};
diff -purN apex-1.6.8/src/mach-lpc313x/drv-cs8900.h work_1.6.8/src/mach-lpc313x/drv-cs8900.h
--- apex-1.6.8/src/mach-lpc313x/drv-cs8900.h	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/drv-cs8900.h	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,40 @@
+/*  Cirrus Logic CS8900A Ethernet
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+   -----------
+   DESCRIPTION
+   -----------
+   This code is derived from u-boot CS8900 driver code.
+   
+ */
+#if !defined (__DRV_CS8900_H__)
+#    define   __DRV_CS8900_H__
+
+#include <driver.h>
+#include <service.h>
+#include <apex.h>		/* printf, only */
+#include "lpc313x.h"		
+
+
+#define CS8900_BASE     (EXT_SRAM1_PHYS + 0x10000)
+
+	 /* Use the second static bank, with fast timings, as an IOBARRIER */
+#define CS8900_IOBARRIER	(*(volatile unsigned char __force*) 0x60000000)
+
+#define CS8900_IO_OVERRIDE         /* We have a platform implementation */
+
+static inline u16 CS_REG16 (u32 reg)
+{
+  u16 v;
+  CS8900_IOBARRIER;
+  v = __REG16(reg);
+  CS8900_IOBARRIER;
+  return v;
+}
+
+
+#endif /*__DRV_CS8900_H__*/
diff -purN apex-1.6.8/src/mach-lpc313x/drv-dm9000.h work_1.6.8/src/mach-lpc313x/drv-dm9000.h
--- apex-1.6.8/src/mach-lpc313x/drv-dm9000.h	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/drv-dm9000.h	2010-03-15 13:49:01.000000000 -0700
@@ -0,0 +1,54 @@
+/* drv-dm9000.h
+
+   written by Marc Singer
+   2 June 2006
+
+   Copyright (C) 2006 Marc Singer
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+   -----------
+   DESCRIPTION
+   -----------
+
+*/
+
+#if !defined (__MACH_DRV_DM9000_H__)
+#    define   __MACH_DRV_DM9000_H__
+
+/* ----- Includes */
+#include "lpc313x.h"
+/* ----- Types */
+
+/* ----- Globals */
+
+/* ----- Prototypes */
+
+# define DM_WIDTH	16
+
+/* Use the second static bank, with fast timings, as an IOBARRIER. ARM MPMC contoller
+as part of low power design doesn't de-assert nCS and nOE for consecutive reads but 
+just changes address. But DM9000 requires nCS and nOE change between address. So access
+other chip select area to force de-assertion of nCS and nOE. Or else wait for long time 
+such as 80 usecs. 
+LPC313x has external logic outside of MPMC IP to toggle nOE to split consecutive reads.
+For this work SYS_MPMC_WTD_DEL0 & SYS_MPMC_WTD_DEL1 should be programmed with MPMC_STWTRD0
+& MPMC_STWTRD1 values. The logic only deactivates the nOE for one clock cycle which is
+11.1nsec but DM9000 needs 80nsec between nOEs. So lets add some dummy instruction such as
+udealy(0) to compensate for extra 70nsec.
+*/
+
+/* if EA_DISP_QVGA_LCD_V2 is used then use following macro else use udelay macro */
+//# define DM_IO_DELAY	do { *(volatile unsigned char __force*) (EXT_SRAM0_PHYS) = 0;} while(0)
+# define DM_IO_DELAY	do { GPIO_STATE(0);} while(0)
+
+# define DM_PHYS	(EXT_SRAM1_PHYS)		/* Dev MAC/PHY */
+# define DM_PHYS_INDEX	(DM_PHYS + 0)
+# define DM_PHYS_DATA	(DM_PHYS + 0x10000)
+# define DM_NAME	"dev"
+
+
+#endif  /* __MACH_DRV_DM9000_H__ */
diff -purN apex-1.6.8/src/mach-lpc313x/drv-lpcnand.c work_1.6.8/src/mach-lpc313x/drv-lpcnand.c
--- apex-1.6.8/src/mach-lpc313x/drv-lpcnand.c	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/drv-lpcnand.c	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,1163 @@
+/* drv-lpcnand.c
+
+written by Durgesh Pattamatta
+19 Oct 2005
+
+Copyright (C) 2008 NXP Semiconductors
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+version 2 as published by the Free Software Foundation.
+Please refer to the file debian/copyright for further details.
+
+-----------
+DESCRIPTION
+-----------
+
+Divide NAND into multiple sections:
+
+1. BootROM paramas: Block 0
+- page 0, 16, 32, 64, 128, 256 contains param structure (lnand:0x00+512)
+- if param page has to be updates corrupt 0 and then write new
+one in 16 and on. This allows only 6 updates to param page.
+- page 1-15, 17-31, 33-63, 65 -127, 129-255 contain bad block lists (lnand:2k+512)
+- if bad block list has to be updates corrupt 1-15 and then write new
+list from page 17 and on. This allows only 6 updates to bad block list page.
+- This release only supports writing once
+2. Apex image: Block 1, 2 & 3 (lnand:128k+384k)
+3. Apex Environment: Block 4 & 5 (lnand:512k+256k)
+- Restrict env size to 2K (nand page size) so that we could wear-level the env 
+page accros block 4 & 5. 
+- provide "lnand cleanenv" to erase both block 4 & 5
+4. Kernel image: Two 2MB worth blocks. so that we could store 1 current and back-up image (lnand:768k+4m)
+5. Ramdisk image: 16MB (lnand: +16m)
+6. JFFS2 partition (not managed by Apex) 
+
+*/
+
+#include <config.h>
+#include <apex.h>
+#include <driver.h>
+#include <service.h>
+#include <linux/string.h>
+#include <spinner.h>
+#include <error.h>
+#include <command.h>
+
+#include <mach/drv-nand.h>
+
+//#define TALK 1
+#undef TALK 
+
+#if defined (TALK)
+#define PRINTF(f...)    printf (f)
+#define ENTRY(l)    printf ("%s\n", __FUNCTION__)
+#define DBG(l,f...)   do { if (TALK >= l) printf (f); } while (0)
+#else
+#define PRINTF(f...)    do {} while (0)
+#define ENTRY(l)    do {} while (0)
+#define DBG(l,f...)   do {} while (0)
+#endif
+
+
+/* NAND command defines */
+#define NAND_Reset			(0xff)
+#define NAND_ReadID			(0x90)
+#define NAND_Status			(0x70)
+#define NAND_ReadSetup			(0x00)
+#define NAND_Read			(0x30)
+#define NAND_Erase			(0x60)
+#define NAND_EraseConfirm		(0xd0)
+#define NAND_PageProgram		(0x80)
+#define NAND_PageProgramConfirm		(0x10)
+#define NAND_RandomDataInput		(0x85)
+
+#define NAND_Fail			(1<<0)
+#define NAND_CacheErr			(1<<1)
+#define NAND_CacheReady			(1<<5)
+#define NAND_Ready			(1<<6)
+#define NAND_Writable			(1<<7)
+
+/* define to implement wear leveling of Apex environment section */
+#define APEX_NAND_ENV_START_PAGE	(4 * chip->pages_per_block)
+#define APEX_NAND_ENV_END_PAGE		((6 * chip->pages_per_block) - 1)
+
+/* chip seclect to which NAND dvice is connected 0, 1, 2, or 3 */
+#define CURR_CS		0
+
+/* Timeouts for various NAND operations in msec */
+#define TIMEOUT_WAIT_RBY           10
+#define TIMEOUT_WAIT_RESET         100
+#define TIMEOUT_WAIT_READ          2
+#define TIMEOUT_WAIT_ERASE         50
+#define TIMEOUT_WAIT_PROGRAM       5
+#define TIMEOUT_WAIT_INTERRUPT     5
+
+/* extern functions */
+extern u32 crc32_compute(u8 *data, int length);
+
+static const NAND_BOOT_CFG_PARAMS_T chips[] = 
+{
+	/* Micron MT*/
+#if defined (CONFIG_MICRON_MT29F2G08)
+	{
+		.tag = "NANDflsh", //{'N', 'A', 'N', 'D', 'f', 'l', 's', 'h',},
+		.interface_width = 8,
+		.page_size_in_bytes = 2048,
+		.page_size_in_32bit_words = 512,
+		.pages_per_block = 64,
+		.nbr_of_blocks = 2048,
+		.amount_of_address_bytes = 5,
+		.amount_of_erase_address_bytes = 3,
+		.support_read_terminate = 1,
+		.page_increment_byte_nr = 2,
+		.device_name = { 0x2C, 0xAA, 0xFF, 0x15, 0x20, 'M', 'T', '2', '9', 'F', '2', 'G', '0', '8',}, /* first 4bytes to fill with readid response */
+		/* assuming 90MHz clock (1clock = 11ns)to NAND block */
+		/* Note, timing macros tcopy naake clk +1 values. */
+		/* tsrd=3, tals=3, talh=1, tcls=3, tclh=1, */
+		.timing1 = NAND_TIM1_TSRD(3) | NAND_TIM1_TALS(3) | NAND_TIM1_TALH(1) | NAND_TIM1_TCLS(3) | NAND_TIM1_TCLH(1),
+		/* tdrd=3, tebi=1, tch=1, tcs=4, treh=2, trp=4, twh=2, twp = 3*/
+		.timing2 = NAND_TIM2_TDRD(3) | NAND_TIM2_TEBI(1) | NAND_TIM2_TCH(1) | NAND_TIM2_TCS(4) | NAND_TIM2_TRH(2) |
+			NAND_TIM2_TRP(4) | NAND_TIM2_TWH(2) | NAND_TIM2_TWP(3),
+		.ecc_mode = 5,
+		.id_mask = 0x6, /*except 2nd & 3rd byte check remains id bytes */
+	},
+#endif
+#if defined (CONFIG_MICRON_MT29F4G08)
+	{
+		.tag = "NANDflsh", //{'N', 'A', 'N', 'D', 'f', 'l', 's', 'h',},
+		.interface_width = 8,
+		.page_size_in_bytes = 2048,
+		.page_size_in_32bit_words = 512,
+		.pages_per_block = 64,
+		.nbr_of_blocks = 4096,
+		.amount_of_address_bytes = 5,
+		.amount_of_erase_address_bytes = 3,
+		.support_read_terminate = 1,
+		.page_increment_byte_nr = 2,
+		.device_name = { 0x2C, 0xAC, 0x90, 0x15, 0x54, 'M', 'T', '2', '9', 'F', '4', 'G', '0', '8',}, /* first 4bytes to fill with readid response */
+		/* assuming 90MHz clock (1clock = 11ns)to NAND block */
+		/* Note, timing macros tcopy naake clk +1 values. */
+		/* tsrd=3, tals=3, talh=1, tcls=3, tclh=1, */
+		.timing1 = NAND_TIM1_TSRD(3) | NAND_TIM1_TALS(3) | NAND_TIM1_TALH(1) | NAND_TIM1_TCLS(3) | NAND_TIM1_TCLH(1),
+		/* tdrd=3, tebi=1, tch=1, tcs=4, treh=2, trp=4, twh=2, twp = 3*/
+		.timing2 = NAND_TIM2_TDRD(3) | NAND_TIM2_TEBI(1) | NAND_TIM2_TCH(1) | NAND_TIM2_TCS(4) | NAND_TIM2_TRH(2) |
+			NAND_TIM2_TRP(4) | NAND_TIM2_TWH(2) | NAND_TIM2_TWP(3),
+		.ecc_mode = 5,
+		.id_mask = 0x6, /*except 2nd & 3rd byte check remains id bytes */
+	},
+#endif
+#if defined (CONFIG_SAMSUNG_K9K8G)
+	{
+		.tag = "NANDflsh", //{'N', 'A', 'N', 'D', 'f', 'l', 's', 'h',},
+		.interface_width = 8,
+		.page_size_in_bytes = 0x0800,
+		.page_size_in_32bit_words = 0x0200,
+		.pages_per_block = 0x0040,
+		.nbr_of_blocks = 0x0800,
+		.amount_of_address_bytes = 5,
+		.amount_of_erase_address_bytes = 3,
+		.support_read_terminate = 1,
+		.page_increment_byte_nr = 2,
+		.device_name = { 0xEC, 0xD3, 0x51, 0x95, 0x20, 'K', '9', 'K', '8', 'G', '0', '8', }, /* first 4bytes to fill with readid response */
+		/* assuming 90MHz clock (1clock = 11ns)to NAND block */
+		/* Note, timing macros take clk +1 values. */
+		/* tsrd=2, tals=3, talh=1, tcls=3, tclh=2, */
+		.timing1 = NAND_TIM1_TSRD(2) | NAND_TIM1_TALS(3) | NAND_TIM1_TALH(1) | NAND_TIM1_TCLS(3) | NAND_TIM1_TCLH(2),
+		/* tdrd=2, tebi=1, tch=1, tcs=4, treh=2, trp=4, twh=2, twp = 3*/
+		.timing2 = NAND_TIM2_TDRD(2) | NAND_TIM2_TEBI(1) | NAND_TIM2_TCH(1) | NAND_TIM2_TCS(4) | NAND_TIM2_TRH(2) |
+			NAND_TIM2_TRP(4) | NAND_TIM2_TWH(2) | NAND_TIM2_TWP(3),
+		.ecc_mode = 5,
+		.id_mask = 0x6, /*except 2nd & 3rd byte check remains id bytes */
+	},
+#endif
+#if defined (CONFIG_TOSHIBA_TC58DVM82A)
+#define USE8BITCOLADDR
+	{
+		.tag = "NANDflsh", //{'N', 'A', 'N', 'D', 'f', 'l', 's', 'h',},
+		.interface_width = 8,
+		.page_size_in_bytes = 512,
+		.page_size_in_32bit_words = 128,
+		.pages_per_block = 32,
+		.nbr_of_blocks = 2048,
+		.amount_of_address_bytes = 3,
+		.amount_of_erase_address_bytes = 2,
+		.support_read_terminate = 0,
+		.page_increment_byte_nr = 2,
+		.device_name = { 0x98, 0x73, 0xA5, 0xBA, 0xFF, 'T', 'C', '5', '8', 'D', 'V', 'M', '8', '2', 'A' }, /* first 4 bytes to fill with readid response */
+		/* assuming 90MHz clock (1clock = 11ns)to NAND block */
+		/* Note, timing macros take clk +1 values. */
+		/* tsrd=2, tals=3, talh=1, tcls=3, tclh=2, */
+		.timing1 = NAND_TIM1_TSRD(2+1) | NAND_TIM1_TALS(3+1) | NAND_TIM1_TALH(1+1) | NAND_TIM1_TCLS(3+1) | NAND_TIM1_TCLH(2+1),
+		/* tdrd=2, tebi=1, tch=1, tcs=4, treh=2, trp=4, twh=2, twp = 3*/
+		.timing2 = NAND_TIM2_TDRD(2+1) | NAND_TIM2_TEBI(1+1) | NAND_TIM2_TCH(1+1) | NAND_TIM2_TCS(4+1) | NAND_TIM2_TRH(2+1) |
+			NAND_TIM2_TRP(4+1) | NAND_TIM2_TWH(2+1) | NAND_TIM2_TWP(3+1),
+		.ecc_mode = 5,
+		.id_mask = 0x6, /*except 2nd & 3rd byte check remains id bytes */
+	},
+#endif
+};
+
+/* forward declarations */
+static void nand_reset (void);
+static ssize_t lpcnand_write (struct descriptor_d* d, const void* pv, size_t cb);
+
+/*global variables */
+static NAND_BOOT_CFG_PARAMS_T* chip;
+static int g_curr_buf = 0;
+static int nand_modify;
+static int blk0enab;
+static u32 nand_bbl_array [(NANDFLASH_BADBLOCK_LIST_LENGTH + 4 / 32)];
+
+/* Mark a block as bad in the memory based bad block table (from block 0) */
+static void nand_setbb_array_bit(u32 pagenum) {
+	u32 blocknum = pagenum / chip->pages_per_block;
+	u32 idx = blocknum / 32;
+	u32 offs = 1 << (blocknum - (idx * 32));
+
+	nand_bbl_array[idx] &= ~offs;
+}
+
+/* Check if a block in the page is good (!0) or bad (0) in the memory
+   based bad block table */
+static int nand_checkbb_array_bit(u32 pagenum) {
+	u32 blocknum = pagenum / chip->pages_per_block;
+	u32 idx = blocknum / 32;
+	u32 offs = 1 << (blocknum - (idx * 32));
+
+	/* Returns '!0' if the block is good */
+	return (int) (nand_bbl_array[idx] & offs);
+}
+
+/* Modify access check */
+static int nand_modfiy_ok(void) {
+	if (!nand_modify) {
+		printf("NAND block 0 has not been formatted yet!. Modify\n");
+		printf("functions have been disabled. Use the lpcnand f\n");
+		printf("command to prepare NAND FLASH prior to use\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+/* wait_on_busy
+
+checks the status of the device and returns when it is no longer
+busy.  
+*/
+static void nand_reset (void)
+{
+	unsigned long time_start = timer_read ();
+	/* clear edge status */
+	volatile u32 status = NANDC_CHECK_STS;
+
+	/* following line is just avoid warning. status gets cleaed by reading
+	the register. */
+	if (status) 
+		status = 0;
+
+	NANDC_SET_CMD = NAND_Reset;
+	/* Wait for MLC NAND ready */
+	while (!(NANDC_CHECK_STS & NAND_CHK_STS_RB_EDGE(CURR_CS))) {
+		if (timer_delta (time_start, timer_read ()) >= TIMEOUT_WAIT_RBY) {
+			printf ("\nbailing at timeout status 0x%lx \n", NANDC_CHECK_STS);
+			break;
+		}
+	}
+}
+
+/* wait_on_int
+Waits for one of the requested interrupts to get set.  
+*/
+static void wait_on_int (u32 int_mask, u32 tmo)
+{
+	unsigned long time_start = timer_read ();
+	/* Wait for MLC NAND ready */
+	while (!(NANDC_IRQ_STS_RAW & int_mask)) {
+		if (timer_delta (time_start, timer_read ()) >= tmo) {
+			printf ("\nbailing at timeout status 0x%08lx bits 0x%08x\n",
+				NANDC_IRQ_STS_RAW, int_mask);
+			break;
+		}
+	}
+}
+
+inline void lpcnand_address (unsigned long page, int index)
+{
+#ifdef USE8BITCOLADDR
+	/* Modify address for index value */
+	if (index >= 256)
+		index -= 256;
+	if (index >= 256)
+		index -= 256;
+
+	NANDC_SET_ADDR = (index & 0xff);
+	NANDC_SET_ADDR = ( page        & 0xff);
+	NANDC_SET_ADDR = ((page >>  8) & 0xff);
+printf("ADDR 0x%02x 0x%02x 0x%02x", (index & 0xff),
+	( page        & 0xff), ((page >>  8) & 0xff));
+
+	if (chip->amount_of_address_bytes > 3) {
+		NANDC_SET_ADDR = ((page >> 16) & 0xff);
+printf(" 0x%02x", ((page >>  16) & 0xff));
+}
+printf("\n");
+
+#else
+	NANDC_SET_ADDR = (index & 0xff);
+	NANDC_SET_ADDR = ((index >> 8) & 0xff);
+	NANDC_SET_ADDR = ( page        & 0xff);
+	NANDC_SET_ADDR = ((page >>  8) & 0xff);
+
+	if (chip->amount_of_address_bytes > 4)
+		NANDC_SET_ADDR = ((page >> 16) & 0xff);
+#endif
+}
+
+inline void lpcnand_read_setup (unsigned long page, int index)
+{
+	/* clear edge status */
+	NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
+
+#ifdef USE8BITCOLADDR
+	if (index < 256) {
+		NANDC_SET_CMD = NAND_ReadSetup;
+printf("0x00-read index %d", index);
+	}
+	else if (index < 512) {
+		NANDC_SET_CMD = 0x01;
+printf("0x01-read index %d", index);
+	}
+	else {
+		NANDC_SET_CMD = 0x50;
+printf("0x50-read index %d", index);
+	}
+
+#else
+	NANDC_SET_CMD = NAND_ReadSetup;
+#endif
+
+	lpcnand_address (page, index);
+	if (chip->support_read_terminate) {
+		NANDC_SET_CMD = NAND_Read;
+}
+	wait_on_int (NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_READ);
+}
+
+
+/* Check block 0 for boot ROM header and build saved bad block list */
+static int lpcnand_block0_good(void)
+{
+	char tag [9];
+	int i, val;
+	unsigned long idx = 0xFFFFFFFF, page = 1;
+	int offs = 0, entries;
+
+	/* Read block 0, page 0, offset 0 */
+	lpcnand_read_setup(0, 0);
+
+	for (i = 0; i < 9; i++)
+		tag[i] = (char) NANDC_READ_DATA;
+	tag[8] = '\0';
+
+	if (strcmp(tag, "NANDflsh") != 0)
+		return 0;
+
+	memset((void*)nand_bbl_array, 0xFF, sizeof(nand_bbl_array));
+
+	/* Read bad block data */
+	lpcnand_read_setup(page, offs);
+
+	/* Get the number of bad blocks */
+	if (idx == 0xFFFFFFFF) {
+		idx = (NANDC_READ_DATA & 0xFF) << 0;
+		idx |= (NANDC_READ_DATA & 0xFF) << 8;
+		idx |= (NANDC_READ_DATA & 0xFF) << 16;
+		idx |= (NANDC_READ_DATA & 0xFF) << 24;
+	}
+	if (idx == 0xFFFFFFFF) {
+		/* Something is wrong */
+		nand_modify = 0;
+
+		return 0;
+	}
+
+	/* Generate list from entries */
+	entries = (int) idx;
+	while (entries > 0) {
+		val = ((NANDC_READ_DATA & 0xFF) << 0) | ((NANDC_READ_DATA & 0xFF) << 8) |
+			((NANDC_READ_DATA & 0xFF) << 16) | ((NANDC_READ_DATA & 0xFF) << 24);
+		if ((val & 0x00FFFFFF) == ((((u32) 'B') << 0) | (((u32) 'A') << 8) |
+			(((u32) 'D') << 16))) {
+			/* Go to the next page and continue */
+			offs += 512;
+			if (offs >= chip->page_size_in_bytes) {
+				page++;
+				offs = 0;
+			}
+
+			/* Read bad block data */
+			lpcnand_read_setup(page, offs);
+		}
+		else {
+			nand_setbb_array_bit(val * chip->pages_per_block);
+			entries--;
+		}
+	}
+
+	return 1;
+}
+
+static void write_badblock_list(void)
+{
+	u32* bad_list_buf = (u32*)EXT_SDRAM_PHYS;
+	char* buff_ptr;
+	u32 temp_buff[2];
+	int curr_pos = 0;
+	int magic_word_pos;
+	int page_nr;
+	int cBad = 0;
+	struct descriptor_d desc;
+
+	DBG (1, "before memset buf:0x%08x len:%d\n", (u32)bad_list_buf, NANDFLASH_BADBLOCK_LIST_LENGTH * 4);
+
+	/* fill buffer with 0xFF */
+	memset((void*)bad_list_buf, 0xFF, NANDFLASH_BADBLOCK_LIST_LENGTH * 4);
+	memset((void*)nand_bbl_array, 0xFF, sizeof(nand_bbl_array));
+	
+	DBG (1, "memset done page:%d / %d\n", chip->pages_per_block, chip->nbr_of_blocks);
+	cBad = 0;
+	/* build bad block list page */
+	for (page_nr = chip->pages_per_block; 
+		page_nr < (chip->nbr_of_blocks * chip->pages_per_block); 
+		page_nr += chip->pages_per_block) {
+
+		DBG (1, "page_nr:%d \r", page_nr);
+		/* reset nand device */
+		nand_reset ();
+		/* index to spare area */
+		lpcnand_read_setup(page_nr, chip->page_size_in_bytes); 
+		if (NANDC_READ_DATA != 0xFF) {
+			printf ("Block %d bad\n", page_nr/chip->pages_per_block);
+			++cBad;
+			nand_setbb_array_bit(page_nr);
+			*((u32*)(bad_list_buf + cBad)) = page_nr/chip->pages_per_block;
+			if (cBad > NANDFLASH_BADBLOCK_LIST_LENGTH)
+				break;
+		}
+	}
+	/* update bad block count */
+	*bad_list_buf = cBad;
+
+	curr_pos = 0;
+	page_nr = 1;
+	while (curr_pos < (cBad + 1)) {
+
+		if ( (cBad + 1 - curr_pos) < (chip->page_size_in_32bit_words - 2)) {
+			magic_word_pos = cBad + 1;
+		}
+		else {
+			magic_word_pos = curr_pos + chip->page_size_in_32bit_words - 2;
+		}
+		DBG (1, "curr_pos:%d, cBad:%d, magic_pos:%d\n", curr_pos, cBad, magic_word_pos);
+
+		/* save last 2 words in current page to write with magic id & CRC.
+		Not needed if CBad < (chip->page_size_in_32bit_words - 2)*/
+		temp_buff[0] = bad_list_buf[magic_word_pos];
+		temp_buff[1] = bad_list_buf[magic_word_pos + 1];
+
+		/* insert magic word */
+		buff_ptr = (char*)&bad_list_buf[magic_word_pos];
+		buff_ptr[0] = 'B';
+		buff_ptr[1] = 'A';
+		buff_ptr[2] = 'D';
+		buff_ptr[3] = (char)(page_nr & 0xFF);
+
+		/* compute CRC32 */
+		bad_list_buf[magic_word_pos + 1] = crc32_compute((u8*)&bad_list_buf[curr_pos], 
+			((u32)&buff_ptr[4] - (u32)&bad_list_buf[curr_pos]));
+
+		/* create the nand descriptor for write routine */
+		desc.index = 0;
+		desc.start = page_nr * chip->page_size_in_bytes;
+		desc.length = chip->page_size_in_bytes;
+
+		DBG (1, "buff_ptr:0x%08x, start:0x%08x, page_nr:%d\n", (u32)buff_ptr, desc.start, page_nr);
+
+		/* write the bad page */
+		if (lpcnand_write (&desc, (void*)(bad_list_buf + curr_pos), 
+			chip->page_size_in_bytes) < chip->page_size_in_bytes) {
+			printf ("Write bad block page %d failed\n", page_nr);
+			return;
+		}
+		
+		/*put back last 2 words*/
+		bad_list_buf[magic_word_pos] = temp_buff[0];
+		bad_list_buf[magic_word_pos + 1] = temp_buff[1];
+		/* move to next page */
+		page_nr++;
+		/* update current position in bad block list */
+		curr_pos = magic_word_pos;
+	}
+}
+
+static void format_device(void) {
+	void* ptr;
+	int count;
+	int tmp;
+
+	tmp = blk0enab;
+	blk0enab = 1;
+	nand_modify = 1;
+
+	/* erase block 0 */
+	NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
+	NANDC_SET_CMD = NAND_Erase;
+	for (count=0; count< chip->amount_of_erase_address_bytes; count++ )
+		NANDC_SET_ADDR = 0x00;
+
+	NANDC_SET_CMD = NAND_EraseConfirm;
+	wait_on_int(NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_ERASE);
+	/* Send page program command  */
+	NANDC_SET_CMD = NAND_PageProgram;
+	lpcnand_address (0, 0);
+	/* set HW flow control to write the page and do ECC */
+	NANDC_IRQ_STS_RAW = 0xFFFFFFFF;
+	/* build param page */
+	ptr = (g_curr_buf)?(void*)NANDC_RAM1_PHYS:(void*)NANDC_RAM0_PHYS;
+	memcpy(ptr, (void*)chip, sizeof(NAND_BOOT_CFG_PARAMS_T));
+	memset(ptr + sizeof(NAND_BOOT_CFG_PARAMS_T), 
+		0, (LPC313x_NAND_BPARAM_PAGE_SZ - sizeof(NAND_BOOT_CFG_PARAMS_T) - 4));
+	/* compute CRC32. */
+	*((u32*)(ptr + (LPC313x_NAND_BPARAM_PAGE_SZ - 4))) = 
+		crc32_compute((g_curr_buf)?(u8*)NANDC_RAM1_PHYS:(u8*)NANDC_RAM0_PHYS, 
+		LPC313x_NAND_BPARAM_PAGE_SZ - 4);
+
+	DBG (1, "crc 0x%08x / 0x%08x\n",  
+		*((u32*)(ptr + (NANDC_BUF_SZ - 4))), (u32)(ptr + (NANDC_BUF_SZ - 4)));
+	/* fill rest of the sub-page.*/ 
+	memset(ptr + LPC313x_NAND_BPARAM_PAGE_SZ, 
+		0xFF, (NANDC_BUF_SZ - LPC313x_NAND_BPARAM_PAGE_SZ));
+	/*When 512-516 bytes are written it will trigger ECC computation.*/
+	*((u32*)(ptr + NANDC_BUF_SZ)) = 0xFFFFFFFF;
+
+	/* see if ECC check is enabled */
+	if (NANDC_CFG & NAND_CFG_EC)
+		wait_on_int((g_curr_buf)?NAND_IRQ_ECC_ENC_RAM1:NAND_IRQ_ECC_ENC_RAM0, TIMEOUT_WAIT_PROGRAM);
+	/* write param page */
+	NANDC_CTRL_FLOW = (g_curr_buf)?NAND_CTRLFLW_WRITE_RAM1:NAND_CTRLFLW_WRITE_RAM0;
+	wait_on_int((g_curr_buf)?NAND_IRQ_WR_RAM1:NAND_IRQ_WR_RAM0, TIMEOUT_WAIT_PROGRAM);
+	/*toggle buff */
+	g_curr_buf ^= 1;
+	NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
+	NANDC_SET_CMD = NAND_PageProgramConfirm;
+	wait_on_int(NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_PROGRAM);
+	/* check status */
+	NANDC_SET_CMD = NAND_Status;
+	udelay(5);// Wait for tWHR
+	if (NANDC_READ_DATA & NAND_Fail) {
+		printf ("Write param page failed\n");
+		nand_modify = 0;
+		blk0enab = tmp;
+		return;
+	}
+
+	/* now write bad block list page */
+	write_badblock_list();
+
+	blk0enab = tmp;
+}
+
+/* nand_init
+
+probes the NAND flash device.
+
+Note that the status check redundantly sends the Status command
+when we are not using the CONFIG_NAND_LPD mode.  It's left in for
+now.
+*/
+static void lpcnand_init (void)
+{
+	unsigned short id[4];
+	u32 config = NAND_CFG_DC;//NAND_CFG_ECGC; 
+
+	/* enable NAND clocks */
+	cgu_clk_en_dis(CGU_SB_NANDFLASH_S0_CLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_NANDFLASH_NAND_CLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_NANDFLASH_PCLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_NANDFLASH_AES_CLK_ID, 0);
+
+	/* reset NAND module through CGU */
+	cgu_soft_reset_module(NANDFLASH_NAND_RESET_N_SOFT);
+	cgu_soft_reset_module(NANDFLASH_ECC_RESET_N_SOFT);
+	cgu_soft_reset_module(NANDFLASH_AES_RESET_N_SOFT); /* needed for LPC3153 & 54 parts only */
+	
+	cgu_clk_en_dis(CGU_SB_NANDFLASH_ECC_CLK_ID, 1);
+
+	/* NAND muxing */
+	SYS_MUX_NAND_MCI = 0;
+
+	/* select bank0*/
+	NANDC_SET_CE = NAND_SETCE_WP | NAND_SETCE_CV(CURR_CS);
+
+	/* reset nand device */
+	nand_reset ();
+
+	NANDC_SET_CMD = NAND_Status;
+	udelay(5);
+	if ((NANDC_READ_DATA & NAND_Ready) == 0)
+		goto exit;
+
+	NANDC_SET_CMD = NAND_ReadID;
+	NANDC_SET_ADDR = 0;
+
+	id[0] = NANDC_READ_DATA;
+	id[1] = NANDC_READ_DATA;
+	id[2] = NANDC_READ_DATA;
+	id[3] = NANDC_READ_DATA;
+
+	for (chip = (NAND_BOOT_CFG_PARAMS_T*)&chips[0];
+		chip < (chips + sizeof(chips)/sizeof (NAND_BOOT_CFG_PARAMS_T));
+		++chip) {
+#define _M(i)\
+	((chip->id_mask & (1<<(i))) || (id[i] == chip->device_name[i]))
+		
+			DBG(1, "ID 0x%02x/0x%02x/0x%02x/0x%02x\n",
+				chip->device_name[0], chip->device_name[1],
+				chip->device_name[2], chip->device_name[3]);
+			if (_M (0) && _M (1) && _M (2) && _M (3)) {
+				DBG(1, "ID matchded\n");
+				break;
+			}
+#undef _M
+	}
+
+	if (chip > (chips + sizeof(chips)/sizeof (chips[0])))
+		chip = NULL;
+
+	if (chip) {
+		/* init timings */
+		NANDC_IRQ_TIMING1 = chip->timing1;
+		NANDC_IRQ_TIMING2 = chip->timing2;
+		/* build config value for the device */
+		/* set ecc type */
+		switch (chip->ecc_mode)
+		{
+		case 8:
+			config |= NAND_CFG_8BIT_ECC;
+		case 5:
+			config |= NAND_CFG_EC;
+			break;
+		default:
+			break;
+		}
+
+		/* write the final config value */
+		NANDC_CFG = config;
+	}
+	printf ("\n* LPC-NAND flash");
+
+	if (chip)
+		printf (" %d MiB total, %d KiB erase, %d B page"
+		" (0x%02x/0x%02x/0x%02x/0x%02x)\n",
+		(chip->nbr_of_blocks * chip->page_size_in_bytes * chip->pages_per_block)/(1024*1024), 
+		(chip->page_size_in_bytes * chip->pages_per_block)/1024,
+		chip->page_size_in_bytes,
+		id[0], id[1], id[2], id[3]);
+	else
+		printf (" unknown 0x%02x/0x%02x/0x%02x/0x%02x\n",
+		id[0], id[1], id[2], id[3]);
+
+ 	/* Does block 0 have a valid structure yet? */
+	blk0enab = 0;
+	nand_modify = 0;
+
+	if (lpcnand_block0_good() != 0) {
+		/* Populate bad block list array from block 0 */
+		nand_modify = 1;
+	}
+	else {
+#if defined (CONFIG_AUTOFORMAT_BLOCK0)
+		printf("NAND Block 0 is being formatted.\n");
+		format_device();
+
+#else
+		printf("NAND Block 0 has not yet been formatted for operation. NAND modify\n"
+			"operations have been temporarily suspended. Use the 'lpcnand format\n"
+			"command to setup block 0.\n");
+#endif
+	}
+
+exit:
+	NAND_CS_DISABLE;
+}
+
+static int lpcnand_open (struct descriptor_d* d)
+{
+	if (!chip)
+		return -1;
+
+	/* Check if param page is programmed */
+
+	return 0;
+}
+
+static int read_buffer(u8 *buffer, int bytes) {
+	/* set HW flow control to read the page and do ECC */
+	NANDC_IRQ_STS_RAW = 0xFFFFFFFF;
+
+	NANDC_CTRL_FLOW = (g_curr_buf)?NAND_CTRLFLW_READ_RAM1:NAND_CTRLFLW_READ_RAM0;
+	wait_on_int((g_curr_buf)?NAND_IRQ_RD_RAM1:NAND_IRQ_RD_RAM0, TIMEOUT_WAIT_RBY);
+
+	/* see if ECC check is enabled */
+	if (NANDC_CFG & NAND_CFG_EC)
+		wait_on_int((g_curr_buf)?NAND_IRQ_ECC_DEC_RAM1:NAND_IRQ_ECC_DEC_RAM0, TIMEOUT_WAIT_RBY);
+
+	memcpy(buffer, (g_curr_buf)?(void*)NANDC_RAM1_PHYS:(void*)NANDC_RAM0_PHYS, bytes);
+	/* toggle buffer */
+	g_curr_buf ^= 1;
+
+	return 1;
+}
+
+static ssize_t lpcnand_read (struct descriptor_d* d, void* pv, size_t cb)
+{
+	ssize_t cbRead = 0;
+	unsigned long blk;
+
+	if (!chip)
+		return cbRead;
+
+	if (nand_modfiy_ok() == 0)
+		return 0;
+
+	if (d->index + cb > d->length)
+		cb = d->length - d->index;
+
+	while (cb) {
+		unsigned long page  = (d->start + d->index)/chip->page_size_in_bytes;
+		int index = (d->start + d->index) & (chip->page_size_in_bytes - 1);
+		int available = chip->page_size_in_bytes - index;
+		int toread;
+
+		/* this driver always reads on page boundaries only */
+		if (index & (NANDC_BUF_SZ -1)) {
+			printf("unaligned read 0x%08x\n", d->start + d->index);
+			return 0;
+		}
+		/* if index is not 0 then add 16 byte for every 512 block. */
+		index += (((index >> 9) & 0x3)) * 16;
+
+		/* If the current block is bad, move to the next block */
+		if (nand_checkbb_array_bit(page) == 0) {
+			blk = page / chip->pages_per_block;
+			printf("Read:Skipping bad block %d\n", (int) blk);
+
+			/* Continue at next block */
+			d->start = (blk + 1) * chip->pages_per_block * chip->page_size_in_bytes;
+			d->index = 0;
+		}
+		else {
+			if (available > cb)
+				available = cb;
+
+			d->index += available;
+			cb -= available;
+			cbRead += available;
+
+			/* reset nand device */
+			nand_reset ();
+			/* do read setup */
+			lpcnand_read_setup (page, index);
+
+			while (available > 0) {
+				toread = (available < NANDC_BUF_SZ)?available:NANDC_BUF_SZ;
+				read_buffer((u8 *) pv, toread);
+
+				pv += toread;
+				available -= toread;
+			}
+		}
+	}
+
+	return cbRead;
+}
+
+static int write_buffer(u8 *buffer, int bytes) {
+	void* buf;
+
+	/* set HW flow control to read the page and do ECC */
+	NANDC_IRQ_STS_RAW = 0xFFFFFFFF;
+
+	/* Write output buffer to memory */
+	buf = (g_curr_buf)?(void*)NANDC_RAM1_PHYS:(void*)NANDC_RAM0_PHYS;
+	memcpy(buf, buffer, bytes);
+	if (bytes < NANDC_BUF_SZ) {
+		memset(buf + bytes, 0xFF, NANDC_BUF_SZ - bytes);
+	}
+	if (bytes <= NANDC_BUF_SZ) {
+		/*When 512-516 bytes are written it will trigger ECC computation.*/
+		*((u32*)(buf + NANDC_BUF_SZ)) = 0xFFFFFFFF;
+	}
+
+	/* see if ECC check is enabled */
+	if (NANDC_CFG & NAND_CFG_EC)
+		wait_on_int((g_curr_buf)?NAND_IRQ_ECC_ENC_RAM1:NAND_IRQ_ECC_ENC_RAM0, TIMEOUT_WAIT_RBY);
+	NANDC_CTRL_FLOW = (g_curr_buf)?NAND_CTRLFLW_WRITE_RAM1:NAND_CTRLFLW_WRITE_RAM0;
+	wait_on_int((g_curr_buf)?NAND_IRQ_WR_RAM1:NAND_IRQ_WR_RAM0, TIMEOUT_WAIT_RBY);
+
+	/* toggle buffer */
+	g_curr_buf ^= 1;
+
+	return 1;
+}
+
+static ssize_t lpcnand_write (struct descriptor_d* d, const void* pv, size_t cb)
+{
+	int cbWrote = 0;
+	unsigned long blk;
+
+	if (!chip)
+		return cbWrote;
+
+	if (nand_modfiy_ok() == 0)
+		return 0;
+
+	if (d->index + cb > d->length)
+		cb = d->length - d->index;
+
+	while (cb) {
+		unsigned long page  = (d->start + d->index)/chip->page_size_in_bytes;
+		int index = (d->start + d->index) & (chip->page_size_in_bytes - 1);
+		int available = chip->page_size_in_bytes - index;
+		int towrite;
+
+		if ((blk0enab == 0) && (page == 0)) {
+			printf("\nCan't write block 0 (protected), use lpcnand protblk0 to disable\n");
+			return 0;
+		}
+
+		/* this driver always writes on sub-page (512) boundaries only */
+		if (index & (NANDC_BUF_SZ -1)) {
+			printf("unaligned write 0x%08x\n", d->start + d->index);
+			return 0;
+		}
+		/* if index is not 0 then add 16 byte for every 512 block. */
+		index += (((index >> 9) & 0x3)) * 16;
+
+		/* If the current block is bad, move to the next block */
+		if (nand_checkbb_array_bit(page) == 0) {
+			blk = page / chip->pages_per_block;
+			printf("Skipping write of bad block %d\n", (int) blk);
+
+			/* Continue at next block */
+			d->start = (blk + 1) * chip->pages_per_block * chip->page_size_in_bytes;
+			d->index = 0;
+		}
+		else {
+			if (available > cb)
+				available = cb;
+
+			/* Reset and read to perform I/O on the data region  */
+			nand_reset ();
+
+			/* Send page program command  */
+			NANDC_SET_CMD = NAND_PageProgram;
+			lpcnand_address (page, index);
+
+			DBG(1, "lpcnand write page:0x%08lx index:0x%08x pv:0x%08x\n", page, index, (u32)pv);
+			d->index += available;
+			cb -= available;
+			cbWrote += available;
+
+			while (available > 0) {
+				towrite = (available < NANDC_BUF_SZ)? available : NANDC_BUF_SZ;
+				write_buffer((u8 *) pv, towrite);
+				available -= towrite;
+			}
+			NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
+			NANDC_SET_CMD = NAND_PageProgramConfirm;
+			wait_on_int(NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_PROGRAM);
+
+			NANDC_SET_CMD = NAND_Status;
+			udelay(5);// Wait for tWHR
+			if (NANDC_READ_DATA & NAND_Fail) {
+				printf ("Write failed at page %ld\n", page);
+				goto exit;
+			}
+		}
+	}
+
+exit:
+	return cbWrote;
+}
+
+static int erase_block(unsigned long page) {
+	int count;
+
+	NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
+	NANDC_SET_CMD = NAND_Erase;
+
+	for (count=0; count< chip->amount_of_erase_address_bytes; count++, page >>= 8 )
+		NANDC_SET_ADDR = (u8)( page & 0xff );
+	NANDC_SET_CMD = NAND_EraseConfirm;
+
+	wait_on_int(NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_ERASE);
+
+	NANDC_SET_CMD = NAND_Status;
+	udelay(5);
+	if (NANDC_READ_DATA & NAND_Fail) {
+		return 0;
+	}
+
+	return 1;
+}
+
+static void lpcnand_erase (struct descriptor_d* d, size_t cb)
+{
+	u32 erase_size = (chip->page_size_in_bytes * chip->pages_per_block);
+	if (!chip)
+		return;
+
+	if (nand_modfiy_ok() == 0)
+		return;
+
+	if (d->index + cb > d->length)
+		cb = d->length - d->index;
+
+	do {
+		unsigned long page = (d->start + d->index)/chip->page_size_in_bytes;
+		unsigned long available
+			= erase_size - ((d->start + d->index) & (erase_size - 1));
+
+		if ((blk0enab == 0) && (page == 0)) {
+			printf("Can't erase block 0, use lpcnand protblk0 to disable\n");
+		}
+		else if (nand_checkbb_array_bit(page) == 0) {
+			printf("Bad block %d, skipping...\n", (int) page/chip->pages_per_block);
+		}
+		else {
+			if (erase_block(page) == 0) {
+				printf ("Erase failed at block %ld\n", page/chip->pages_per_block);
+			}
+		}
+
+		if (available < cb) {
+			cb -= available;
+			d->index += available;
+		}
+		else {
+			cb = 0;
+			d->index = d->length;
+		}
+	} while (cb > 0);
+}
+
+#if !defined (CONFIG_SMALL)
+static void lpcnand_report (void)
+{
+	unsigned char status;
+
+
+	if (!chip)
+		return;
+
+	NANDC_SET_CMD = NAND_Status;
+	udelay(5);
+	status = NANDC_READ_DATA;
+	printf ("  lnand:   %d MiB total, %d KiB erase, %d B page %s%s%s\n",
+		(chip->nbr_of_blocks * chip->page_size_in_bytes * chip->pages_per_block)/(1024*1024), 
+		(chip->page_size_in_bytes * chip->pages_per_block)/1024,
+		chip->page_size_in_bytes,
+		(status & NAND_Fail) ? " FAIL" : "",
+		(status & NAND_Ready) ? " RDY" : "",
+		(status & NAND_Writable) ? " R/W" : " R/O"
+		);
+}
+#endif
+
+static __driver_3 struct driver_d lpcnand_driver = {
+	.name = "lnand",
+	.description = "LPC NAND flash driver (hw ecc)",
+	.flags = DRIVER_WRITEPROGRESS(6),
+	.open = lpcnand_open,
+	.close = close_helper,
+	.read = lpcnand_read,
+	.write = lpcnand_write,
+	.erase = lpcnand_erase,
+	.seek = seek_helper,
+};
+
+static __service_6 struct service_d lpcnand_service = {
+	.init = lpcnand_init,
+#if !defined (CONFIG_SMALL)
+	.report = lpcnand_report,
+#endif
+};
+
+#define SMALLPAGESIZE (512)
+void mark_page_bad(unsigned long page) {
+	u8* tmp_buf = (u8 *) EXT_SDRAM_PHYS;
+
+	/* Setup buffer for bad block markers */
+	memset((void*)tmp_buf, 0xff, SMALLPAGESIZE);
+	tmp_buf[512] = 0;
+
+	nand_reset ();
+
+	NANDC_SET_CMD = NAND_PageProgram;
+	if (chip->page_size_in_bytes == 512) {
+		/* Small block FLASH, no extra indicing */
+		lpcnand_address (page, 0);
+	}
+	else if (chip->page_size_in_bytes == 2048) {
+		/* Large block FLASH, no extra indicing */
+		lpcnand_address (page, (3 * SMALLPAGESIZE));
+	}
+	else {
+		/* Huge block FLASH, no extra indicing */
+		lpcnand_address (page, (7 * SMALLPAGESIZE));
+	}
+
+	write_buffer(tmp_buf, 516);
+
+	NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
+	NANDC_SET_CMD = NAND_PageProgramConfirm;
+	wait_on_int(NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_PROGRAM);
+
+	NANDC_SET_CMD = NAND_Status;
+	udelay(5);// Wait for tWHR
+	if (NANDC_READ_DATA & NAND_Fail) {
+		printf ("Failed marking %d block bad\n", (int) (page/chip->pages_per_block));
+	}
+	else {
+		printf("Block %d marked bad\n", (int) (page/chip->pages_per_block));
+	}
+}
+
+int cmd_lpcnand (int argc, const char** argv)
+{
+	int page, cBad = 0;
+
+	if (!chip)
+		return 0; 
+
+	if (PARTIAL_MATCH (argv[1], "f", "ormat") == 0) {
+	 	/* Does block 0 already have a valid structure yet? */
+		if (nand_modify) {
+			printf("Block 0 already has a valid structure!\n");
+
+			if ((argc > 3) || (argv[2][0] != '1')) {
+				printf("CAUTION: The bad block list in block 0 contains the entire bad\n"
+					"block list for the device from factory marked bad blocks. If\n"
+					"you erase this block now, you may lose these markers forever!\n"
+					"You can override this warning message with 'lpcnand format 1'.\n");
+				return -1;
+			}
+		}
+
+		format_device();
+	}
+
+	if (PARTIAL_MATCH (argv[1], "s", "can") == 0) {
+		
+		cBad = 0;
+
+		for (page = chip->pages_per_block; page < (chip->nbr_of_blocks * chip->pages_per_block);
+			page += chip->pages_per_block) {
+			/* reset nand device */
+			nand_reset ();
+			lpcnand_read_setup(page, chip->page_size_in_bytes); /* index to spare area */
+			{
+				if (NANDC_READ_DATA != 0xFF) {
+					printf ("Block %d bad\n", page/chip->pages_per_block);
+					++cBad;
+				}
+			}
+			DBG(2, "Checking page:0x%08x\n", page);
+		}
+		printf ("%d of %d blocks are bad\n",
+			cBad, chip->nbr_of_blocks);
+	}
+
+	if (PARTIAL_MATCH (argv[1], "b", "blist") == 0) {
+		if (nand_modfiy_ok() == 0)
+			return 0;
+
+		cBad = 0;
+
+		for (page = chip->pages_per_block; page < (chip->nbr_of_blocks * chip->pages_per_block);
+			page += chip->pages_per_block) {
+			/* reset nand device */
+			if (nand_checkbb_array_bit(page) == 0) {
+				printf ("Block %d bad\n", page/chip->pages_per_block);
+				++cBad;
+			}
+			DBG(2, "Checking page:0x%08x\n", page);
+		}
+		printf ("%d of %d blocks are bad\n",
+			cBad, chip->nbr_of_blocks);
+	}
+
+	if (PARTIAL_MATCH (argv[1], "r", "estore") == 0) {
+		if (nand_modfiy_ok() == 0)
+			return 0;
+
+		printf("Restoring factory bad block markers\n");
+
+		/* Erase all blocks and mark blocks bad as specified by block 0 table */
+		for (page = chip->pages_per_block; page < (chip->nbr_of_blocks * chip->pages_per_block);
+			page += chip->pages_per_block) {
+			if (nand_checkbb_array_bit(page) == 0) {
+				/* Mark this block/page as bad */
+				mark_page_bad(page);
+			}
+			else {
+				erase_block(page);
+			}
+		}
+	}
+
+	if (PARTIAL_MATCH (argv[1], "p", "rotblk0") == 0) {
+		printf ("Block 0 modify protection is ");
+		if (argv[2][0] == '0') {
+			blk0enab = 1;
+			printf ("off\n");
+		}
+		else {
+			blk0enab = 0;
+			printf ("on\n");
+		}
+	}
+
+	/* This command is not for end-users. Don't use it! */
+	if (strcmp (argv[1], "diagmode") == 0) {
+		nand_modify = 1;
+
+		if ((argc >= 2) || (argv[2][0] != '1')) {
+			/* option 1 - clear bad blocks */
+			memset((void*)nand_bbl_array, 0xFF, sizeof(nand_bbl_array));
+		}
+	}
+
+	return 0;
+}
+
+/* Empty function needed for Apex NAND driver */
+void nandsys_init(void) {}
+
+static __command struct command_d c_nand = {
+	.command = "lpcnand",
+	.func = cmd_lpcnand,
+	COMMAND_DESCRIPTION ("lpcnand test function")
+	COMMAND_HELP (
+	"lpcnand [SUBCOMMAND [PARAMETER]]\n"
+	" format     - Write boot params and bad blocklist to block 0\n"
+	" scan       - Scan for factory marked bad blocks\n"
+	" bblist     - Dump bad block list (from block 0)\n"
+	" restore    - Restore device to factory default state\n"
+	" protblk0   - Enable or disable block 0 modify protection\n"
+	"\n")
+};
+
diff -purN apex-1.6.8/src/mach-lpc313x/drv-mmc.c work_1.6.8/src/mach-lpc313x/drv-mmc.c
--- apex-1.6.8/src/mach-lpc313x/drv-mmc.c	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/drv-mmc.c	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,1006 @@
+/* drv-mmc.c
+
+written by Durgesh Pattamatta
+19 Oct 2005
+
+Copyright (C) 2008 NXP Semiconductors
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+version 2 as published by the Free Software Foundation.
+Please refer to the file debian/copyright for further details.
+
+NOTES
+-----
+
+o Detection should be continuous.
+o If the card doesn't respond to the known address, we can
+perform acqurire again.
+o This can be done when the report is generated as well.
+o Perhaps we acquire every time?
+o The only way to know we have the right card is to randomize the
+ID we set in MMC cards or...we have to acquire every time we
+start a transaction.
+o IO should really be quite easy, check for boundaries and read
+blocks as we do in the CF driver.
+o Enable SD mode when available.  There are two pieces, the
+controller and the card.  
+o Check for the best speed.  
+
+-----------
+DESCRIPTION
+-----------
+
+Clocking
+--------
+
+The specification limits the clock frequency during identification
+to 400KHz.  During I/O, the limit is set based on card type 
+20/25/26/52MHz for MMC/SD,SDHC/new  MMC/HighMMC cards respectively.
+
+Block Caching
+-------------
+
+The driver caches one block from the card and copied data from the
+cached block to the caller's buffer.  This is done because the
+callers aren't expected to be efficient about reading large blocks
+of data.  This is a convenience for the upper layers as the command
+routines are best when they can handle data in the manner most
+efficient to their structure.
+
+Card Acquisition
+----------------
+
+The present state of the card acqusition logic is weak.  We acquire
+a card with the system initializes.  If the card goes offline, we
+have no way to detect and correct it.  What should happen is the
+read code ought to detect that the card has changed, probably
+because the select fails, and perform the acquire at that time.
+
+
+*/
+
+#include <config.h>
+#include <driver.h>
+#include <service.h>
+#include <linux/string.h>
+#include <apex.h>
+#include <command.h>
+#include <mach/hardware.h>
+#include <console.h>
+#include <error.h>
+
+#include <mmc.h>
+
+#define USE_SD      /* Allow SD cards */
+#define USE_WIDE    /* Allow WIDE mode */
+//#define USE_MULTIBLOCK_READ /* Use multiblock read implementation */
+
+
+#if defined USE_MMC_BOOTSTRAP
+# define SECTION __section (.bootstrap)
+# define SECTIOND __section (.bss_bootstrap)
+#else
+# define SECTION
+# define SECTIOND
+#endif
+
+
+extern char* strcat (char*, const char*);
+
+//#define TALK 1
+//#undef TALK 
+
+#if defined (USE_MMC_BOOTSTRAP)
+# undef TALK
+#endif
+
+#if defined (TALK)
+#define PRINTF(f...)    printf (f)
+#define ENTRY(l)    printf ("%s\n", __FUNCTION__)
+#define DBG(l,f...)   do { if (TALK >= l) printf (f); } while (0)
+#else
+#define PRINTF(f...)    do {} while (0)
+#define ENTRY(l)    do {} while (0)
+#define DBG(l,f...)   do {} while (0)
+#endif
+
+struct mmc_info SECTIOND mmc;
+unsigned char SECTIOND mmc_rgb[MMC_SECTOR_SIZE];
+
+#define MS_TIMEOUT 1000
+
+#if defined (USE_MMC_BOOTSTRAP)
+
+static void SECTION _memcpy (void* dest, const void* src, size_t cb)
+{
+	while (cb--)
+		*(unsigned char*) dest++ = *(unsigned char*) src++;
+}
+#define memcpy _memcpy
+
+static void SECTION _memset (void* pv, int v, size_t cb)
+{
+	while (cb--)
+		*(unsigned char*) pv++ = v;
+}
+#undef memset
+#define memset _memset
+
+#endif
+
+static inline void mmc_clear (void) {
+	memset (&mmc, 0, sizeof (mmc));
+	mmc.ib = -1; 
+}
+
+static void mmc_report (void);
+
+static inline unsigned long response_ocr (void) {
+	u32* resp = (u32*)&mmc.response[0];
+
+	return *resp;
+}
+static inline u32 get_bits(int start, int end, u32* data) 
+{
+	u32 v;
+	u32 i = end >> 5;
+	u32 j = start & 0x1f;
+
+	if ( i == (start >> 5) )
+		v = (data[i] >> j);
+	else
+		v = ((data[i] << (32 - j)) | (data[start >> 5] >> j));
+
+	return (v & ((1<<(end - start+1))-1));
+}
+
+#if defined (TALK)
+static const char* report_status (unsigned long l)
+{
+	static char sz[256];
+
+	sprintf (sz, "[%04lx", l);
+	if (l & SDMMC_INT_RESP_ERR)
+		strcat (sz, " RESP_ERR");
+	if (l & SDMMC_INT_CMD_DONE)
+		strcat (sz, " CMD_DONE");
+	if (l & SDMMC_INT_TXDR)
+		strcat (sz, " TXDR");
+	if (l & SDMMC_INT_RXDR)
+		strcat (sz, " RXDR");
+	if (l & SDMMC_INT_RCRC)
+		strcat (sz, " RCRC");
+	if (l & SDMMC_INT_DCRC)
+		strcat (sz, " DCRC");
+	if (l & SDMMC_INT_RTO)
+		strcat (sz, " RTO");
+	if (l & SDMMC_INT_DTO)
+		strcat (sz, " DTO");
+	if (l & SDMMC_INT_HTO)
+		strcat (sz, " HTO");
+	if (l & SDMMC_INT_FRUN)
+		strcat (sz, " FRUN");
+	if (l & SDMMC_INT_HLE)
+		strcat (sz, " HLE");
+	if (l & SDMMC_INT_SBE)
+		strcat (sz, " SBE");
+	if (l & SDMMC_INT_ACD)
+		strcat (sz, " ACD");
+	if (l & SDMMC_INT_EBE)
+		strcat (sz, " EBE");
+	strcat (sz, "]");
+	return sz;
+}
+#endif
+
+
+
+/* clear_all
+
+clears the FIFOs, response and data, and the interrupt status.
+*/
+
+static void SECTION clear_all (void)
+{
+	/* reset all blocks */
+	SDMMC_CTRL |= SDMMC_CTRL_FIFO_RESET;
+	/* wait till resets clear */
+	while (SDMMC_CTRL & SDMMC_CTRL_FIFO_RESET);
+
+	/* Clear interrupt status */
+	SDMMC_RINTSTS = 0xFFFFFFFF;
+}
+
+static int SECTION send_cmd (u32 cmd, u32 arg)
+{
+	volatile int tmo = 50;
+	volatile int delay;
+
+	SDMMC_CMDARG = arg;
+	SDMMC_CMD = SDMMC_CMD_START | cmd;
+
+	while (--tmo && (SDMMC_CMD & SDMMC_CMD_START)) {
+		if (tmo & 1)
+			delay = 50;
+		else
+			delay = 18000;
+
+		while (--delay > 1);
+	}
+
+	return (tmo < 1)? 1: 0;
+}
+
+static void SECTION set_clock (int speed)
+{
+	/* compute SD/MMC clock dividers */
+	u32 mmc_clk = cgu_get_clk_freq(CGU_SB_SD_MMC_CCLK_IN_ID);
+	u32 div = ((mmc_clk / speed) + 2) >> 1;
+
+	if ((div == SDMMC_CLKDIV) && SDMMC_CLKENA)
+		return; /* requested speed is already set */
+
+	/* disable clock */
+	SDMMC_CLKENA = 0;
+	SDMMC_CLKSRC = 0;
+
+	/* inform CIU */
+	if ( send_cmd( SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0) )   
+		DBG (2, "MMC clock 1tmo\n");
+
+	/* set clock to desired speed */
+	SDMMC_CLKDIV = div;
+	/* inform CIU */
+	if ( send_cmd( SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0) )   
+		DBG (2, "MMC clock 2tmo\n");
+
+	/* enable clock */
+	SDMMC_CLKENA = SDMMC_CLKEN_ENABLE;
+	/* inform CIU */
+	if ( send_cmd( SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0) )   
+		DBG (2, "MMC clock 3tmo\n");
+
+
+	DBG (2, "MMC clock %ld req: %d main:%d\n", mmc_clk/(SDMMC_CLKDIV << 1) , speed, mmc_clk);
+}
+
+/* pull_response
+
+retrieves a command response.  The length is the length of the
+expected response, in bits.
+
+*/
+
+static void SECTION pull_response (int length)
+{
+	u32* resp = (u32*)&mmc.response[0];
+
+	*resp++ = SDMMC_RESP0;
+	if (length > 31)
+		*resp++ = SDMMC_RESP1;
+
+	if (length > 63)
+		*resp++ = SDMMC_RESP2;
+
+	if (length > 95)
+		*resp++ = SDMMC_RESP3;
+
+	DBG (3, "resp: 0x%lx 0x%lx 0x%lx 0x%lx(%d)\n", 
+		SDMMC_RESP0, SDMMC_RESP1, SDMMC_RESP2, SDMMC_RESP3, length);
+}
+
+static void SECTION pull_data (void* pv, int cnt)
+{
+	int i = 0;
+	int fcnt;
+
+	while ( i < cnt) {
+		fcnt = SDMMC_GET_FCNT(SDMMC_STATUS) << 2;
+		/* LPC313x maps address above 0x18000100 to FIFO to support
+		burst reading. So let's use memcpy to speedup read. Since we
+		always pass 4byte aligned address and also multiple of 4 count
+		let's hope memcpy of C runtime does LDMs.*/
+		if (fcnt)
+			memcpy(pv + i, (void*)SDMMC_DATA_ADR, fcnt);
+		i += fcnt;
+	}
+}
+
+static void SECTION push_data (const void* pv, size_t cb)
+{
+	int i = 0;
+	int fcnt;
+
+	while (i < cb)
+	{
+		fcnt = SDMMC_FIFO_SZ - (SDMMC_GET_FCNT(SDMMC_STATUS) << 2);
+		/* LPC313x maps address above 0x18000100 to FIFO to support
+		burst writing. So let's use memcpy to speedup write. Since we
+		always pass 4byte aligned address and also multiple of 4 count
+		let's hope memcpy of C runtime does STMs (store multiples).*/
+		memcpy((void*)SDMMC_DATA_ADR, pv + i, fcnt);
+		i += fcnt;
+	}
+}
+
+static unsigned long SECTION wait_for_completion (short bits)
+{
+	unsigned short status = 0;
+	unsigned long time_start = timer_read ();
+	int timed_out = 0;
+
+	/* also check error conditions */
+	bits |= SDMMC_INT_EBE | SDMMC_INT_SBE | SDMMC_INT_HLE
+		| SDMMC_INT_RTO | SDMMC_INT_RCRC | SDMMC_INT_RESP_ERR;
+
+	if (bits & SDMMC_INT_DATA_OVER)
+		bits |= SDMMC_INT_FRUN | SDMMC_INT_HTO | SDMMC_INT_DTO
+		| SDMMC_INT_DCRC;
+
+	DBG (3, " (%x) ", bits);
+	do {
+		udelay (1);
+		status = SDMMC_RINTSTS;
+
+		if (timer_delta (time_start, timer_read ()) >= MS_TIMEOUT) {
+			//printf ("\nbailing at timeout status 0x%x bits 0x%x\n", status, bits);
+			timed_out = 1;
+		}
+	} while (((status  & bits) == 0) && !timed_out);
+
+	DBG (3, " => %s 0x%lx\n", report_status (status), SDMMC_STATUS);
+
+	if (timed_out)
+		DBG (1, " timedout => cmd:0x%lx %s 0x%lx\n", SDMMC_CMD, report_status (status), SDMMC_STATUS);
+
+	return status | (timed_out ? SDMMC_INT_RTO : 0);
+}
+
+#if defined (TALK) && ! defined (USE_MMC_BOOTSTRAP)
+static void report_command (u32 cmd, u32 cmd_reg, u32 arg)
+{
+	DBG (3, "cmd (%03ld) 0x%08lx (0x%x)/(0x%x)  arg 0x%08lx(0x%x)"
+		" ctrl 0x%04lxrate 0x%02lx\n",
+		(SDMMC_CMD & 0x3F), SDMMC_CMD, cmd_reg, cmd, SDMMC_CMDARG, 
+		arg, SDMMC_CTRL, SDMMC_CLKDIV);
+}
+#else
+# define report_command(cmd, cmd_reg, arg)
+#endif
+
+static int SECTION execute_command (unsigned long cmd,
+				    unsigned long arg,
+				    unsigned short wait_status)
+{
+	/* if APP command there are 2 stages */
+	int step = (cmd & CMD_BIT_APP) ? 2 : 1;
+	int status = 0;
+	u32 cmd_reg = 0;
+
+	if (!wait_status)
+		wait_status = ((cmd >> CMD_SHIFT_RESP) & CMD_MASK_RESP)
+		? SDMMC_INT_CMD_DONE : SDMMC_INT_DATA_OVER;
+
+	/* Clear the interrupts & FIFOs*/
+	if (cmd & CMD_BIT_DATA)
+		clear_all();
+	while (step)
+	{
+		set_clock ((cmd & CMD_BIT_LS) ? 400000 : mmc.speed);
+
+		if (status)
+			DBG (3, "%s: step %d s 0x%x\n", __FUNCTION__, step, status);
+
+		SDMMC_RINTSTS = 0xFFFFFFFF;
+
+		switch (step) {
+
+		case 1:     /* Execute command */
+			cmd_reg = ((cmd & CMD_MASK_CMD) >> CMD_SHIFT_CMD)
+				| ((cmd & CMD_BIT_INIT)  ? SDMMC_CMD_INIT : 0)
+				| ((cmd & CMD_BIT_DATA)  ? (SDMMC_CMD_DAT_EXP | SDMMC_CMD_PRV_DAT_WAIT) : 0)
+				| ((((cmd >> CMD_SHIFT_RESP) & CMD_MASK_RESP) == 2) ? SDMMC_CMD_RESP_LONG : 0)
+				| ((cmd & (CMD_MASK_RESP << CMD_SHIFT_RESP)) ? SDMMC_CMD_RESP_EXP : 0)
+				| ((cmd & CMD_BIT_WRITE)  ? SDMMC_CMD_DAT_WR : 0)
+				| ((cmd & CMD_BIT_STREAM) ? SDMMC_CMD_STRM_MODE: 0)
+				| ((cmd & CMD_BIT_BUSY) ? SDMMC_CMD_STOP: 0)
+				| ((cmd & CMD_BIT_AUTO_STOP)  ? SDMMC_CMD_SEND_STOP: 0)
+				| SDMMC_CMD_START 
+				;
+			/* wait for previos data finsh for select/deselect commands */
+			if (((cmd & CMD_MASK_CMD) >> CMD_SHIFT_CMD) == MMC_SELECT_CARD)
+			{
+			  cmd_reg |= SDMMC_CMD_PRV_DAT_WAIT;
+			}
+			/* wait for command to be accepted by CIU */
+			if ( send_cmd (cmd_reg, arg) == 0)
+			  --step;
+			break;
+
+		case 0:
+			return 0;
+
+		case 2:      /* APP prefix */
+			cmd_reg = MMC_APP_CMD 
+				| SDMMC_CMD_RESP_EXP /* Response is status */
+				| ((cmd & CMD_BIT_INIT)  ? SDMMC_CMD_INIT : 0)
+				| SDMMC_CMD_START 
+				;
+			if ( send_cmd (cmd_reg, mmc.rca<<16) == 0)
+			  --step;
+			break;
+		}
+
+
+		report_command (cmd, cmd_reg, arg);
+
+
+		/* wait for command response*/
+		status = wait_for_completion (wait_status);
+
+		/* We return an error if there is a timeout, even if we've fetched a
+		response */
+		if (status & SDMMC_INT_ERROR) {
+
+			if ((SDMMC_CMD & 0x3F) != 0x07)
+				DBG (1, "cmd (%03ld) 0x%08lx arg 0x%08lx st:0x%08x\n", 
+				(SDMMC_CMD & 0x3F), SDMMC_CMD, SDMMC_CMDARG, status);
+
+			return status;
+		}
+
+		if (status & SDMMC_INT_CMD_DONE)
+			switch ((cmd >> CMD_SHIFT_RESP) & CMD_MASK_RESP) {
+			case 0:
+				break;
+			case 1:
+			case 3:
+				pull_response (31);
+				break;
+			case 2:
+				pull_response (128);
+				break;
+			}
+
+	}
+	return 0;
+}
+/** Purpose: Puts current selected card in trans state **/
+static int set_trans_state(void)
+{
+	u32 status;
+	u32* resp = (u32*)&mmc.response[0];
+
+	/* get current state of the card */
+	status = execute_command(CMD_SEND_STATUS, mmc.rca<<16, 0);
+	if (status & SDMMC_INT_RTO)
+	{
+		/* unable to get the card state. So return immediatly. */
+		return -1;
+	}
+
+	DBG (3, "mmc status 0x%x 0x%x 0x%x 0x%x\n", status, *resp, mmc.rca, CMD_SEND_STATUS);
+	/* check card state in response */
+	status = R1_CURRENT_STATE(*resp);
+	switch (status)
+	{
+	case MMC_STBY_ST:
+		/* put card in 'Trans' state */
+		status = execute_command (CMD_SELECT_CARD, mmc.rca<<16, 0);
+		if (status != 0)
+		{
+			/* unable to put the card in Trans state. So return immediatly. */
+			return -1;
+		}
+		break;
+	case MMC_TRAN_ST:
+		/*do nothing */
+		break;
+	default:
+		/* card shouldn't be in other states so return */
+		return -1;
+	}
+
+#if defined (USE_WIDE)
+	if (mmc.card_type & CARD_TYPE_SD) {
+		execute_command (CMD_SD_SET_WIDTH, 2, 0); /* SD, 4 bit width */
+		/* if positive response */
+		SDMMC_CTYPE = SDMMC_CTYPE_4BIT;
+	}
+#endif
+	/* set block length */
+	SDMMC_BLKSIZ = MMC_SECTOR_SIZE;
+	status = execute_command (CMD_SET_BLOCKLEN, MMC_SECTOR_SIZE, 0);
+
+
+	return 0;
+}
+
+
+/* mmc_acquire
+
+detects cards on the bus and initializes them for IO.  It can
+detect both SD and MMC card types.
+
+It will only detect a single card and the first one will be the one
+that is configured with an RCA and will be used by the driver.
+
+*/
+
+void SECTION mmc_acquire (void)
+{
+	int status;
+	int tries = 0;
+	unsigned long ocr = 0x00ff8000;
+	unsigned long r;
+	int state = 0;
+	unsigned long command = 0;
+
+	mmc_clear ();
+
+#if defined(CONFIG_MACH_VAL313X)
+	/* check if card is inserted in the slot. GPIO12 */
+	GPIO_IN(IOCONF_GPIO, _BIT(6));
+	if (GPIO_STATE(IOCONF_GPIO) & _BIT(6)) {
+		/* card is absent  return */
+		DBG (1, "%s: Card not inserted 0x%lx\n", __FUNCTION__, GPIO_STATE(IOCONF_GPIO));
+		return;
+	}
+#elif defined(CONFIG_MACH_EA313x_V1) || defined(CONFIG_MACH_EA313x_V2) || defined(CONFIG_MACH_VAL3154)
+	/* check if card is inserted in the slot. mI2STX_BCK0 */
+	GPIO_IN(IOCONF_EBI_MCI, _BIT(7));
+	if (GPIO_STATE(IOCONF_EBI_MCI) & _BIT(7)) {
+		/* card is absent  return */
+		DBG (1, "%s: Card not inserted 0x%lx\n", __FUNCTION__, GPIO_STATE(IOCONF_GPIO));
+		return;
+	}
+#endif
+
+	/* clear card type */
+	SDMMC_CTYPE = 0;
+	/* set high speed for the card as 20MHz */
+	mmc.speed = 20000000;
+
+	status = execute_command (CMD_IDLE, 0, SDMMC_INT_CMD_DONE);
+
+	while (state < 100) {
+
+		switch (state) {
+
+		case 0:     /* Setup for SD */
+			mmc.acquired = 0;
+			/* check if it is SDHC card */
+			status = execute_command (CMD_SD_SEND_IF_COND, 0x1AA, 0);
+			if (!(status & SDMMC_INT_RTO)) {
+
+				u32* resp = (u32*)&mmc.response[0];
+
+				/* check response has same echo pattern */
+				if ((resp[0] & 0xFF) == 0xAA)
+					/* it is SD 2.0 card so indicate we are SDHC capable*/
+					ocr |= OCR_HC_CCS;
+			}  
+
+			++state;
+			command = CMD_SD_OP_COND;
+			tries = 10;   
+			/* assume SD card */
+			mmc.card_type |= CARD_TYPE_SD;
+			/* for SD cards high speed is 25MHz */
+			mmc.speed = 25000000;
+
+			break;
+
+		case 10:      /* Setup for MMC */
+			/* start fresh for MMC crds */
+			mmc.card_type &= ~CARD_TYPE_SD;  
+			status = execute_command (CMD_IDLE, 0, SDMMC_INT_CMD_DONE);
+			command = CMD_MMC_OP_COND;
+			tries = 10;
+			ocr |= OCR_HC_CCS;
+			++state;
+			/* for MMC cards high speed is 20MHz */
+			mmc.speed = 20000000;
+			DBG (1, "Trying MMC sequence\n");
+			break;
+
+		case 1:
+		case 11:
+			status = execute_command (command, 0, 0);
+			if (status & SDMMC_INT_RTO)
+				state += 9;		/* Mode unavailable */
+			else
+				++state;
+			break;
+
+		case 2:			/* Initial OCR check  */
+		case 12:
+			ocr = response_ocr () | (ocr & OCR_HC_CCS);
+			if (ocr & OCR_ALL_READY)
+				++state;
+			else
+				state += 2;
+			break;
+
+		case 3:			/* Initial wait for OCR clear */
+		case 13:
+			while ((ocr & OCR_ALL_READY) && --tries > 0) {
+				mdelay (MS_ACQUIRE_DELAY);
+				status = execute_command (command, 0, 0);
+				ocr = response_ocr () | (ocr & OCR_HC_CCS);
+			}
+			if (ocr & OCR_ALL_READY)
+				state += 7;
+			else
+				++state;
+			break;
+
+		case 14:
+			/* for MMC cards set high capacity bit */
+			ocr |= OCR_HC_CCS;
+		case 4:     /* Assign OCR */  
+			tries = 200;
+			ocr &= 0x40ff8000;	/* Mask for the bits we care about */
+			do {
+				mdelay (MS_ACQUIRE_DELAY);
+				mmc.acquire_time += MS_ACQUIRE_DELAY;
+				status = execute_command (command, ocr, 0);
+				r = response_ocr ();
+			} while (!(r & OCR_ALL_READY) && --tries > 0);
+			if (r & OCR_ALL_READY) {
+				/* is it high capacity card */
+				mmc.card_type |= (r & OCR_HC_CCS);  
+				++state;
+			} else
+				state += 6;
+
+			break;
+
+		case 5:     /* CID polling */
+		case 15:
+			status = execute_command (CMD_ALL_SEND_CID, 0, 0);
+			memcpy (mmc.cid, mmc.response + 1, 16);
+			++state;
+			break;
+
+		case 6:     /* RCA send */
+			status = execute_command (CMD_SD_SEND_RCA, 0, 0);
+			mmc.rca = (*((u32*)&mmc.response[0])) >> 16;
+			++state;
+			break;
+		case 16:      /* RCA assignment */
+			mmc.rca = 1;
+			status = execute_command (CMD_MMC_SET_RCA, mmc.rca << 16, 0);
+			++state;
+			break;
+
+		case 7:
+		case 17:
+			status = execute_command (CMD_SEND_CSD, mmc.rca << 16, 0);
+			memcpy (mmc.csd, mmc.response, 16);
+			mmc.acquired = 1;
+			++state;
+			break;
+
+		default:
+			state += 100; /* break from while loop */
+			break;
+		}
+	}
+
+	if (mmc_card_acquired ()) {
+
+		/* change delay gates per card type */
+		if (mmc.card_type & CARD_TYPE_SD)
+			SYS_SDMMC_DELAYMODES = 0x1B;
+		else
+			SYS_SDMMC_DELAYMODES = 0x16;
+
+		mmc.read_bl_len = get_bits(80, 83, (u32*)mmc.csd); //mmc.csd[10] & 0xf;
+		mmc.block_len = 1 << mmc.read_bl_len;
+
+		if ( (mmc.card_type & CARD_TYPE_HC) && 
+			(mmc.card_type & CARD_TYPE_SD) )
+		{
+			/* See section 5.3.3 CSD Register (CSD Version 2.0) of SD2.0 spec
+			an explanation for the calculation of these values
+			*/
+			mmc.c_size = get_bits(48, 63, (u32*)mmc.csd) + 1; 
+			mmc.blocknr = mmc.c_size << 10; /* 512 byte blocks */
+		}
+		else
+		{
+			/* See section 5.3 of the 4.1 revision of the MMC specs for
+			an explanation for the calculation of these values
+			*/
+			mmc.c_size = get_bits(62, 73, (u32*)mmc.csd);
+			mmc.c_size_mult = get_bits(47, 49, (u32*)mmc.csd); //csd_c_size_mult ();
+			mmc.mult = 1 <<  (mmc.c_size_mult + 2);
+			mmc.blocknr = (mmc.c_size + 1) * mmc.mult;
+			/* adjust blocknr to 512/block */
+			if ( mmc.block_len > 512)
+				mmc.blocknr = mmc.blocknr * (mmc.block_len >> 9);
+
+			/* get extended CSD for newer MMC cards CSD spec >= 4.0*/
+			if ( ((mmc.card_type & CARD_TYPE_SD) == 0) && 
+				(get_bits(122, 125, (u32*)mmc.csd) >= 4) ) {
+
+					u32 ext_csd[MMC_SECTOR_SIZE/4];
+
+					/* put card in trans state */
+					status = execute_command (CMD_SELECT_CARD, mmc.rca<<16, 0);
+					/* set block size and byte count */
+					SDMMC_BLKSIZ = MMC_SECTOR_SIZE;
+					SDMMC_BYTCNT = MMC_SECTOR_SIZE;
+					/* send EXT_CSD command */
+					status = execute_command (CMD_SEND_EXT_CSD, 0, SDMMC_INT_CMD_DONE 
+						| SDMMC_INT_DATA_OVER | SDMMC_INT_RXDR);
+					if ((status & SDMMC_INT_ERROR) == 0) {
+
+						pull_data(ext_csd, MMC_SECTOR_SIZE);
+
+						/* check EXT_CSD_VER is greater than 1.1 */
+						if ( (ext_csd[48] & 0xFF) > 1)
+							mmc.blocknr = ext_csd[53]; /* bytes 212:215 represent sec count */
+						/* switch to 52MHz clock if card type is set to 1 or else set to 26MHz */
+						if ( (ext_csd[49] & 0xFF) == 1 ) {
+							/* for type 1 MMC cards high speed is 52MHz */
+							mmc.speed = 52000000;
+						}
+						else {
+							/* for type 0 MMC cards high speed is 26MHz */
+							mmc.speed = 26000000;
+						}
+					}
+			}
+		}
+
+		mmc.device_size = mmc.blocknr << 9; /* blocknr * 512 */
+
+	}
+}
+
+void SECTION mmc_init (void)
+{
+  volatile u32 i;
+	/* enable SD/MMC clock */
+	cgu_clk_en_dis(CGU_SB_SD_MMC_HCLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_SD_MMC_CCLK_IN_ID, 1);
+
+	/* reset SD/MMC/MCI modules through CGU */
+  /* clear and set the register */
+  CGU_CFG->resetn_soft[SD_MMC_PNRES_SOFT] = 0;
+  CGU_CFG->resetn_soft[SD_MMC_NRES_CCLK_IN_SOFT] = 0;
+  /* introduce some delay */
+  for (i = 0;i < 1000;i++);
+  CGU_CFG->resetn_soft[SD_MMC_NRES_CCLK_IN_SOFT] = CGU_CONFIG_SOFT_RESET;
+  CGU_CFG->resetn_soft[SD_MMC_PNRES_SOFT] = CGU_CONFIG_SOFT_RESET;
+
+	/* Set IOCONF to MCI pins */
+	SYS_SDMMC_DELAYMODES = 0;
+	SYS_MUX_GPIO_MCI = 1;
+	/* set the pins as driven by IP in IOCONF */
+	GPIO_DRV_IP(IOCONF_EBI_MCI, 0xF0000003);
+
+	/* power-up / select MMC+ slot */
+	GPIO_OUT_LOW(IOCONF_EBI_I2STX_0, _BIT(5));
+
+	/* wait atleast 10ms */
+	udelay (10 * 1000);
+
+	/* set delay gates */
+	SYS_SDMMC_DELAYMODES = 0x1B;
+
+	/* reset all blocks */
+	SDMMC_CTRL = SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET 
+		| SDMMC_CTRL_DMA_RESET;
+	/* wait till resets clear */
+	while (SDMMC_CTRL & 
+		(SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
+
+	/* Clear the interrupts for the host controller */
+	SDMMC_RINTSTS = 0xFFFFFFFF;
+
+	/* Put in max timeout */
+	SDMMC_TMOUT = 0xFFFFFF40;
+
+	/* FIFO threshold settings  */
+	SDMMC_FIFOTH = (0x2 << 28) | (0x10 << 16) | (0x10 << 0);
+
+	/* disable clock to CIU */
+	SDMMC_CLKENA = 0;
+	SDMMC_CLKSRC = 0;
+
+	/* clear mmc structure*/  
+	mmc_clear ();
+	/* start card enumeration */
+	mmc_acquire ();
+}
+
+static void mmc_report (void)
+{
+	printf ("  mmc:    %s card acquired",
+		mmc_card_acquired () ? ((mmc.card_type & CARD_TYPE_SD)? "sd" : "mmc") : "no");
+	if (mmc_card_acquired ()) {
+		printf (", rca 0x%x (%d ms)", mmc.rca, mmc.acquire_time);
+		printf (", %ld.%02ld MiB\n",
+			mmc.device_size/(1024*1024),
+			(((mmc.device_size/1024)%1024)*100)/1024);
+		dump (mmc.cid, 16, 0);
+		dump (mmc.csd, 16, 0);
+		printf ("\n");
+	}
+	else
+		printf ("\n");
+}
+
+static int mmc_open (struct descriptor_d* d)
+{
+	DBG (2,"%s: opened %ld %ld\n", __FUNCTION__, d->start, d->length);
+
+	if (!mmc_card_acquired ())
+		ERROR_RETURN (ERROR_IOFAILURE, "no card");
+
+	return 0;
+}
+
+
+/* mmc_read
+
+performs the read of data from the SD/MMC card.  It handles
+unaligned, and sub-block length I/O.
+
+*/
+
+ssize_t SECTION mmc_read (struct descriptor_d* d, void* pv, size_t cb)
+{
+	ssize_t cbRead = 0;
+	int status;
+
+
+	if (d->index + cb > d->length)
+		cb = d->length - d->index;
+
+	DBG (4, "mmc reading %d\n", cb);
+	while (cb) {
+		u32 index = d->start + d->index;
+		int availableMax = MMC_SECTOR_SIZE - (index & (MMC_SECTOR_SIZE - 1));
+		int available = cb;
+		int block = index >> 9;
+
+		if (available > availableMax)
+			available = availableMax;
+
+
+		/* Read block into buffer  */
+		if (block != mmc.ib) {
+			int tmp_index = 0;
+
+			/* if high capacity card use block index */
+			if ( mmc.card_type & CARD_TYPE_HC)
+				tmp_index = block;
+			else
+				tmp_index = index & ~(MMC_SECTOR_SIZE - 1); 
+
+			/* if can't put card in trans state return immediately */
+			if (set_trans_state())
+				return 0;
+
+			DBG (1, "mmc reading %d\n", block, tmp_index);
+
+			/* read single block and cache it */
+			SDMMC_BLKSIZ = MMC_SECTOR_SIZE;
+			SDMMC_BYTCNT = MMC_SECTOR_SIZE;
+			status = execute_command (CMD_READ_SINGLE, tmp_index,
+				SDMMC_INT_CMD_DONE | SDMMC_INT_DATA_OVER | SDMMC_INT_RXDR);
+			if ((status & SDMMC_INT_ERROR) == 0) {        
+				pull_data(mmc_rgb, MMC_SECTOR_SIZE);
+				mmc.ib = block;
+			}
+		}
+
+		DBG (1, "mmc read: 0x%08x %d \n", index, available);
+		memcpy (pv, mmc_rgb + (index & (MMC_SECTOR_SIZE - 1)), available);
+
+		d->index += available;
+		cb -= available;
+		cbRead += available;
+		pv += available;
+	}
+
+
+	return cbRead;
+}
+
+
+/* mmc_write
+
+performs the write of data from the SD/MMC card.
+
+//   It handles unaligned, and sub-block length I/O.
+
+*/
+
+ssize_t SECTION mmc_write (struct descriptor_d* d, const void* pv, size_t cb)
+{
+	ssize_t cbWrote = 0;
+	int status;
+
+	/* partial block wrtites shouldn't be allowed */
+
+	if (d->index + cb > d->length)
+		cb = d->length - d->index;
+
+	/* if can't put card in trans state return immediately */
+	if (set_trans_state())
+		return 0;
+
+
+	while (cb) {
+		unsigned long index = d->start + d->index;
+		int availableMax = MMC_SECTOR_SIZE
+			- (index & (MMC_SECTOR_SIZE - 1)); /* Must not overlap a block */
+		int available = cb;
+
+		if (available > availableMax)
+			available = availableMax;
+
+		//    DBG (1, "%ld %ld\n", mmc.ib, index);
+
+		DBG (1, "%s: write av %d  avM %d  ind %ld  cb %d\n", __FUNCTION__,
+			available, availableMax, index, cb);
+
+		SDMMC_BYTCNT = available;
+
+		status = execute_command (CMD_WRITE_SINGLE, index, 
+			SDMMC_INT_CMD_DONE | SDMMC_INT_TXDR);
+
+		DBG (2, "%s: sending waiting to write %x\n", __FUNCTION__, status);
+
+		push_data (pv, available);
+		DBG (2, "%s: restarted %s\n", __FUNCTION__, report_status (SDMMC_RINTSTS));
+		//    status = execute_command (CMD_STOP, 0, 0);
+		status = wait_for_completion (SDMMC_INT_DATA_OVER);
+		DBG (2, "%s: end %s\n", __FUNCTION__, report_status (status));
+
+		d->index += available;
+		cb -= available;
+		cbWrote += available;
+		pv += available;
+	}
+
+	return cbWrote;
+}
+
+static __driver_5 struct driver_d mmc_driver = {
+	.name    = "mmc",
+	.description = "MMC/SD card driver",
+	.flags = DRIVER_READPROGRESS(2),
+	.open    = mmc_open,
+	.close = close_helper,
+	.read    = mmc_read,
+	.write = mmc_write,
+	.seek    = seek_helper,
+};
+
+static __service_6 struct service_d mmc_service = {
+	.init    = mmc_init,
+#if !defined (CONFIG_SMALL)
+	.report  = mmc_report,
+#endif
+};
+
+static int cmd_mmc (int argc, const char** argv)
+{
+
+	mmc_init ();
+
+	return 0;
+}
+
+static __command struct command_d c_mmc = {
+	.command = "mmc",
+	.func = cmd_mmc,
+	COMMAND_DESCRIPTION ("test MMC controller")
+};
diff -purN apex-1.6.8/src/mach-lpc313x/drv-nand.h work_1.6.8/src/mach-lpc313x/drv-nand.h
--- apex-1.6.8/src/mach-lpc313x/drv-nand.h	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/drv-nand.h	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,71 @@
+/* drv-nand.h
+
+Copyright (C) 2008 NXP Semiconductors
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+   -----------
+   DESCRIPTION
+   -----------
+
+   NAND flash hooks.
+
+*/
+
+#if !defined (__DRV_NAND_H__)
+#    define   __DRV_NAND_H__
+
+/* ----- Includes */
+
+#include "mach/hardware.h"
+#include <drv-nand-base.h>
+
+/* ----- Types */
+/* NAND Flash configuration parameters structure used by bootROM */
+typedef struct
+{
+  char   tag[8];
+  u8  interface_width;
+  u8  reserv_1;
+  u16 page_size_in_bytes;
+  u16 page_size_in_32bit_words;
+  u16 pages_per_block;
+  u32 nbr_of_blocks;
+  u8  amount_of_address_bytes;
+  u8  amount_of_erase_address_bytes;
+  u8  support_read_terminate;
+  u8  page_increment_byte_nr;
+  char   device_name[40];
+  u32 timing1;
+  u32 timing2;
+  u8  ecc_mode;
+  u8  id_mask;
+  u8  reserv_2[2];
+
+} NAND_BOOT_CFG_PARAMS_T;
+
+/* ----- Globals */
+#define LPC313x_NAND_BPARAM_PAGE_SZ	256
+#define NANDFLASH_BADBLOCK_LIST_LENGTH 4094  //1 block = min 32 pages = min 16Kbytes (32x512bytes)
+                                             //=> 4094 blocks = min 64Mbytes (should be enough for the image)
+
+
+/* ----- Prototypes */
+
+#define NAND_PHYS	(NANDC_PHYS)
+#define NAND_DATA	(unsigned char) (NANDC_READ_DATA & 0xFF)
+#define NAND_DATA_W	NANDC_WRITE_DATA
+#define NAND_CLE	NANDC_SET_CMD
+#define NAND_ALE	NANDC_SET_ADDR
+
+#define NAND_CS_ENABLE {NANDC_SET_CE &= ~NAND_SETCE_CV(0);}
+#define NAND_CS_DISABLE {NANDC_SET_CE |= NAND_SETCE_CV(0);}
+
+#define NAND_ENABLE nandsys_init()
+
+#define NAND_ISBUSY ((NANDC_CHECK_STS & NAND_CHK_STS_RB1_LVL) == 0)
+
+#endif  /* __DRV_NAND_H__ */
diff -purN apex-1.6.8/src/mach-lpc313x/drv-spinor.c work_1.6.8/src/mach-lpc313x/drv-spinor.c
--- apex-1.6.8/src/mach-lpc313x/drv-spinor.c	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/drv-spinor.c	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,634 @@
+/* drv-spinor.c
+
+written by Durgesh Pattamatta
+19 Oct 2005
+
+Copyright (C) 2008 NXP Semiconductors
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+version 2 as published by the Free Software Foundation.
+Please refer to the file debian/copyright for further details.
+
+-----------
+DESCRIPTION
+-----------
+
+
+*/
+
+#include <config.h>
+#include <apex.h>
+#include <driver.h>
+#include <service.h>
+#include <linux/string.h>
+#include <spinner.h>
+#include <error.h>
+#include <command.h>
+#include <mach/hardware.h>
+
+//#define TALK 1
+#undef TALK 
+
+#if defined (TALK)
+#define PRINTF(f...)    printf (f)
+#define ENTRY(l)    printf ("%s\n", __FUNCTION__)
+#define DBG(l,f...)   do { if (TALK >= l) printf (f); } while (0)
+#else
+#define PRINTF(f...)    do {} while (0)
+#define ENTRY(l)    do {} while (0)
+#define DBG(l,f...)   do {} while (0)
+#endif
+
+
+/* SPI flash command defines */
+#define CMD_RDID        0x9F        /* read device ID */
+#define CMD_RDSR        0xD7        /* read status register */
+#define CMD_FAST_READ   0x0B        /* read data (extra command setup time allows higher SPI clock) */
+#define CMD_SE          0x7C        /* sector erase */
+#define CMD_BE          0x50        /* block erase */
+#define CMD_PE          0x81        /* page erase */
+#define CMD_PP          0x82        /* page program */
+#define CMD_DP          0xB9        /* deep power down */
+#define CMD_RES         0xAB        /* release from deep power down */
+
+#define MANFID_ATMEL    0x1F
+#define DUMMY_BYTE		  0xFF
+
+/* status register defines */
+#define STATUS_RDY      (1 << 7)
+#define STATUS_COMP     (1 << 6)
+#define STATUS_PROTECT  (1 << 1)
+#define STATUS_P512     (1 << 0)
+
+
+typedef struct _SPINOR_INFO_T {
+  u8 id[4];
+  u16 total_pages;
+  u16 page_size;
+  u32 clock;
+  u16 cs;
+  u16 cs_pin;
+  u32 cs_port;
+} SPINOR_INFO_T;
+
+/* forward declarations */
+
+/*global variables */
+static SPINOR_INFO_T* chip;
+static const SPINOR_INFO_T chips[] = 
+{
+  /* Micron MT*/
+#if defined (CONFIG_SPINOR_AT45DB)
+  {
+    .id = {0x1F, 0x27, 1, 0},
+    .page_size = 512,
+    .total_pages = 8192,
+    .clock = 1000000,
+    .cs = 0,
+    .cs_pin = 4,
+    .cs_port = IOCONF_SPI, 
+  },
+#endif
+};
+
+
+void spinor_cs_low(void)
+{
+  //GPIO_OUT_LOW(IOCONF_SPI, _BIT(4));
+  GPIO_OUT_LOW(chip->cs_port, _BIT(chip->cs_pin));
+}
+
+void spinor_cs_high(void)
+{
+  udelay(10);
+  //GPIO_OUT_HIGH(IOCONF_SPI, _BIT(4));
+  GPIO_OUT_HIGH(chip->cs_port, _BIT(chip->cs_pin));
+}
+/*
+Perform a single low level 8bit SPI read
+*/
+u32 spi_read_single8 (void)
+{
+  u32 temp;
+
+  /* Flush all of the RxFifo */
+  while ((SPI_STS_REG & SPI_ST_RX_EMPTY) == 0) {
+    temp = SPI_FIFO_DATA_REG;
+  }
+  /* Write dummy word to generate clock cycles */
+  SPI_FIFO_DATA_REG = 0;
+  /* Please don't combine following two statements. They are intentionaly in sequence*/
+  /* Wait until data read */
+  while (SPI_STS_REG & SPI_ST_RX_EMPTY);
+  /* Wait while spi activity*/
+  while (SPI_STS_REG  & SPI_ST_BUSY); 
+  /* Read the byte */
+  temp = SPI_FIFO_DATA_REG;
+
+  return temp;
+}
+
+/*
+Perform a single low level 8bit SPI write
+*/
+u32 spi_write_single8 (u32 value)
+{
+  /* Write the word to be sent*/
+  SPI_FIFO_DATA_REG = value;
+  /* Please don't combine following two statements. They are intentionaly in sequence*/
+  /* Wait until data transmitted*/
+  while ((SPI_STS_REG & SPI_ST_TX_EMPTY) == 0);
+  /* Wait while spi activity*/
+  while (SPI_STS_REG  & SPI_ST_BUSY); 
+  return 0;
+}
+static u32 spi_read_fifosize (u8 *dst)
+{
+  u32 temp;
+  int count; 
+
+  SPI_SLV_SET2_REG(chip->cs) = SPI_SLV2_WD_SZ(16-1);
+
+  /* Flush all of the RxFifo */
+  while ((SPI_STS_REG & SPI_ST_RX_EMPTY) == 0) {
+    temp = SPI_FIFO_DATA_REG;
+  }
+
+  /* Write dummy word SPI_FIFO_DEPTH times to generate clock cycles for 
+  SPI_FIFO_DEPTH 16-b words */
+  temp = 0;
+  for (count = 0; count < SPI_FIFO_DEPTH; count++ ) {
+    SPI_FIFO_DATA_REG = temp;
+  }
+
+  /* Wait until data read*/
+  while ((SPI_STS_REG & SPI_ST_TX_EMPTY) == 0);
+  /* Wait while spi activity*/
+  while (SPI_STS_REG  & SPI_ST_BUSY); 
+
+  /* Read the data */
+  for (count = 0; count < SPI_FIFO_DEPTH; count++ )
+  {
+    /* attention: following is valid under assumption that we always have msb first. 
+    If that changes, following must change.
+    */
+    temp = SPI_FIFO_DATA_REG;
+    dst[(count << 1) + 0] = (u8) ((temp >> 8) & 0xFF);   // even bytes are input first, so they are high part of the words
+    dst[(count << 1) + 1] = (u8) ((temp >> 0) & 0xFF);   // odd bytes are input second, so they are low part of the words
+  }
+
+  SPI_SLV_SET2_REG(chip->cs) = SPI_SLV2_WD_SZ(8-1);
+
+  return 0;
+}
+
+/*
+Read 'count' bytes from SPI into 'dst' buffer.
+*/
+u32 spi_read_multi (u8 *dst, u32 count)
+{
+  int i = 0;
+
+  while ((count-i) >= (SPI_FIFO_DEPTH<<1))
+  {
+    spi_read_fifosize (&dst[i]);
+    i+= (SPI_FIFO_DEPTH<<1);
+  }
+
+  /* Crude and simple read of remaining bytes...*/
+
+  for (; i < count; i++)
+    dst[i] = (u8) spi_read_single8();
+
+  return 0;
+}
+
+static u32 spi_write_fifosize (u8 *src)
+{
+  u32 temp;
+  int count; 
+
+  SPI_SLV_SET2_REG(chip->cs) = SPI_SLV2_WD_SZ(16-1);
+
+  /* Write data in form of SPI_FIFO_DEPTH 16-b words  */
+  for (count = 0; count < SPI_FIFO_DEPTH; count++ ) {
+    /* attention: following is valid under assumption that we always have msb first. 
+    If that changes, following must change */
+    temp = src[count<<1];      /* even bytes go first */
+    temp <<= 8;                /* so they are high part of 16-b word */
+    temp |= src[(count<<1)+1]; /* then odd bytes */
+
+    SPI_FIFO_DATA_REG = temp;
+  }
+
+  /* Wait until data read*/
+  while ((SPI_STS_REG & SPI_ST_TX_EMPTY) == 0);
+  /* Wait while spi activity*/
+  while (SPI_STS_REG  & SPI_ST_BUSY); 
+
+  SPI_SLV_SET2_REG(chip->cs) = SPI_SLV2_WD_SZ(8-1);
+
+  return 0;
+}
+
+
+/*
+Write 'count' bytes from 'src' buffer to SPI.
+*/
+u32 spi_write_multi (u8 *src, u32 count)
+{
+  int i = 0;
+
+  while ((count - i) >= (SPI_FIFO_DEPTH << 1)) {
+    spi_write_fifosize (&src[i]);
+    i += (SPI_FIFO_DEPTH << 1);
+  }
+
+  /* Crude and simple write of remaining bytes */
+
+  for (; i < count; i++)
+    spi_write_single8 (src[i]);
+
+  return 0;
+}
+
+
+static int spinor_read_device_id (u8 *device_id)
+{
+  spinor_cs_low();
+  spi_write_single8 (CMD_RDID);
+  spi_read_multi (device_id, 3);  /* 3 bytes: manufacturer id, device type, device capacity */
+  spinor_cs_high();
+  return 0;
+}
+
+static int spinor_simple_command (u8 command_byte)
+{
+  spinor_cs_low();
+  spi_write_single8 (command_byte);
+  /*
+  Note that the above write _must_ have completed (ie sent to
+  SPI nor device and not stuck in a write fifo somewhere) before
+  CS is de-asserted. 
+  */
+  spinor_cs_high();
+  return 0;
+}
+
+static int spinor_enter_deep_power_down (void)
+{
+  return spinor_simple_command (CMD_DP);
+  return 0;
+}
+
+static int spinor_exit_deep_power_down (void)
+{
+  spinor_simple_command (CMD_RES);
+  /* max tEDPD in Atmel AT45DB161D-SU datasheet is given as 35 usec */
+  udelay (50);                    
+  return 0;
+}
+
+
+
+static int spinor_read_status_register (u32 *status)
+{
+  spinor_cs_low();
+  spi_write_single8 (CMD_RDSR);
+  *status = spi_read_single8();
+  spinor_cs_high();
+  return 0;
+}
+
+static int spinor_poll_is_busy (void)
+{
+  u32 status;
+
+  spinor_cs_low();
+  spi_write_single8 (CMD_RDSR);
+
+  while (1) {
+    udelay (10);
+    status = spi_read_single8();
+    if (status & STATUS_RDY)
+      break;
+  }
+
+  spinor_cs_high();
+
+  return 0;
+}
+
+static int spinor_page_erase (u32 offset)
+{
+  spinor_cs_low();
+  spi_write_single8 (CMD_PE);
+  spi_write_single8 ((offset >> 16) & 0xFF);  /* 24bit address upper byte */
+  spi_write_single8 ((offset >>  8) & 0xFF);  /* 24bit address middle byte */
+  spi_write_single8 ((offset >>  0) & 0xFF);  /* 24bit address least significant byte */
+  /*
+  Note that the above write _must_ have completed (ie sent to
+  SPI nor device and not stuck in a write fifo somewhere) before
+  CS is de-asserted. We rely on the SPI driver to take of this !!
+  */
+  spinor_cs_high();
+
+  spinor_poll_is_busy();
+  return 0;
+}
+
+static int spinor_page_program (u32 offset, u8 *src)
+{
+  spinor_cs_low();
+  spi_write_single8 (CMD_PP);
+  spi_write_single8 ((offset >> 16) & 0xFF);  /* 24bit address upper byte */
+  spi_write_single8 ((offset >>  8) & 0xFF);  /* 24bit address middle byte */
+  spi_write_single8 ((offset >>  0) & 0xFF);  /* 24bit address least significant byte */
+  spi_write_multi (src, chip->page_size);
+  /*
+  Note that the above write _must_ have completed (ie sent to
+  SPI nor device and not stuck in a write fifo somewhere) before
+  CS is de-asserted. We rely on the SPI driver to take of this !!
+  */
+  spinor_cs_high();
+
+  spinor_poll_is_busy();
+  return 0;
+}
+
+static int spi_get_clock_div(u32 target_clock,
+                                u32 *pDivSet)
+{
+  u32 div, spi_clk, ps, div1;
+  int retvalue = -1;
+
+  /* The SPI clock is derived from the (main system PLL / 2),
+     so compute the best divider from that clock */
+  spi_clk = cgu_get_clk_freq(CGU_SB_SPI_CLK_ID);
+
+  /* Find closest divider to get at or under the target frequency.
+     Use smallest prescaler possible and rely on the divider to get
+     the closest target frequency */
+  div = (spi_clk + target_clock / 2) / target_clock;
+
+  if ((div < SPI_MAX_DIVIDER) && (div > SPI_MIN_DIVIDER))
+  {
+    ps = (((div - 1) / 512) + 1) * 2;
+    div1 = ((((div + ps / 2) / ps) - 1));
+
+    /* write the divider settings */
+    *pDivSet = SPI_SLV1_CLK_PS(ps) | SPI_SLV1_CLK_DIV1((div1));
+
+    retvalue = 0;
+  }
+  DBG(1, "SPI clocks - base:%d req:%d div:0x%08x \n", 
+         spi_clk, target_clock, *pDivSet);
+
+  return retvalue;
+}
+
+
+static int spinor_open (struct descriptor_d* d)
+{
+  u32 status;
+  if (!chip)
+    return -1;
+
+#if defined (CONFIG_SPINOR_AT45DB)
+  /* check status if 528 byte device program it to be a 512 byte device */
+  spinor_read_status_register(&status);
+  if ((status & STATUS_P512) == 0) {
+    /* program device to 512 mode. needs a power cycle after this.*/
+    spinor_cs_low();
+    spi_write_single8 (0x3D);
+    spi_write_single8 (0x2A);
+    spi_write_single8 (0x80);
+    spi_write_single8 (0xA6);
+    spinor_cs_high();
+    printf (" Power cycle the board for 512 byte page size switch to be affective. \n");
+    chip = NULL;
+  }
+#endif
+
+  return 0;
+}
+
+static ssize_t spinor_read (struct descriptor_d* d, void* pv, size_t cb)
+{
+  ssize_t cbRead = 0;
+  int index = (d->start + d->index);
+
+  if (!chip)
+    return cbRead;
+
+  if ((d->index + cb) > d->length)
+    cb = d->length - d->index;
+
+  spinor_exit_deep_power_down();
+
+  /* do read setup */
+  spinor_cs_low();
+  spi_write_single8 (CMD_FAST_READ);          /* FAST_READ is safe at all supported SPI speeds... */
+  spi_write_single8 ((index >> 16) & 0xFF);  /* 24bit address upper byte */
+  spi_write_single8 ((index >>  8) & 0xFF);  /* 24bit address middle byte */
+  spi_write_single8 ((index >>  0) & 0xFF);  /* 24bit address least significant byte */
+  spi_write_single8 (0);                      /* dummy byte */
+  spi_read_multi (pv, cb);            /* data */
+  spinor_cs_high();
+  d->index += cb;
+
+  spinor_enter_deep_power_down();
+
+  return cb;
+}
+
+static ssize_t spinor_write (struct descriptor_d* d, const void* pv, size_t cb)
+{
+  int cbWrote = 0;
+
+  if (!chip)
+    return cbWrote;
+
+  /* this driver always writes on page (512) boundaries only */
+  if ((d->start + d->index) & (chip->page_size - 1)) {
+    printf("spinor: unaligned write 0x%08x FAILED!!\n", d->start + d->index);
+    return 0;
+  }
+  if ((d->index + cb) > d->length)
+    cb = d->length - d->index;
+
+  spinor_exit_deep_power_down();
+  while (cb) {
+    int available = chip->page_size;
+
+    if (available > cb)
+      available = cb;
+
+    DBG(2, "spinor write page:0x%08x pv:0x%08x\n", 
+        (d->start + d->index)/chip->page_size, (u32)(pv + cbWrote));
+
+    spinor_page_program(d->start + d->index, (u8*)((u32)pv + cbWrote));
+    d->index += available;
+    cb -= available;
+    cbWrote += available;
+  }
+  spinor_enter_deep_power_down();
+
+  return cbWrote;
+}
+
+
+static void spinor_erase (struct descriptor_d* d, size_t cb)
+{
+  if (!chip)
+    return;
+
+  /* this driver always writes on page (512) boundaries only */
+  if ((d->start + d->index) & (chip->page_size - 1)) {
+    printf("spinor: unaligned write 0x%08x FAILED!!\n", d->start + d->index);
+    return;
+  }
+  if ((d->index + cb) > d->length)
+    cb = d->length - d->index;
+
+  spinor_exit_deep_power_down();
+  while (cb) {
+    int available = chip->page_size;
+
+    if (available > cb)
+      available = cb;
+
+    DBG(1, "spinor page erase:0x%08x \n",
+      (d->start + d->index)/chip->page_size);
+    spinor_page_erase(d->start + d->index);
+    d->index += available;
+    cb -= available;
+  }
+  spinor_enter_deep_power_down();
+}
+
+#if !defined (CONFIG_SMALL)
+static void spinor_report (void)
+{
+  u32 status;
+
+  if (!chip)
+    return;
+
+  spinor_read_status_register(&status);
+
+  printf ("  spinor:   %d MiB total, %d B page %s%s%s%s\n",
+    (chip->page_size * chip->total_pages)/(1024*1024), 
+    chip->page_size,
+    (status & STATUS_RDY) ? " RDY" : "BSY",
+    (status & STATUS_COMP) ? " FAIL" : "",
+    (status & STATUS_PROTECT) ? " R/O" : " R/W",
+    (status & STATUS_P512) ? " 512" : " 528"
+    );
+}
+#endif
+
+static __driver_3 struct driver_d spinor_driver = {
+  .name = "spinor",
+  .description = "LPC SPI flash driver",
+  .flags = DRIVER_WRITEPROGRESS(6),
+  .open = spinor_open,
+  .close = close_helper,
+  .read = spinor_read,
+  .write = spinor_write,
+  .erase = spinor_erase,
+  .seek = seek_helper,
+};
+
+/* spinor_init
+
+probes the NAND flash device.
+
+Note that the status check redundantly sends the Status command
+when we are not using the CONFIG_NAND_LPD mode.  It's left in for
+now.
+*/
+static void spinor_init (void)
+{
+  u32 clk_div = 0;
+  u8 id[4] = {1, 2, 3, 4};
+
+  /* Enable SPI clock */
+  cgu_clk_en_dis(CGU_SB_SPI_PCLK_ID, 1);
+  cgu_clk_en_dis(CGU_SB_SPI_PCLK_GATED_ID, 1);
+  cgu_clk_en_dis(CGU_SB_SPI_CLK_ID, 1);
+  cgu_clk_en_dis(CGU_SB_SPI_CLK_GATED_ID, 1);
+
+  /* reset the SPI block */
+  SPI_CONFIG_REG = SPI_CFG_SW_RESET;
+
+  DBG(2, "spinor: 0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx\n",
+      SPI_CONFIG_REG, SPI_SLV_ENAB_REG, SPI_STS_REG, 
+      SPI_SLV_SET1_REG(0), SPI_SLV_SET2_REG(0));
+
+  /* configure SPI*/
+  for (chip = (SPINOR_INFO_T*)&chips[0];
+    chip < (chips + sizeof(chips)/sizeof (SPINOR_INFO_T)); ++chip) {
+  
+    SPI_CONFIG_REG &= ~SPI_CFG_ENABLE;
+    spinor_cs_high();       /* Make nCS an output, initially high (ie de-asserted) */
+
+    SPI_SLV_ENAB_REG = SPI_SLV_EN(chip->cs);
+    SPI_CONFIG_REG |= SPI_CFG_UPDATE_EN;
+    SPI_CONFIG_REG |= SPI_CFG_ENABLE;
+
+    if (spi_get_clock_div(chip->clock, &clk_div)) {
+
+      DBG(1, "SPI clock divider not found. cs:%d "
+             "id:0x%02x 0x%02x 0x%02x 0x%02x \n", 
+             chip->cs, chip->id[0], chip->id[1], chip->id[2], chip->id[3]);
+      continue;
+    }
+
+    SPI_SLV_SET1_REG(chip->cs) = clk_div;
+    SPI_SLV_SET2_REG(chip->cs) = SPI_SLV2_WD_SZ(8-1);
+
+    DBG(2, "spinor: 0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx\n",
+      SPI_CONFIG_REG, SPI_SLV_ENAB_REG, SPI_STS_REG, 
+      SPI_SLV_SET1_REG(0), SPI_SLV_SET2_REG(0));
+
+    spinor_exit_deep_power_down();
+    spinor_read_device_id(id);
+
+    DBG(1, "spinor: ID 0x%02x/0x%02x/0x%02x/0x%02x stat:0x%08lx\n",
+      id[0], id[1], id[2], id[3], SPI_STS_REG);
+
+#ifdef _M
+#undef _M
+#endif
+#define _M(i) (id[(i)] == chip->id[(i)])
+    if (_M (0) && _M (1) && _M (2)) {
+        DBG(1, "ID matchded\n");
+        break;
+    }
+#undef _M
+  }
+
+  if (chip >= (chips + sizeof(chips)/sizeof (chips[0])))
+    chip = NULL;
+
+  if (chip)
+    printf (" %d MiB total, %d B page"
+      " (0x%02x/0x%02x/0x%02x/0x%02x)\n",
+      (chip->total_pages * chip->page_size)/(1024*1024), 
+      chip->page_size,
+      id[0], id[1], id[2], id[3]);
+  else
+    printf (" unknown 0x%02x/0x%02x/0x%02x/0x%02x\n",
+      id[0], id[1], id[2], id[3]);
+
+}
+
+static __service_6 struct service_d spinor_service = {
+  .init = spinor_init,
+#if !defined (CONFIG_SMALL)
+  .report = spinor_report,
+#endif
+};
+
diff -purN apex-1.6.8/src/mach-lpc313x/ea313x_v1_config work_1.6.8/src/mach-lpc313x/ea313x_v1_config
--- apex-1.6.8/src/mach-lpc313x/ea313x_v1_config	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/ea313x_v1_config	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,155 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: KERNELVERSION
+# Wed Sep 30 11:17:19 2009
+#
+CONFIG_ARM=y
+CONFIG_CPU_ARMV5=y
+CONFIG_CPU_ARM9=y
+CONFIG_CPU_ARM926T=y
+# CONFIG_ARCH_LH7952X is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_IXP42X is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_MX3 is not set
+# CONFIG_ARCH_ORION5X is not set
+CONFIG_ARCH_LPC313X=y
+# CONFIG_EXPERIMENTAL is not set
+# CONFIG_SMALL is not set
+
+#
+# General Setup
+#
+CONFIG_TARGET_DESCRIPTION="Unspecified target"
+CONFIG_CROSS_COMPILE="arm-linux-"
+CONFIG_AEABI=y
+# CONFIG_DRIVER_LONG_LONG_SIZE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_CC_OPTIMIZE_FOR_SPEED is not set
+# CONFIG_CC_NO_OPTIMIZATION is not set
+# CONFIG_STARTUP_UART is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_SPINNER=y
+CONFIG_ATAG=y
+# CONFIG_MMU is not set
+CONFIG_DISABLE_MMU_AT_BOOT=y
+CONFIG_SDRAMBOOT_REPORT=y
+CONFIG_STACK_SIZE=0x1000
+# CONFIG_BOOTSTRAP_MEMTEST is not set
+CONFIG_ATAG_PHYS=0x30000100
+CONFIG_ARCH_NUMBER=9998
+CONFIG_APEX_VMA=0x11029000
+CONFIG_KERNEL_LMA=0x30008000
+CONFIG_USE_RAMDISK=y
+CONFIG_RAMDISK_LMA=0x32000000
+CONFIG_MACH="lpc313x"
+CONFIG_RAMDISK_SIZE=0x00300000
+# CONFIG_MACH_VAL3153 is not set
+# CONFIG_MACH_VAL3154 is not set
+CONFIG_MACH_EA313x_V1=y
+# CONFIG_MACH_EA313x_V2 is not set
+
+#
+# Platform Setup
+#
+CONFIG_OSC_FREQ=12000000
+CONFIG_PLL_180=y
+# CONFIG_PLL_270 is not set
+CONFIG_DYNAMIC_CLOCKS=y
+# CONFIG_USB_BOOT is not set
+CONFIG_AUTOFORMAT_BLOCK0=y
+CONFIG_MICRON_MT29F2G08=y
+# CONFIG_MICRON_MT29F4G08 is not set
+# CONFIG_SAMSUNG_K9K8G is not set
+# CONFIG_TOSHIBA_TC58DVM82A is not set
+CONFIG_DRIVER_SPINOR=y
+CONFIG_SPINOR_AT45DB=y
+CONFIG_USES_SPINOR=y
+
+#
+# Commands
+#
+CONFIG_ALLHELP=y
+CONFIG_ALPHABETIZE_COMMANDS=y
+CONFIG_PARTIAL_MATCHES=y
+CONFIG_DEL_IS_BS=y
+CONFIG_ANSI_KEYS=y
+CONFIG_COMMAND_HISTORY=y
+CONFIG_COMMAND_EDITING=y
+# CONFIG_TIME_COMMANDS is not set
+CONFIG_CMD_ALIAS=y
+CONFIG_CMD_CHECKSUM=y
+CONFIG_CMD_COPY=y
+CONFIG_CMD_COMPARE=y
+CONFIG_CMD_DRVINFO=y
+CONFIG_CMD_DUMP=y
+CONFIG_CMD_ENV=y
+CONFIG_CMD_IMAGE=y
+CONFIG_CMD_IMAGE_APEX=y
+# CONFIG_CMD_IMAGE_UBOOT is not set
+CONFIG_CMD_IMAGE_SHOW=y
+CONFIG_CMD_SETENV=y
+CONFIG_CMD_ERASE=y
+CONFIG_CMD_FILL=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_INFO=y
+# CONFIG_CMD_PARSE is not set
+# CONFIG_CMD_PAUSE is not set
+# CONFIG_CMD_FLASHUSAGE is not set
+CONFIG_CMD_WAIT=y
+CONFIG_CMD_XRECEIVE=y
+# CONFIG_CMD_MEMLIMIT is not set
+# CONFIG_CMD_MEMSCAN is not set
+# CONFIG_CMD_MEMTEST is not set
+CONFIG_CMD_NAND=y
+# CONFIG_CRC32_LSB is not set
+
+#
+# Generic Drivers
+#
+# CONFIG_DRIVER_FAT is not set
+CONFIG_DRIVER_EXT2=y
+CONFIG_DRIVER_EXT2_BLOCKDEVICE="mmc"
+# CONFIG_DRIVER_JFFS2 is not set
+# CONFIG_DRIVER_FIS is not set
+CONFIG_DRIVER_NAND=y
+# CONFIG_DRIVER_NAND_TYPE_TOSHIBA is not set
+# CONFIG_DRIVER_NAND_TYPE_ST is not set
+CONFIG_DRIVER_NAND_TYPE_MICRON=y
+CONFIG_DRIVER_NAND_ADDRESS_BYTES=2
+# CONFIG_DRIVER_ONENAND is not set
+CONFIG_USES_NAND=y
+CONFIG_USES_PATHNAME_PARSER=y
+
+#
+# Environment
+#
+CONFIG_ENV=y
+CONFIG_ENV_MUTABLE=y
+CONFIG_ENV_REGION="lnand:512k+256k"
+CONFIG_ENV_SAVEATONCE=y
+CONFIG_ENV_SIZE=16384
+CONFIG_ENV_CHECK_LEN=1024
+# CONFIG_VARIATIONS is not set
+CONFIG_NO_BOOTSTRAP=y
+# CONFIG_NOR_BOOT is not set
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_COMPANION_EVT1_BOOT is not set
+# CONFIG_COMPANION_EVT2_BOOT is not set
+# CONFIG_ENV_STARTUP_PREFIX_P is not set
+
+#
+# Regions
+#
+CONFIG_ENV_REGION_KERNEL="lnand:768k+2m"
+CONFIG_ENV_REGION_RAMDISK="lnand:4864K+2m"
+
+#
+# Overrides
+#
+# CONFIG_ENV_DEFAULT_CMDLINE_OVERRIDE is not set
+CONFIG_ENV_DEFAULT_STARTUP_OVERRIDE=y
+CONFIG_ENV_DEFAULT_STARTUP="wait 10;copy $kernelsrc $bootaddr;copy $ramdisksrc $ramdiskaddr; boot"
+CONFIG_RELOCATE_SIMPLE=y
+CONFIG_ALIASES=y
diff -purN apex-1.6.8/src/mach-lpc313x/ea313x_v2_config work_1.6.8/src/mach-lpc313x/ea313x_v2_config
--- apex-1.6.8/src/mach-lpc313x/ea313x_v2_config	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/ea313x_v2_config	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,171 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: KERNELVERSION
+# Fri Nov 20 13:19:40 2009
+#
+CONFIG_ARM=y
+CONFIG_CPU_ARMV5=y
+CONFIG_CPU_ARM9=y
+CONFIG_CPU_ARM926T=y
+# CONFIG_ARCH_LH7952X is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_IXP42X is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_MX3 is not set
+# CONFIG_ARCH_ORION5X is not set
+CONFIG_ARCH_LPC313X=y
+# CONFIG_EXPERIMENTAL is not set
+# CONFIG_SMALL is not set
+
+#
+# General Setup
+#
+CONFIG_TARGET_DESCRIPTION="Unspecified target"
+CONFIG_CROSS_COMPILE="arm-linux-"
+CONFIG_AEABI=y
+# CONFIG_DRIVER_LONG_LONG_SIZE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_CC_OPTIMIZE_FOR_SPEED is not set
+# CONFIG_CC_NO_OPTIMIZATION is not set
+# CONFIG_STARTUP_UART is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_SPINNER=y
+CONFIG_ATAG=y
+# CONFIG_MMU is not set
+CONFIG_DISABLE_MMU_AT_BOOT=y
+CONFIG_SDRAMBOOT_REPORT=y
+CONFIG_STACK_SIZE=0x1000
+# CONFIG_BOOTSTRAP_MEMTEST is not set
+CONFIG_ATAG_PHYS=0x30000100
+CONFIG_ARCH_NUMBER=9998
+CONFIG_APEX_VMA=0x11029000
+CONFIG_KERNEL_LMA=0x30008000
+# CONFIG_USE_RAMDISK is not set
+CONFIG_MACH="lpc313x"
+# CONFIG_MACH_VAL3153 is not set
+# CONFIG_MACH_VAL3154 is not set
+# CONFIG_MACH_EA313x_V1 is not set
+CONFIG_MACH_EA313x_V2=y
+
+#
+# Platform Setup
+#
+CONFIG_OSC_FREQ=12000000
+CONFIG_PLL_180=y
+# CONFIG_PLL_270 is not set
+CONFIG_DYNAMIC_CLOCKS=y
+# CONFIG_USB_BOOT is not set
+CONFIG_AUTOFORMAT_BLOCK0=y
+CONFIG_MICRON_MT29F2G08=y
+# CONFIG_MICRON_MT29F4G08 is not set
+# CONFIG_SAMSUNG_K9K8G is not set
+# CONFIG_TOSHIBA_TC58DVM82A is not set
+CONFIG_DRIVER_SPINOR=y
+CONFIG_SPINOR_AT45DB=y
+CONFIG_USES_SPINOR=y
+
+#
+# Commands
+#
+CONFIG_ALLHELP=y
+CONFIG_ALPHABETIZE_COMMANDS=y
+CONFIG_PARTIAL_MATCHES=y
+CONFIG_DEL_IS_BS=y
+CONFIG_ANSI_KEYS=y
+CONFIG_COMMAND_HISTORY=y
+CONFIG_COMMAND_EDITING=y
+# CONFIG_TIME_COMMANDS is not set
+CONFIG_CMD_ALIAS=y
+CONFIG_CMD_CHECKSUM=y
+CONFIG_CMD_COPY=y
+CONFIG_CMD_COMPARE=y
+CONFIG_CMD_DRVINFO=y
+CONFIG_CMD_DUMP=y
+CONFIG_CMD_ENV=y
+CONFIG_CMD_IMAGE=y
+CONFIG_CMD_IMAGE_APEX=y
+# CONFIG_CMD_IMAGE_UBOOT is not set
+CONFIG_CMD_IMAGE_SHOW=y
+CONFIG_CMD_SETENV=y
+CONFIG_CMD_ERASE=y
+CONFIG_CMD_FILL=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_INFO=y
+# CONFIG_CMD_PARSE is not set
+# CONFIG_CMD_PAUSE is not set
+# CONFIG_CMD_FLASHUSAGE is not set
+CONFIG_CMD_WAIT=y
+CONFIG_CMD_XRECEIVE=y
+CONFIG_CMD_ETH_DM9000=y
+# CONFIG_CMD_MEMLIMIT is not set
+# CONFIG_CMD_MEMSCAN is not set
+# CONFIG_CMD_MEMTEST is not set
+CONFIG_CMD_NAND=y
+# CONFIG_CRC32_LSB is not set
+
+#
+# Generic Drivers
+#
+CONFIG_DRIVER_FAT=y
+CONFIG_DRIVER_FAT_BLOCKDEVICE="mmc"
+CONFIG_DRIVER_EXT2=y
+CONFIG_DRIVER_EXT2_BLOCKDEVICE="mmc"
+# CONFIG_DRIVER_JFFS2 is not set
+# CONFIG_DRIVER_FIS is not set
+CONFIG_DRIVER_NAND=y
+# CONFIG_DRIVER_NAND_TYPE_TOSHIBA is not set
+# CONFIG_DRIVER_NAND_TYPE_ST is not set
+CONFIG_DRIVER_NAND_TYPE_MICRON=y
+CONFIG_DRIVER_NAND_ADDRESS_BYTES=4
+# CONFIG_DRIVER_ONENAND is not set
+CONFIG_DRIVER_DM9000=y
+CONFIG_USES_NAND=y
+CONFIG_USES_PATHNAME_PARSER=y
+CONFIG_USES_DM9000=y
+
+#
+# Ethernet Networking
+#
+CONFIG_ETHERNET=y
+CONFIG_CMD_IPCONFIG=y
+CONFIG_CMD_IPCONFIG_STATIC=y
+CONFIG_CMD_IPCONFIG_RARP=y
+CONFIG_CMD_IPCONFIG_BOOTP=y
+# CONFIG_CMD_IPCONFIG_DHCP is not set
+CONFIG_PROTO_ICMP_ECHO=y
+# CONFIG_CMD_PING is not set
+# CONFIG_CMD_ARP is not set
+CONFIG_CMD_TFTP=y
+CONFIG_USE_ETHERNET=y
+
+#
+# Environment
+#
+CONFIG_ENV=y
+CONFIG_ENV_MUTABLE=y
+CONFIG_ENV_REGION="lnand:512k+256k"
+CONFIG_ENV_SAVEATONCE=y
+CONFIG_ENV_SIZE=16384
+CONFIG_ENV_CHECK_LEN=1024
+# CONFIG_VARIATIONS is not set
+CONFIG_NO_BOOTSTRAP=y
+# CONFIG_NOR_BOOT is not set
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_COMPANION_EVT1_BOOT is not set
+# CONFIG_COMPANION_EVT2_BOOT is not set
+# CONFIG_ENV_STARTUP_PREFIX_P is not set
+
+#
+# Regions
+#
+CONFIG_ENV_REGION_KERNEL="tftp://$serverip/zImage"
+
+#
+# Overrides
+#
+# CONFIG_ENV_DEFAULT_CMDLINE_OVERRIDE is not set
+CONFIG_ENV_DEFAULT_STARTUP_OVERRIDE=y
+CONFIG_ENV_DEFAULT_STARTUP="eth mac 00:08:ee:00:80:43;ipconfig rarp; copy $kernelsrc $bootaddr; boot"
+CONFIG_RELOCATE_SIMPLE=y
+CONFIG_ALIASES=y
diff -purN apex-1.6.8/src/mach-lpc313x/ea313x_v2_ram_config work_1.6.8/src/mach-lpc313x/ea313x_v2_ram_config
--- apex-1.6.8/src/mach-lpc313x/ea313x_v2_ram_config	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/ea313x_v2_ram_config	2010-03-25 14:29:18.000000000 -0700
@@ -0,0 +1,176 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: KERNELVERSION
+# Thu Mar 25 13:40:21 2010
+#
+CONFIG_ARM=y
+CONFIG_CPU_ARMV5=y
+CONFIG_CPU_ARM9=y
+CONFIG_CPU_ARM926T=y
+# CONFIG_ARCH_LH7952X is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_IXP42X is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_MX3 is not set
+# CONFIG_ARCH_ORION5X is not set
+CONFIG_ARCH_LPC313X=y
+# CONFIG_EXPERIMENTAL is not set
+# CONFIG_SMALL is not set
+
+#
+# General Setup
+#
+CONFIG_TARGET_DESCRIPTION="Unspecified target"
+CONFIG_CROSS_COMPILE="arm-linux-"
+CONFIG_AEABI=y
+# CONFIG_DRIVER_LONG_LONG_SIZE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_CC_OPTIMIZE_FOR_SPEED is not set
+# CONFIG_CC_NO_OPTIMIZATION is not set
+# CONFIG_STARTUP_UART is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_SPINNER=y
+CONFIG_ATAG=y
+# CONFIG_MMU is not set
+CONFIG_DISABLE_MMU_AT_BOOT=y
+CONFIG_SDRAMBOOT_REPORT=y
+CONFIG_STACK_SIZE=0x1000
+# CONFIG_BOOTSTRAP_MEMTEST is not set
+CONFIG_ATAG_PHYS=0x30000100
+CONFIG_ARCH_NUMBER=9998
+CONFIG_APEX_VMA=0x11029000
+CONFIG_KERNEL_LMA=0x30008000
+CONFIG_USE_RAMDISK=y
+CONFIG_RAMDISK_LMA=0x32000000
+CONFIG_MACH="lpc313x"
+CONFIG_RAMDISK_SIZE=0x00300000
+# CONFIG_MACH_VAL3153 is not set
+# CONFIG_MACH_VAL3154 is not set
+# CONFIG_MACH_EA313x_V1 is not set
+CONFIG_MACH_EA313x_V2=y
+# CONFIG_MACH_EA3152 is not set
+
+#
+# Platform Setup
+#
+CONFIG_OSC_FREQ=12000000
+CONFIG_PLL_180=y
+# CONFIG_PLL_270 is not set
+CONFIG_DYNAMIC_CLOCKS=y
+# CONFIG_USB_BOOT is not set
+CONFIG_AUTOFORMAT_BLOCK0=y
+CONFIG_MICRON_MT29F2G08=y
+# CONFIG_MICRON_MT29F4G08 is not set
+# CONFIG_SAMSUNG_K9K8G is not set
+# CONFIG_TOSHIBA_TC58DVM82A is not set
+CONFIG_DRIVER_SPINOR=y
+CONFIG_SPINOR_AT45DB=y
+CONFIG_USES_SPINOR=y
+
+#
+# Commands
+#
+CONFIG_ALLHELP=y
+CONFIG_ALPHABETIZE_COMMANDS=y
+CONFIG_PARTIAL_MATCHES=y
+CONFIG_DEL_IS_BS=y
+CONFIG_ANSI_KEYS=y
+CONFIG_COMMAND_HISTORY=y
+CONFIG_COMMAND_EDITING=y
+# CONFIG_TIME_COMMANDS is not set
+CONFIG_CMD_ALIAS=y
+CONFIG_CMD_CHECKSUM=y
+CONFIG_CMD_COPY=y
+CONFIG_CMD_COMPARE=y
+CONFIG_CMD_DRVINFO=y
+CONFIG_CMD_DUMP=y
+CONFIG_CMD_ENV=y
+CONFIG_CMD_IMAGE=y
+CONFIG_CMD_IMAGE_APEX=y
+# CONFIG_CMD_IMAGE_UBOOT is not set
+CONFIG_CMD_IMAGE_SHOW=y
+CONFIG_CMD_SETENV=y
+CONFIG_CMD_ERASE=y
+CONFIG_CMD_FILL=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_INFO=y
+# CONFIG_CMD_PARSE is not set
+# CONFIG_CMD_PAUSE is not set
+# CONFIG_CMD_FLASHUSAGE is not set
+CONFIG_CMD_WAIT=y
+CONFIG_CMD_XRECEIVE=y
+CONFIG_CMD_ETH_DM9000=y
+# CONFIG_CMD_MEMLIMIT is not set
+# CONFIG_CMD_MEMSCAN is not set
+# CONFIG_CMD_MEMTEST is not set
+CONFIG_CMD_NAND=y
+# CONFIG_CRC32_LSB is not set
+
+#
+# Generic Drivers
+#
+CONFIG_DRIVER_FAT=y
+CONFIG_DRIVER_FAT_BLOCKDEVICE="mmc"
+CONFIG_DRIVER_EXT2=y
+CONFIG_DRIVER_EXT2_BLOCKDEVICE="mmc"
+# CONFIG_DRIVER_JFFS2 is not set
+# CONFIG_DRIVER_FIS is not set
+CONFIG_DRIVER_NAND=y
+# CONFIG_DRIVER_NAND_TYPE_TOSHIBA is not set
+# CONFIG_DRIVER_NAND_TYPE_ST is not set
+CONFIG_DRIVER_NAND_TYPE_MICRON=y
+CONFIG_DRIVER_NAND_ADDRESS_BYTES=4
+# CONFIG_DRIVER_ONENAND is not set
+CONFIG_DRIVER_DM9000=y
+CONFIG_USES_NAND=y
+CONFIG_USES_PATHNAME_PARSER=y
+CONFIG_USES_DM9000=y
+
+#
+# Ethernet Networking
+#
+CONFIG_ETHERNET=y
+CONFIG_CMD_IPCONFIG=y
+CONFIG_CMD_IPCONFIG_STATIC=y
+CONFIG_CMD_IPCONFIG_RARP=y
+CONFIG_CMD_IPCONFIG_BOOTP=y
+# CONFIG_CMD_IPCONFIG_DHCP is not set
+CONFIG_PROTO_ICMP_ECHO=y
+# CONFIG_CMD_PING is not set
+# CONFIG_CMD_ARP is not set
+CONFIG_CMD_TFTP=y
+CONFIG_USE_ETHERNET=y
+
+#
+# Environment
+#
+CONFIG_ENV=y
+CONFIG_ENV_MUTABLE=y
+CONFIG_ENV_REGION="lnand:512k+256k"
+CONFIG_ENV_SAVEATONCE=y
+CONFIG_ENV_SIZE=16384
+CONFIG_ENV_CHECK_LEN=1024
+# CONFIG_VARIATIONS is not set
+CONFIG_NO_BOOTSTRAP=y
+# CONFIG_NOR_BOOT is not set
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_COMPANION_EVT1_BOOT is not set
+# CONFIG_COMPANION_EVT2_BOOT is not set
+# CONFIG_ENV_STARTUP_PREFIX_P is not set
+
+#
+# Regions
+#
+CONFIG_ENV_REGION_KERNEL="tftp://$serverip/zImage"
+CONFIG_ENV_REGION_RAMDISK="tftp://$serverip/ramdisk_image.gz"
+
+#
+# Overrides
+#
+CONFIG_ENV_DEFAULT_CMDLINE_OVERRIDE=y
+CONFIG_ENV_DEFAULT_CMDLINE="console=ttyS0,115200n8 root=/dev/ram0 rw loglevel=7 ip=rarp ramdisk_size=12000k"
+CONFIG_ENV_DEFAULT_STARTUP_OVERRIDE=y
+CONFIG_ENV_DEFAULT_STARTUP="eth mac 00:08:ee:00:80:44;ipconfig rarp; copy $ramdisksrc $ramdiskaddr; copy $kernelsrc $bootaddr; boot"
+CONFIG_RELOCATE_SIMPLE=y
+CONFIG_ALIASES=y
diff -purN apex-1.6.8/src/mach-lpc313x/ea3152_config work_1.6.8/src/mach-lpc313x/ea3152_config
--- apex-1.6.8/src/mach-lpc313x/ea3152_config	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/ea3152_config	2010-03-15 13:39:53.000000000 -0700
@@ -0,0 +1,173 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: KERNELVERSION
+# Mon Mar 15 13:23:32 2010
+#
+CONFIG_ARM=y
+CONFIG_CPU_ARMV5=y
+CONFIG_CPU_ARM9=y
+CONFIG_CPU_ARM926T=y
+# CONFIG_ARCH_LH7952X is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_IXP42X is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_MX3 is not set
+# CONFIG_ARCH_ORION5X is not set
+CONFIG_ARCH_LPC313X=y
+# CONFIG_EXPERIMENTAL is not set
+# CONFIG_SMALL is not set
+
+#
+# General Setup
+#
+CONFIG_TARGET_DESCRIPTION="Unspecified target"
+CONFIG_CROSS_COMPILE="arm-linux-"
+CONFIG_AEABI=y
+# CONFIG_DRIVER_LONG_LONG_SIZE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_CC_OPTIMIZE_FOR_SPEED is not set
+# CONFIG_CC_NO_OPTIMIZATION is not set
+# CONFIG_STARTUP_UART is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_SPINNER=y
+CONFIG_ATAG=y
+# CONFIG_MMU is not set
+CONFIG_DISABLE_MMU_AT_BOOT=y
+CONFIG_SDRAMBOOT_REPORT=y
+CONFIG_STACK_SIZE=0x1000
+# CONFIG_BOOTSTRAP_MEMTEST is not set
+CONFIG_ATAG_PHYS=0x30000100
+CONFIG_ARCH_NUMBER=9996
+CONFIG_APEX_VMA=0x11029000
+CONFIG_KERNEL_LMA=0x30008000
+# CONFIG_USE_RAMDISK is not set
+CONFIG_MACH="lpc313x"
+# CONFIG_MACH_VAL3153 is not set
+# CONFIG_MACH_VAL3154 is not set
+# CONFIG_MACH_EA313x_V1 is not set
+# CONFIG_MACH_EA313x_V2 is not set
+CONFIG_MACH_EA3152=y
+
+#
+# Platform Setup
+#
+CONFIG_OSC_FREQ=12000000
+CONFIG_PLL_180=y
+# CONFIG_PLL_270 is not set
+CONFIG_DYNAMIC_CLOCKS=y
+# CONFIG_USB_BOOT is not set
+CONFIG_AUTOFORMAT_BLOCK0=y
+CONFIG_MICRON_MT29F2G08=y
+# CONFIG_MICRON_MT29F4G08 is not set
+# CONFIG_SAMSUNG_K9K8G is not set
+# CONFIG_TOSHIBA_TC58DVM82A is not set
+CONFIG_DRIVER_SPINOR=y
+CONFIG_SPINOR_AT45DB=y
+CONFIG_HAS_ANALOG_DIE=y
+CONFIG_USES_SPINOR=y
+
+#
+# Commands
+#
+CONFIG_ALLHELP=y
+CONFIG_ALPHABETIZE_COMMANDS=y
+CONFIG_PARTIAL_MATCHES=y
+CONFIG_DEL_IS_BS=y
+CONFIG_ANSI_KEYS=y
+CONFIG_COMMAND_HISTORY=y
+CONFIG_COMMAND_EDITING=y
+# CONFIG_TIME_COMMANDS is not set
+CONFIG_CMD_ALIAS=y
+CONFIG_CMD_CHECKSUM=y
+CONFIG_CMD_COPY=y
+CONFIG_CMD_COMPARE=y
+CONFIG_CMD_DRVINFO=y
+CONFIG_CMD_DUMP=y
+CONFIG_CMD_ENV=y
+CONFIG_CMD_IMAGE=y
+CONFIG_CMD_IMAGE_APEX=y
+# CONFIG_CMD_IMAGE_UBOOT is not set
+CONFIG_CMD_IMAGE_SHOW=y
+CONFIG_CMD_SETENV=y
+CONFIG_CMD_ERASE=y
+CONFIG_CMD_FILL=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_INFO=y
+# CONFIG_CMD_PARSE is not set
+# CONFIG_CMD_PAUSE is not set
+# CONFIG_CMD_FLASHUSAGE is not set
+CONFIG_CMD_WAIT=y
+CONFIG_CMD_XRECEIVE=y
+CONFIG_CMD_ETH_DM9000=y
+# CONFIG_CMD_MEMLIMIT is not set
+# CONFIG_CMD_MEMSCAN is not set
+# CONFIG_CMD_MEMTEST is not set
+CONFIG_CMD_NAND=y
+# CONFIG_CRC32_LSB is not set
+
+#
+# Generic Drivers
+#
+CONFIG_DRIVER_FAT=y
+CONFIG_DRIVER_FAT_BLOCKDEVICE="mmc"
+CONFIG_DRIVER_EXT2=y
+CONFIG_DRIVER_EXT2_BLOCKDEVICE="mmc"
+# CONFIG_DRIVER_JFFS2 is not set
+# CONFIG_DRIVER_FIS is not set
+CONFIG_DRIVER_NAND=y
+# CONFIG_DRIVER_NAND_TYPE_TOSHIBA is not set
+# CONFIG_DRIVER_NAND_TYPE_ST is not set
+CONFIG_DRIVER_NAND_TYPE_MICRON=y
+CONFIG_DRIVER_NAND_ADDRESS_BYTES=4
+# CONFIG_DRIVER_ONENAND is not set
+CONFIG_DRIVER_DM9000=y
+CONFIG_USES_NAND=y
+CONFIG_USES_PATHNAME_PARSER=y
+CONFIG_USES_DM9000=y
+
+#
+# Ethernet Networking
+#
+CONFIG_ETHERNET=y
+CONFIG_CMD_IPCONFIG=y
+CONFIG_CMD_IPCONFIG_STATIC=y
+CONFIG_CMD_IPCONFIG_RARP=y
+CONFIG_CMD_IPCONFIG_BOOTP=y
+# CONFIG_CMD_IPCONFIG_DHCP is not set
+CONFIG_PROTO_ICMP_ECHO=y
+# CONFIG_CMD_PING is not set
+# CONFIG_CMD_ARP is not set
+CONFIG_CMD_TFTP=y
+CONFIG_USE_ETHERNET=y
+
+#
+# Environment
+#
+CONFIG_ENV=y
+CONFIG_ENV_MUTABLE=y
+CONFIG_ENV_REGION="lnand:512k+256k"
+CONFIG_ENV_SAVEATONCE=y
+CONFIG_ENV_SIZE=16384
+CONFIG_ENV_CHECK_LEN=1024
+# CONFIG_VARIATIONS is not set
+CONFIG_NO_BOOTSTRAP=y
+# CONFIG_NOR_BOOT is not set
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_COMPANION_EVT1_BOOT is not set
+# CONFIG_COMPANION_EVT2_BOOT is not set
+# CONFIG_ENV_STARTUP_PREFIX_P is not set
+
+#
+# Regions
+#
+CONFIG_ENV_REGION_KERNEL="tftp://$serverip/zImage"
+
+#
+# Overrides
+#
+# CONFIG_ENV_DEFAULT_CMDLINE_OVERRIDE is not set
+CONFIG_ENV_DEFAULT_STARTUP_OVERRIDE=y
+CONFIG_ENV_DEFAULT_STARTUP="eth mac 00:08:ee:00:80:44;ipconfig rarp; copy $kernelsrc $bootaddr; boot"
+CONFIG_RELOCATE_SIMPLE=y
+CONFIG_ALIASES=y
diff -purN apex-1.6.8/src/mach-lpc313x/env.c work_1.6.8/src/mach-lpc313x/env.c
--- apex-1.6.8/src/mach-lpc313x/env.c	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/env.c	2010-03-19 13:58:21.000000000 -0700
@@ -0,0 +1,94 @@
+/* env.c
+
+   written by Durgesh Pattamatta
+   10 Oct 2008
+
+   Copyright (C) 2008 NXP Semiconductors
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+
+   -----------
+   DESCRIPTION
+   -----------
+
+   Environment for the LPC313x.
+
+*/
+
+#include <config.h>
+#include <environment.h>
+#include <driver.h>
+#include <service.h>
+
+#if ! defined (CONFIG_ENV_DEFAULT_CMDLINE)
+
+__env struct env_d e_cmdline = {
+  .key = "cmdline",
+#if defined(CONFIG_MACH_VAL3153) || defined(CONFIG_MACH_EA313x_V2) || defined(CONFIG_MACH_EA3152)
+  .default_value = "console=ttyS0,115200n8 root=/dev/nfs rw nfsroot=/tftpboot/arm ip=rarp loglevel=7",
+  //.default_value = "console=ttyS0,115200n8 root=/dev/ram0 rw ip=rarp loglevel=7 ramdisk_size=12000K",
+#else
+  .default_value = "console=ttyS0,115200n8 root=/dev/ram0 rw loglevel=7 ramdisk_size=12000K",
+#endif
+  .description = "Linux kernel command line",
+};
+
+#endif
+
+#if defined (CONFIG_ENV_LINK)
+#error "For LPC313x CONFIG_ENV_LINK can't be used."
+#endif
+
+extern char APEX_ENV_START;
+extern char APEX_ENV_END;
+extern char APEX_VMA_COPY_START;
+extern char APEX_VMA_COPY_END;
+extern char APEX_IMAGE_512_SIZE;
+
+typedef struct LPC313x_BOOT_HDR 
+{
+    u32	 magic;
+  	u32  image_crc32;
+  	u32  rsrvd_img[4];
+  	u32  imageType;
+  	u32  imageLength;
+  	u32  releaseID;
+  	u32  buildTime;
+  	u32  sbzBootParameter;
+    
+    u32  apex_env_magic;
+    const char apexversion[16];
+    void* apex_env_link;		/* Align loader within flash */
+    void* apex_start;
+    void* apex_end;
+    void* apex_env_start;
+    void* apex_env_end;
+    u32 apex_env_d_size;
+    const char apex_region[16];
+  	
+  	u32  header_crc32;
+  	u32  rsrvd_hdr[4];
+} LPC313x_BOOT_HDR;
+
+static __used __section (.envlink) LPC313x_BOOT_HDR env_link = {
+  .magic	= 0x41676d69,
+  .imageType	= 10,
+  .imageLength = (u32)&APEX_IMAGE_512_SIZE,
+
+  .apex_env_magic	= ENV_LINK_MAGIC,
+  .apexversion	= APEXVERSION,
+  .apex_start	= &APEX_VMA_COPY_START, /* Immutable portion of APEX */
+  .apex_end	= &APEX_VMA_COPY_END,
+  .apex_env_start	= &APEX_ENV_START,	/* Environment variable def's */
+  .apex_env_end	= &APEX_ENV_END,
+  .apex_env_link	= &(env_link.apex_env_magic),
+  .apex_env_d_size	= sizeof (struct env_d),
+#if defined (CONFIG_ENV_REGION)
+  .apex_region	= CONFIG_ENV_REGION,
+#endif
+ };
+
diff -purN apex-1.6.8/src/mach-lpc313x/event_router.h work_1.6.8/src/mach-lpc313x/event_router.h
--- apex-1.6.8/src/mach-lpc313x/event_router.h	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/event_router.h	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,200 @@
+/* linux/arch/arm/mach-lpc313x/include/mach/event_router.h
+ *  
+ *  Author:	Durgesh Pattamatta
+ *  Copyright (C) 2009 NXP semiconductors
+ *
+ * Event router defines for LPC313x and LPC315x SoCs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+
+#ifndef __ASM_ARCH_EVT_IRQS_H
+#define __ASM_ARCH_EVT_IRQS_H
+
+
+/* event PIN or internal signal */
+typedef enum _EVT_TYPE_
+{
+  EVT_ipint_int = 0,
+  EVT_mLCD_DB_0,
+  EVT_mLCD_DB_1,
+  EVT_mLCD_DB_2,
+  EVT_mLCD_DB_3,
+  EVT_mLCD_DB_4,
+  EVT_mLCD_DB_5,
+  EVT_mLCD_DB_6,
+  EVT_mLCD_DB_7,
+  EVT_mLCD_DB_8,
+  EVT_mLCD_DB_9,
+  EVT_mLCD_DB_10,
+  EVT_mLCD_DB_11,
+  EVT_mLCD_DB_12,
+  EVT_mLCD_DB_13,
+  EVT_mLCD_DB_14,
+  EVT_mLCD_DB_15,
+  EVT_mLCD_RS,
+  EVT_mLCD_CSB,
+  EVT_mLCD_E_RD,
+  EVT_mLCD_RW_WR,
+  EVT_mNAND_RYBN0,
+  EVT_mNAND_RYBN1,
+  EVT_mNAND_RYBN2,
+  EVT_mNAND_RYBN3,
+  EVT_EBI_D_0,
+  EVT_EBI_D_1,
+  EVT_EBI_D_2,
+  EVT_EBI_D_3,
+  EVT_EBI_D_4,
+  EVT_EBI_D_5,
+  EVT_EBI_D_6,
+  EVT_EBI_D_7,
+  EVT_EBI_D_8,
+  EVT_EBI_D_9,
+  EVT_EBI_D_10,
+  EVT_EBI_D_11,
+  EVT_EBI_D_12,
+  EVT_EBI_D_13,
+  EVT_EBI_D_14,
+  EVT_EBI_D_15,
+  EVT_EBI_NWE,
+  EVT_EBI_A_0_ALE,
+  EVT_EBI_A_1_CLE,
+  EVT_EBI_DQM_0_NOE,
+  EVT_EBI_NCAS_BLOUT_0,
+  EVT_EBI_NRAS_BLOUT_1,
+  EVT_GPIO1,
+  EVT_GPIO0,
+  EVT_GPIO2,
+  EVT_GPIO3,
+  EVT_GPIO4,
+  EVT_mGPIO5,
+  EVT_mGPIO6,
+  EVT_mGPIO7,
+  EVT_mGPIO8,
+  EVT_mGPIO9,
+  EVT_mGPIO10,
+  EVT_GPIO11,
+  EVT_GPIO12,
+  EVT_GPIO13,
+  EVT_GPIO14,
+  EVT_GPIO15,
+  EVT_GPIO16,
+  EVT_GPIO17,
+  EVT_GPIO18,
+  EVT_NAND_NCS_0,
+  EVT_NAND_NCS_1,
+  EVT_NAND_NCS_2,
+  EVT_NAND_NCS_3,
+  EVT_SPI_MISO,
+  EVT_SPI_MOSI,
+  EVT_SPI_CS_IN,
+  EVT_SPI_SCK,
+  EVT_SPI_CS_OUT0,
+  EVT_UART_RXD,
+  EVT_UART_TXD,
+  EVT_mUART_CTS_N,
+  EVT_mUART_RTS_N,
+  EVT_mDAO_CLK0,
+  EVT_mDAO_BCK0,
+  EVT_mDAO_DATA0,
+  EVT_mDAO_WS0,
+  EVT_DAI_BCK0,
+  EVT_DAI_DATA0,
+  EVT_DAI_WS0,
+  EVT_DAI_DATA1,
+  EVT_DAI_BCK1,
+  EVT_DAI_WS1,
+  EVT_DAO_DATA1,
+  EVT_DAO_BCK1,
+  EVT_DAO_WS1,
+  EVT_CLK_256FS_O,
+  EVT_I2C_SDA1,
+  EVT_I2C_SCL1,
+  EVT_PWM_DATA,
+  EVT_AD_NINT_I,
+  EVT_PLAY_DET_I,
+  EVT_timer0_intct1,
+  EVT_timer1_intct1,
+  EVT_timer2_intct1,
+  EVT_timer3_intct1,
+  EVT_adc_int,
+  EVT_wdog_m0,
+  EVT_uart_rxd,
+  EVT_i2c0_scl_n,
+  EVT_i2c1_scl_n,
+  EVT_arm926_nfiq,
+  EVT_arm926_nirq,
+  EVT_MCI_DAT_0,
+  EVT_MCI_DAT_1,
+  EVT_MCI_DAT_2,
+  EVT_MCI_DAT_3,
+  EVT_MCI_DAT_4,
+  EVT_MCI_DAT_5,
+  EVT_MCI_DAT_6,
+  EVT_MCI_DAT_7,
+  EVT_MCI_CMD,
+  EVT_MCI_CLK,
+  EVT_USB_VBUS1,
+  EVT_usb_otg_ahb_needclk,
+  EVT_usb_atx_pll_lock,
+  EVT_usb_otg_vbus_pwr_en,
+  EVT_USB_ID,
+  EVT_isram0_mrc_finished,
+  EVT_isram1_mrc_finished,
+  EVT_LAST
+} EVENT_T;
+
+/* External interrupt type enumerations */
+typedef enum
+{
+  EVT_ACTIVE_LOW,
+  EVT_ACTIVE_HIGH,
+  EVT_FALLING_EDGE,
+  EVT_RISING_EDGE
+} EVENT_TYPE_T;
+
+/* Macros to compute the bank based on EVENT_T */
+#define EVT_GET_BANK(evt)   (((evt) >> 5) & 0x3)
+
+/* structure to map board IRQ to event pin */
+typedef struct {
+	u32 irq;
+	EVENT_T event_pin;
+	EVENT_TYPE_T type;
+} IRQ_EVENT_MAP_T;
+
+#define EVT_MAX_VALID_BANKS   4
+#define EVT_MAX_VALID_INT_OUT 5
+
+/* Activation polarity register defines */
+#define EVT_APR_HIGH    1
+#define EVT_APR_LOW     0
+#define EVT_APR_BANK0_DEF 0x00000001
+#define EVT_APR_BANK1_DEF 0x00000000
+#define EVT_APR_BANK2_DEF 0x00000000
+#define EVT_APR_BANK3_DEF 0x0FFFFFFC
+
+/* Activation type register defines */
+#define EVT_ATR_EDGE    1
+#define EVT_ATR_LEVEL   0
+#define EVT_ATR_BANK0_DEF 0x00000001
+#define EVT_ATR_BANK1_DEF 0x00000000
+#define EVT_ATR_BANK2_DEF 0x00000000
+#define EVT_ATR_BANK3_DEF 0x077FFFFC
+
+
+#endif
diff -purN apex-1.6.8/src/mach-lpc313x/hardware.h work_1.6.8/src/mach-lpc313x/hardware.h
--- apex-1.6.8/src/mach-lpc313x/hardware.h	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/hardware.h	2010-03-15 14:21:27.000000000 -0700
@@ -0,0 +1,48 @@
+/* hardware.h
+
+   written by Durgesh Pattamatta
+   10 Oct 2008
+
+   Copyright (C) 2008 NXP Semiconductors
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+   -----------
+   DESCRIPTION
+   -----------
+
+*/
+
+#if !defined (__HARDWARE_H__)
+#    define   __HARDWARE_H__
+
+/* ----- Includes */
+
+#include <config.h>
+
+#include "lpc313x.h"
+
+
+
+/* ----- Types */
+#define ANALOG_3V3_RAIL    0
+#define ANALOG_1V2_RAIL    1
+#define ANALOG_1V8_RAIL    2
+
+/* ----- Globals */
+
+/* ----- Prototypes */
+
+extern void nandsys_init(void);
+void setcorevoltage(unsigned long mv);
+
+extern void analog_reg_init(void);
+extern void analog_reg_read(u32 reg_addr, u32 * pReg_value);
+extern void analog_reg_write(u32 reg_addr, u32 reg_value);
+extern void psu_set_voltage(u32 rail, u32 volt);
+
+
+#endif  /* __HARDWARE_H__ */
diff -purN apex-1.6.8/src/mach-lpc313x/initialize.c work_1.6.8/src/mach-lpc313x/initialize.c
--- apex-1.6.8/src/mach-lpc313x/initialize.c	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/initialize.c	2010-03-22 10:56:36.000000000 -0700
@@ -0,0 +1,293 @@
+/* initialize.c
+
+   written by Durgesh Pattamatta
+   10 Oct 2008
+
+   Copyright (C) 2008 NXP Semiconductors
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+
+   -----------
+   DESCRIPTION
+   -----------
+
+   Hardware initializations for the EA313x boards.  Some
+   initializations may be left to drivers, such as the serial
+   interface and timer.
+
+*/
+
+#include <config.h>
+#include <asm/bootstrap.h>
+#include <service.h>
+#include <sdramboot.h>
+
+#include "hardware.h"
+
+#include <debug_ll.h>
+
+//{fin_select; ndec; mdec; pdec; selr; seli; selp; mode; freq;}
+#if (CONFIG_OSC_FREQ == 24000000)
+#define PLL_180M  {CGU_FIN_SELECT_FFAST, 514,  8191, 98, 0, 16,  8, 0, 180000000}
+#define PLL_270M  {CGU_FIN_SELECT_FFAST,   2, 19660, 98, 0, 48, 23, 0, 180000000}
+#else
+#define PLL_90M   {CGU_FIN_SELECT_FFAST, 770,  8191, 66, 0, 16,  8, 0, 90000000}
+#define PLL_180M  {CGU_FIN_SELECT_FFAST, 770,  8191, 98, 0, 16,  8, 0, 180000000}
+#define PLL_270M  {CGU_FIN_SELECT_FFAST, 514, 19660, 98, 0, 48, 23, 0, 270000000}
+#endif
+
+#if defined(CONFIG_PLL_180)
+
+#define CUR_PLL_SET     PLL_180M
+#define HCLK          (90 * 1000000ull)
+#define PLLCLK        (180 * 1000000ull)
+
+extern const CGU_CLKS_INIT_T g_cgu_default_clks_2;
+#define DEFAULT_CFG   &g_cgu_default_clks_2
+
+#elif defined(CONFIG_PLL_270)
+
+#if defined(CONFIG_HAS_ANALOG_DIE)
+#warning "####!!!@@##@@!!! LPC3152 can't run at this speed. ####!!!@@##@@!!!\n" 
+#endif
+
+#define CUR_PLL_SET     PLL_270M
+#define HCLK          (90 * 1000000ull)
+#define PLLCLK        (270 * 1000000ull)
+
+extern const CGU_CLKS_INIT_T g_cgu_default_clks_3;
+#define DEFAULT_CFG   &g_cgu_default_clks_3
+
+#endif
+
+
+#define SDRAM_CHIP_MODE   _SBF(13, 0x23)
+
+const CGU_HPLL_SETUP_T const g_pll = CUR_PLL_SET;
+
+void __naked __section (.bootstrap.early) bootstrap_early (void)
+{
+	/* Initialize startup stack pointer at end of ISRAM0*/
+  __asm volatile ("mov sp, %0" :: "r" (ISRAM1_PHYS));
+
+  /* Map first 4KB of ARM space to ISRAM area. ie 0x0 - 0x1000 = 0x11028000 - 0x11029000 */
+  SYS_REMAP_ADDR = ISRAM0_PHYS;
+
+  __asm volatile ("b bootstrap_early_exit");
+}
+
+void __naked __section (.bootstrap.early.exit) bootstrap_early_exit (void)
+{
+}
+
+/* usleep
+
+   this function accepts a count of microseconds and will wait at
+   least that long before returning.  The timer clock must be
+   activated by the initialization code before using usleep.
+
+   When in C, this function was one instruction longer than the
+   hand-coded assembler.  For some reason, the compiler would reload
+   the TIMER1_PHYS at the top of the while loop.
+
+   Note that this function is neither __naked nor static.  It is
+   available to the rest of the application as is.
+
+   Keep in mind that it has a limit of about 357913.94125ms.  
+
+   This routine assumes 12MHz clock is used as source clock for timer
+   block. Which means 12 ticks for every usec.
+
+ */
+
+void __section (.bootstrap) usleep (unsigned long us)
+{
+  unsigned long end, current;
+  end = (us << 2) + (us << 3);
+  __REG (TIMER1_PHYS + TIMER_CONTROL) = TM_CTRL_ENABLE;
+  __REG (TIMER1_PHYS + TIMER_LOAD) = end;
+  
+  do {
+    current = __REG (TIMER1_PHYS + TIMER_VALUE);
+  } while( current <= end);
+ 
+}
+
+
+/* initialize_bootstrap
+
+   performs vital SDRAM initialization as well as some other memory
+   controller initializations.  It will perform no work if we are
+   already running from SDRAM.
+
+   The assembly output of this implementation of the initialization is
+   more dense than the assembler version using a table of
+   initializations.  This is primarily due to the compiler's ability
+   to keep track of the register set offsets and value being output.
+
+   The return value is true if SDRAM has been initialized and false if
+   this initialization has already been performed.  Note that the
+   non-SDRAM initializations are performed regardless of whether or
+   not we're running in SDRAM.
+
+
+*/
+
+void __naked __section (.bootstrap) initialize_bootstrap (void)
+{
+  unsigned long lr;
+  __asm volatile ("mov %0, lr" : "=r" (lr));
+
+  /* init CGU block*/
+  cgu_init();
+  /* reset all clocks to XTAL clock */
+  cgu_reset_all_clks();
+
+  /* set all clocks based on the default structure */
+  cgu_init_clks(DEFAULT_CFG);
+#if defined(CONFIG_HAS_ANALOG_DIE)
+  /* before bumping up the frquency adjust core & IO voltages*/
+  analog_reg_init();
+  psu_set_voltage(ANALOG_1V2_RAIL, DCDC2_1_40);
+  /* Set SDRAM voltage rail to 1.8V default is 1.4V */
+  psu_set_voltage(ANALOG_1V8_RAIL, PSU_VOUT3_1_80);
+  //psu_set_voltage(ANALOG_3V3_RAIL, DCDC1_3_20);
+#endif
+  /* set HPLL1 - main PLL to default speed */
+  cgu_hpll_config (CGU_HPLL1_ID, &g_pll);
+
+
+  /* configure the LCD pins in EBI memory mode. */
+  SYS_MUX_LCD_EBI = 1;
+  
+  cgu_clk_en_dis( CGU_SB_TIMER1_PCLK_ID, 1);
+  /* enable EBI clock */
+  cgu_clk_en_dis( CGU_SB_EBI_CLK_ID, 1);
+  
+  /* enable MPMC controller clocks */
+  cgu_clk_en_dis( CGU_SB_MPMC_CFG_CLK_ID, 1);
+  cgu_clk_en_dis( CGU_SB_MPMC_CFG_CLK2_ID, 1);
+  cgu_clk_en_dis( CGU_SB_MPMC_CFG_CLK3_ID, 1);
+
+  /* enable External Memory controller */
+  MPMC_CTRL = MPMC_CTL_ENABLE;
+  /* Force HCLK to MPMC_CLK to 1:1 ratio */
+  MPMC_CONFIG = MPMC_CFG_SDCCLK_1_1;
+  /* set MPMC delay gates appropriately based on trace lengths between
+  SDRAM and the chip. Also based on the delay startergy used for SDRAM. */
+  SYS_MPMC_DELAY = 0x826;
+  
+  /* check the jumpers are set for EBI mode or not before proceeding 
+  further.*/
+#if defined(CONFIG_MACH_VAL3153)
+  /* NOR flash, 16 bit */
+  MPMC_STCONFIG0  = 0x81;
+  MPMC_STWTWEN0   = 1;
+  MPMC_STWTOEN0   = 1;
+  MPMC_STWTRD0    = 6;
+  MPMC_STWTPG0    = 2;
+  MPMC_STWTWR0    = 6;
+  MPMC_STWTTURN0  = 1;
+  /* ethernet, 16 bit */
+  MPMC_STCONFIG1  = 0x81;
+  MPMC_STWTWEN1   = 4;
+  MPMC_STWTOEN1   = 4;
+  MPMC_STWTRD1    = 18;
+  MPMC_STWTPG1    = 0xFF;
+  MPMC_STWTWR1    = 16;
+  MPMC_STWTTURN1  = 6;
+  /* enable oe toggle between consecutive reads */
+  SYS_MPMC_WTD_DEL0 = _BIT(5) | 6;
+  SYS_MPMC_WTD_DEL1 = _BIT(5) | 18;
+#elif defined(CONFIG_MACH_EA313x_V1) || defined(CONFIG_MACH_EA313x_V2) || defined(CONFIG_MACH_EA3152)
+  /* LCD display, 16 bit */
+  MPMC_STCONFIG0  = 0x81;
+  MPMC_STWTWEN0   = 2;
+  MPMC_STWTOEN0   = 1;
+  MPMC_STWTRD0    = 15;
+  MPMC_STWTPG0    = 2;
+  MPMC_STWTWR0    = 4;
+  MPMC_STWTTURN0  = 2;
+  /* ethernet DM9000, 16 bit */
+  MPMC_STCONFIG1  = 0x81;
+  MPMC_STWTWEN1   = 1;
+  MPMC_STWTOEN1   = 1;
+  MPMC_STWTRD1    = 4;
+  MPMC_STWTPG1    = 1;
+  MPMC_STWTWR1    = 1;
+  MPMC_STWTTURN1  = 2;
+  /* enable oe toggle between consecutive reads */
+  SYS_MPMC_WTD_DEL0 = _BIT(5) | 15;
+  SYS_MPMC_WTD_DEL1 = _BIT(5) | 4;
+#endif
+  
+  /* SDRAM */
+  MPMC_DYRDCFG    = MPMC_SDRAMC_RDCFG_CMDDELAY_STG;
+  MPMC_DYCONFIG   = SDRAMC_16HP_32Mx16_4B_R13_C10;
+  MPMC_DYRASCAS   = MPMC_SDRAMC_RASCAS_RAS2 | MPMC_SDRAMC_RASCAS_CAS2;
+  /* min 20ns program 1 so that atleast 2 HCLKs are used */
+  MPMC_DYTRP    = NS_TO_MPMCCLK(20, HCLK);
+  MPMC_DYTRAS   = NS_TO_MPMCCLK(44, HCLK);
+  MPMC_DYTSREX  = NS_TO_MPMCCLK(75, HCLK);
+  MPMC_DYTAPR   = 4;
+  MPMC_DYTDAL   = NS_TO_MPMCCLK(50, HCLK);
+  MPMC_DYTWR    = NS_TO_MPMCCLK(75, HCLK);
+  MPMC_DYTRC    = NS_TO_MPMCCLK(66, HCLK);
+  MPMC_DYTRFC   = NS_TO_MPMCCLK(66, HCLK);
+  MPMC_DYTXSR   = NS_TO_MPMCCLK(75, HCLK);
+  MPMC_DYTRRD   = NS_TO_MPMCCLK(15, HCLK);
+  MPMC_DYTMRD   = NS_TO_MPMCCLK(20, HCLK);
+
+  usleep (100);
+  /* issue continuous NOP commands  */
+  MPMC_DYNCTL    = MPMC_SDRAMC_CTL_CE | MPMC_SDRAMC_CTL_CS | MPMC_SDRAMC_CTL_NOP_CMD;
+  usleep (200);
+  /* issue a "pre-charge all" command */
+  MPMC_DYNCTL    = MPMC_SDRAMC_CTL_CE | MPMC_SDRAMC_CTL_CS | MPMC_SDRAMC_CTL_PALL_CMD;
+  MPMC_DYNREF     = NS_TO_MPMCCLK(100, HCLK)/16 + 1;
+  usleep (250);
+  MPMC_DYNREF     = NS_TO_MPMCCLK(7812, HCLK)/16;
+  /* select mode register update mode */
+  MPMC_DYNCTL    = MPMC_SDRAMC_CTL_CE | MPMC_SDRAMC_CTL_CS | MPMC_SDRAMC_CTL_MODE_CMD;
+
+  /* set mode register by reading the address */
+  __REG (EXT_SDRAM_PHYS + SDRAM_CHIP_MODE);
+  MPMC_DYCONFIG  = SDRAMC_16HP_32Mx16_4B_R13_C10;
+  /* select normal operating mode */
+  MPMC_DYNCTL    = MPMC_SDRAMC_CTL_CE | MPMC_SDRAMC_CTL_CS | MPMC_SDRAMC_CTL_NORMAL_CMD;
+
+  /* enable buffers */
+  MPMC_DYCONFIG |= MPMC_SDRAMC_CFG_BUF_EN;
+  MPMC_DYNCTL = MPMC_SDRAMC_CTL_NORMAL_CMD | MPMC_SDRAMC_CTL_CS;
+
+#if defined(CONFIG_DYNAMIC_CLOCKS)
+  /* program dynamic referesh clock for external refresh generator also.
+  Used during dynamic clock scaling done by CGU. */
+  SYS_MPMC_TESTMODE0 = (NS_TO_MPMCCLK(7812, PLLCLK)/16) | _BIT(12);
+  /*testMode1 = (10+ Trp/(1/MPMC_CLK) + Trfc/(1/MPMC_CLK)) * baseclock/ MPMC_clk */
+  SYS_MPMC_TESTMODE1 = (10 + NS_TO_MPMCCLK(20, HCLK) + NS_TO_MPMCCLK(66, HCLK)) * (PLLCLK/HCLK);
+#endif
+
+  __asm volatile ("mov r0, #-1\t\n"
+		  "mov pc, %0" : : "r" (lr));
+}
+
+
+/* target_init
+
+   performs the rest of the hardware initialization that didn't have
+   to be performed during the bootstrap phase.
+
+*/
+
+static void target_init (void)
+{
+}
+
+static __service_0 struct service_d lpc313x_target_service = {
+  .init    = target_init,
+};
diff -purN apex-1.6.8/src/mach-lpc313x/Kconfig work_1.6.8/src/mach-lpc313x/Kconfig
--- apex-1.6.8/src/mach-lpc313x/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/Kconfig	2010-03-25 13:39:30.000000000 -0700
@@ -0,0 +1,205 @@
+if ARCH_LPC313X
+
+choice
+	prompt "LPC313X Implementations"
+	default MACH_EA313x_V1
+
+config MACH_VAL3153
+	bool "NXP validation board VAL3131"
+	select USES_CS8900
+	select USES_NAND
+	select USES_SPINOR
+
+config MACH_VAL3154
+	bool "NXP validation board VAL3154"
+	select HAS_ANALOG_DIE
+	select USES_NAND
+
+config MACH_EA313x_V1
+	bool "EA313x 1.0 board w/o ethernet"
+	select USES_NAND
+	select USES_SPINOR
+
+config MACH_EA313x_V2
+	bool "EA313x 2.0 board w/ ethernet"
+	select USES_DM9000
+	select USES_NAND
+	select USES_SPINOR
+	
+config MACH_EA3152
+	bool "EA3152 board w/ ethernet"
+	select HAS_ANALOG_DIE
+	select USES_DM9000
+	select USES_NAND
+	select USES_SPINOR
+
+endchoice
+
+
+menu "Platform Setup"
+
+config OSC_FREQ
+	int "Crystal frequency"
+	default 12000000 
+	depends on ARCH_LPC313X
+	help
+	  Change this if using crystal other than 12MHz. 
+choice
+	prompt "PLL frequency"
+	default PLL_180
+
+config PLL_180
+	bool "Set PLL/ARM frequency at 180MHz and AHB=90MHz"
+
+config PLL_270
+	bool "Set PLL/ARM frequency at 270MHz and AHB=90MHz."
+	help
+	  This frequency is garunteed only for LPC314x series with core
+	  voltage set to 1.3v. 
+
+endchoice
+
+config DYNAMIC_CLOCKS
+	bool "Enable automatic clock scaling"
+	help
+	  Enables automatic clock scaling feature present in CGU. Whenever
+	  AHB bus system is inactive CGU automaticly switches the FDC0 to FDC7
+	  to DynFDC0 to DyncFDC7.   
+	  
+config USB_BOOT
+	bool "Enable LPC313x USB boot method"
+	help
+	  Make sure you have copied usbmsc.d file under 
+	  src\mach-lpc313x\usb directory.   
+	  
+config ATAG_PHYS
+	hex "Physical address for ATAGs list"
+	default "0x30000100"
+	depends on ATAG
+	help
+	  This is the address where APEX will construct the ATAG list
+	  before starting the Linux kernel.  This address should be
+	  within the first 16KiB of physical RAM.  Don't change this
+	  value unless you know what you are doing. 
+
+config ARCH_NUMBER
+	int
+	default 9999 if (MACH_VAL3153)
+	default 9998 if (MACH_EA313x_V1 || MACH_EA313x_V2)
+	default 9997 if (MACH_VAL3154)
+	default 9996 if (MACH_EA3152)
+
+config APEX_VMA
+	hex "APEX Runtime Address"
+	default "0x11029000"
+
+config KERNEL_LMA
+	hex "Kernel Load Address"
+	default "0x30008000"
+
+config USE_RAMDISK
+	bool "Enable ramdisk options"
+	default n
+	help
+	  This option doesn't enable the ramdisk, per se.  It enables
+	  other configuration options that help setup a default
+	  ramdisk.  The kernel command line and the APEX startup
+	  commands may be overridden to perform the same steps.
+
+	  There is a separate option in the Environment section that
+	  controls whether or not APEX copies the ramdisk from flash
+	  into RAM at startup.  That is where the ramdisk region is
+	  defined.
+
+config RAMDISK_LMA
+	hex "Ramdisk load address"
+	default "0x32000000"
+	depends on USE_RAMDISK
+	help
+	  This option sets the physical load address for an initial
+	  ramdisk (a.k.a initrd).
+
+config RAMDISK_SIZE
+	hex "Ramdisk compressed size"
+	default "0x00300000"
+	depends on USE_RAMDISK
+	help
+	  This option sets the size, in bytes, of the initial ramdisk
+	  (a.k.a. initrd).  This is the size of the compressed initrd
+	  image.
+
+config AUTOFORMAT_BLOCK0
+	bool "Autoformat NAND block 0"
+	default y
+	depends on DRIVER_NAND
+	help
+	  The LPC31xx devices use block 0 of FLASH to store device bad
+	  block and NAND boot information. If this option is enabled,
+	  this information will be built automatically if it doesn't
+	  exist. (A image of all the factory bad blocks are stored in
+	  here.) It is highly recommended that this option always be
+	  enabled. If it is not enabled, the device should be formatted
+	  manually with the lpcnand format command. If this is not
+	  done, the device will lose it's factory bad block information
+	  as soon as writes start occuring to the device. See the
+	  additional information about NAND FLASH included with the BSP
+	  for more information.
+
+choice
+	prompt "LPC NAND device"
+	depends on DRIVER_NAND
+	default MICRON_MT29F2G08
+
+config MICRON_MT29F2G08
+	bool "MICRON NAND MT29F2G08 device."
+
+config MICRON_MT29F4G08
+	bool "MICRON NAND MT29F4G08 device."
+
+config SAMSUNG_K9K8G
+	bool "SAMSUNG NAND K9K8G device."
+
+config TOSHIBA_TC58DVM82A
+	bool "TOSHIBA C58DVM82A device (small block)."
+
+endchoice
+
+config DRIVER_SPINOR
+	bool "SPI NOR Flash"
+	depends on USES_SPINOR=y
+	default y
+	help
+	  This driver implements a SPI-NOR flash driver
+	  which works with most contemporary SPI-NOR flash chips. 
+
+choice
+	prompt "SPI NOR device"
+	depends on DRIVER_SPINOR
+	default SPINOR_AT45DB
+
+config SPINOR_AT45DB
+	bool "Atmel SPINOR AT45DB device."
+
+endchoice
+
+endmenu
+
+config MACH
+	string
+	default "lpc313x"
+
+config ARCH_LPC313X
+	bool
+	select CPU_ARMV5
+	select CPU_ARM9
+	select CPU_ARM926T
+
+
+config HAS_ANALOG_DIE
+	bool
+
+config USES_SPINOR
+	bool
+
+endif
+
diff -purN apex-1.6.8/src/mach-lpc313x/lpc313x_cgu_default.c work_1.6.8/src/mach-lpc313x/lpc313x_cgu_default.c
--- apex-1.6.8/src/mach-lpc313x/lpc313x_cgu_default.c	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/lpc313x_cgu_default.c	2010-03-11 16:31:33.000000000 -0800
@@ -0,0 +1,494 @@
+/*
+   written by Durgesh Pattamatta
+   10 Oct 2008
+
+   Copyright (C) 2008 NXP Semiconductors
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+ */
+
+#include <apex.h>
+#include "lpc313x.h"
+
+
+
+/*Below are the default configurations
+ * FFAST : 12MHz
+ * MASTER PLL Freq: 180MHz;
+ * AUDIOPLL Freq:   1024Fs, Fs = 44.1kHz
+ *
+ * Domain                                 Input           Subdomain     Divider Ratio
+ * 0 - CLK_SWITCHBOX_SYS_BASE0            MASTER PLL      DIV0          1/2
+ *                                                        DIV1          1
+ *                                                        DIV2          1/2
+ *                                                        DIV3          1/4
+ *                                                        DIV4          1/4
+ *                                                        DIV5          1/4
+ *                                                        DIV6          1/2
+ *
+ * 1 - CLK_SWITCHBOX_AHB0_APB0_BASE1      FFAST           DIV7          1/2
+ *                                                        DIV8          1/2
+ *
+ * 2 - CLK_SWITCHBOX_AHB0_APB1_BASE2      FFAST           DIV9          1/2
+ *                                                        DIV10         1/2
+ *
+ * 3 - CLK_SWITCHBOX_AHB0_APB2_BASE3      MASTER PLL      DIV11         1/2
+ *                                                        DIV12         1/4
+ *                                                        DIV13         not used
+ *
+ * 4 - CLK_SWITCHBOX_AHB0_APB2_BASE3      MASTER PLL      DIV14         1/2
+ *
+ * 5 - CLK_SWITCHBOX_IPINT0_BASE5         MASTER PLL      DIV15         1/2
+ *
+ * 6 - CLK_SWITCHBOX_UARTCLK_BASE6        MASTER PLL      DIV16         0
+ *
+ * 7 - CLK_SWITCHBOX_CLK1024FS_BASE7      AUDIO PLL       DIV17         1/1024
+ *                                                        DIV18         1/16
+ *                                                        DIV19         1/4
+ *                                                        DIV20         1/16
+ *                                                        DIV21         1/128
+ *                                                        DIV22         1/8
+ *
+ * 8 - CLK_SWITCHBOX_DAI_BCK0_BASE8        DAI_BCK0          -                -
+ *
+ * 9 - CLK_SWITCHBOX_DAI_BCK1_BASE9        DAI_BCK1          -                -
+ *
+ * 10 - CLK_SWITCHBOX_SPI_BASE10           MASTER PLL       DIV23        1/2
+ *
+ * 11 - CLK_SWITCHBOX_SYSCLK0_BASE11       FFAST              -                 -
+ *
+ * End of configuration table*/
+
+/*------------------------------------------------------------------------------------------
+  Group the clocks 0 - 29 belonging to SYS_BASE domain into 7 different sub-domains using
+  following macro. Clocks not defined in the macros will be sourced with SYS_BASE_CLK.
+ ------------------------------------------------------------------------------------------*/
+/* define clocks belonging to subdomain DOMAIN0_DIV0 */
+#define CGU_DEF_DOMAIN0_DIV0	( D0_BIT(CGU_SB_APB0_CLK_ID) | D0_BIT(CGU_SB_APB1_CLK_ID) | \
+                               D0_BIT(CGU_SB_APB2_CLK_ID) | D0_BIT(CGU_SB_APB3_CLK_ID) | \
+                               D0_BIT(CGU_SB_APB4_CLK_ID) | D0_BIT(CGU_SB_AHB2INTC_CLK_ID) | \
+                               D0_BIT(CGU_SB_AHB0_CLK_ID) | D0_BIT(CGU_SB_DMA_PCLK_ID) | \
+                               D0_BIT(CGU_SB_DMA_CLK_GATED_ID) | D0_BIT(CGU_SB_NANDFLASH_S0_CLK_ID) | \
+                               D0_BIT(CGU_SB_NANDFLASH_PCLK_ID) | D0_BIT(CGU_SB_ARM926_BUSIF_CLK_ID) | \
+                               D0_BIT(CGU_SB_SD_MMC_HCLK_ID) | D0_BIT(CGU_SB_USB_OTG_AHB_CLK_ID) | \
+                               D0_BIT(CGU_SB_ISRAM0_CLK_ID) | D0_BIT(CGU_SB_ISRAM1_CLK_ID) | \
+                               D0_BIT(CGU_SB_ISROM_CLK_ID) | D0_BIT(CGU_SB_MPMC_CFG_CLK_ID) | \
+                               D0_BIT(CGU_SB_MPMC_CFG_CLK2_ID) | D0_BIT(CGU_SB_INTC_CLK_ID) )
+
+/* define clocks belonging to subdomain DOMAIN0_DIV1 */
+#define CGU_DEF_DOMAIN0_DIV1	(D0_BIT(CGU_SB_ARM926_CORE_CLK_ID))
+
+/* define clocks belonging to subdomain DOMAIN0_DIV2 */
+#define CGU_DEF_DOMAIN0_DIV2	( D0_BIT(CGU_SB_NANDFLASH_AES_CLK_ID) | \
+                               D0_BIT(CGU_SB_NANDFLASH_NAND_CLK_ID))
+
+/* define clocks belonging to subdomain DOMAIN0_DIV3 */
+#define CGU_DEF_DOMAIN0_DIV3	(D0_BIT(CGU_SB_NANDFLASH_ECC_CLK_ID))
+
+/* define clocks belonging to subdomain DOMAIN0_DIV4 */
+#define CGU_DEF_DOMAIN0_DIV4	(D0_BIT(CGU_SB_SD_MMC_CCLK_IN_ID))
+/* define clocks belonging to subdomain DOMAIN0_DIV5 */
+#define CGU_DEF_DOMAIN0_DIV5	(D0_BIT(CGU_SB_CLOCK_OUT_ID))
+/* define clocks belonging to subdomain DOMAIN0_DIV6 */
+#define CGU_DEF_DOMAIN0_DIV6	(D0_BIT(CGU_SB_EBI_CLK_ID))
+
+/*------------------------------------------------------------------------------------------
+  Group the clocks 30 - 39 belonging to AHB_APB0_BASE domain into 2 different sub-domains using
+  following macro. Clocks not defined in the macros will be sourced with AHB_APB0_BASE_CLK.
+ ------------------------------------------------------------------------------------------*/
+/* define clocks belonging to subdomain DOMAIN1_DIV7 */
+#define CGU_DEF_DOMAIN1_DIV7	(D1_BIT(CGU_SB_ADC_CLK_ID))
+/* define clocks belonging to subdomain DOMAIN1_DIV8 */
+#define CGU_DEF_DOMAIN1_DIV8	( D1_BIT(CGU_SB_AHB2APB0_ASYNC_PCLK_ID) | \
+                               D1_BIT(CGU_SB_EVENT_ROUTER_PCLK_ID) | D1_BIT(CGU_SB_ADC_PCLK_ID) | \
+                               D1_BIT(CGU_SB_WDOG_PCLK_ID) | D1_BIT(CGU_SB_IOCONF_PCLK_ID) | \
+                               D1_BIT(CGU_SB_CGU_PCLK_ID) | D1_BIT(CGU_SB_SYSCREG_PCLK_ID) | \
+                               D1_BIT(CGU_SB_OTP_PCLK_ID) | D1_BIT(CGU_SB_RNG_PCLK_ID) )
+
+/*------------------------------------------------------------------------------------------
+  Group the clocks 40 - 49 belonging to AHB_APB1_BASE domain into 2 different sub-domains using
+  following macro. Clocks not defined in the macros will be sourced with AHB_APB1_BASE_CLK.
+ ------------------------------------------------------------------------------------------*/
+/* define clocks belonging to subdomain DOMAIN2_DIV9 */
+#define CGU_DEF_DOMAIN2_DIV9	( D2_BIT(CGU_SB_AHB2APB1_ASYNC_PCLK_ID) | \
+                               D2_BIT(CGU_SB_TIMER0_PCLK_ID) | D2_BIT(CGU_SB_TIMER1_PCLK_ID) | \
+                               D2_BIT(CGU_SB_TIMER2_PCLK_ID) | D2_BIT(CGU_SB_TIMER3_PCLK_ID) | \
+                               D2_BIT(CGU_SB_PWM_PCLK_ID) | D2_BIT(CGU_SB_PWM_PCLK_REGS_ID) | \
+                               D2_BIT(CGU_SB_I2C0_PCLK_ID) | D2_BIT(CGU_SB_I2C1_PCLK_ID) )
+
+/* define clocks belonging to subdomain DOMAIN2_DIV10 */
+#define CGU_DEF_DOMAIN2_DIV10	(D2_BIT(CGU_SB_PWM_CLK_ID))
+
+/*------------------------------------------------------------------------------------------
+  Group the clocks 50 - 57 belonging to AHB_APB2_BASE domain into 3 different sub-domains using
+  following macro. Clocks not defined in the macros will be sourced with AHB_APB2_BASE_CLK.
+ ------------------------------------------------------------------------------------------*/
+/* define clocks belonging to subdomain DOMAIN3_DIV11 */
+#define CGU_DEF_DOMAIN3_DIV11	( D3_BIT(CGU_SB_AHB2APB2_ASYNC_PCLK_ID) | \
+                                D3_BIT(CGU_SB_PCM_PCLK_ID) | D3_BIT(CGU_SB_PCM_APB_PCLK_ID) | \
+                                D3_BIT(CGU_SB_UART_APB_CLK_ID) | D3_BIT(CGU_SB_LCD_PCLK_ID) | \
+                                D3_BIT(CGU_SB_SPI_PCLK_ID) | D3_BIT(CGU_SB_SPI_PCLK_GATED_ID) )
+
+/* define clocks belonging to subdomain DOMAIN3_DIV12 */
+#define CGU_DEF_DOMAIN3_DIV12	(D3_BIT(CGU_SB_LCD_CLK_ID))
+/* Currently no clocks are connected to this subdomain */
+#define CGU_DEF_DOMAIN3_DIV13	(0)
+
+/*------------------------------------------------------------------------------------------
+  Group the clocks 58 - 70 belonging to AHB_APB3_BASE domain into a sub-domains using
+  following macro. Clocks not defined in the macros will be sourced wih AHB_APB3_BASE_CLK.
+ ------------------------------------------------------------------------------------------*/
+#define CGU_DEF_DOMAIN4_DIV14	( D4_BIT(CGU_SB_AHB2APB3_ASYNC_PCLK_ID) | \
+                                D4_BIT(CGU_SB_I2S_CFG_PCLK_ID) | D4_BIT(CGU_SB_EDGE_DET_PCLK_ID) | \
+                                D4_BIT(CGU_SB_I2STX_FIFO_0_PCLK_ID) | D4_BIT(CGU_SB_I2STX_IF_0_PCLK_ID) | \
+                                D4_BIT(CGU_SB_I2STX_FIFO_1_PCLK_ID) | D4_BIT(CGU_SB_I2STX_IF_1_PCLK_ID) | \
+                                D4_BIT(CGU_SB_I2SRX_FIFO_0_PCLK_ID) | D4_BIT(CGU_SB_I2SRX_IF_0_PCLK_ID) | \
+                                D4_BIT(CGU_SB_I2SRX_FIFO_1_PCLK_ID) | D4_BIT(CGU_SB_I2SRX_IF_1_PCLK_ID) )
+
+/*------------------------------------------------------------------------------------------
+  Define whether CGU_SB_PCM_CLK_IP_ID clock uses the FDC_15 fractional divider or not. If
+  the following macro is set 0 then CGU_SB_PCM_CLK_IP_ID clock is sourced with PCM_BASE_CLK.
+ ------------------------------------------------------------------------------------------*/
+#define CGU_DEF_DOMAIN5_DIV15	(D5_BIT(CGU_SB_PCM_CLK_IP_ID))
+
+/*------------------------------------------------------------------------------------------
+  Define whether CGU_SB_UART_U_CLK_ID clock uses the FDC_16 fractional divider or not. If
+  the following macro is set 0 then CGU_SB_UART_U_CLK_ID clock is sourced with UART_BASE_CLK.
+ ------------------------------------------------------------------------------------------*/
+#define CGU_DEF_DOMAIN6_DIV16	(0)
+
+/*------------------------------------------------------------------------------------------
+  Group the clocks 73 - 86 belonging to CLK1024FS_BASE domain into 6 different sub-domains using
+  following macro. Clocks not defined in the macros will be sourced with CLK1024FS_BASE_CLK.
+ ------------------------------------------------------------------------------------------*/
+/* define clocks belonging to subdomain DOMAIN7_DIV17. This divider has 13 bit resolution
+   for madd & msub values compared to other dividers which have 8 bit only.*/
+#define CGU_DEF_DOMAIN7_DIV17	( D7_BIT(CGU_SB_I2S_EDGE_DETECT_CLK_ID) | \
+                                D7_BIT(CGU_SB_I2STX_WS0_ID) | D7_BIT(CGU_SB_I2STX_WS1_ID) | \
+                                D7_BIT(CGU_SB_I2SRX_WS0_ID) | D7_BIT(CGU_SB_I2SRX_WS1_ID) )
+
+/* define clocks belonging to subdomain DOMAIN7_DIV18 */
+#define CGU_DEF_DOMAIN7_DIV18	( D7_BIT(CGU_SB_I2STX_BCK0_N_ID) | \
+                                D7_BIT(CGU_SB_I2STX_BCK1_N_ID) )
+
+/* define clocks belonging to subdomain DOMAIN7_DIV19 */
+#define CGU_DEF_DOMAIN7_DIV19	( D7_BIT(CGU_SB_I2STX_CLK0_ID) | \
+                                D7_BIT(CGU_SB_CLK_256FS_ID) )
+
+/* define clocks belonging to subdomain DOMAIN7_DIV20 */
+#define CGU_DEF_DOMAIN7_DIV20	( D7_BIT(CGU_SB_I2SRX_BCK0_N_ID) | \
+                                D7_BIT(CGU_SB_I2SRX_BCK1_N_ID) )
+
+/* define clocks belonging to subdomain DOMAIN7_DIV21 */
+#define CGU_DEF_DOMAIN7_DIV21	(0)
+/* define clocks belonging to subdomain DOMAIN7_DIV22 */
+#define CGU_DEF_DOMAIN7_DIV22	(0)
+
+/* I2SRX_BCK0_BASE and I2SRX_BCK1_BASE domains are directly connected. So, no entry exists here */
+
+/*------------------------------------------------------------------------------------------
+  Group the clocks 89 - 90 belonging to SPI_CLK_BASE domain into a sub-domain using
+  following macro. Clocks not defined in the macros will be sourced wih SPI_CLK_BASE_CLK.
+ ------------------------------------------------------------------------------------------*/
+#define CGU_DEF_DOMAIN10_DIV23	( D10_BIT(CGU_SB_SPI_CLK_ID) | \
+                                 D10_BIT(CGU_SB_SPI_CLK_GATED_ID) )
+
+/* SYSCLK_O_BASE is directly connected. So, no entry exists here */
+
+/*------------------------------------------------------------------------------------------
+  Global variables:
+ ------------------------------------------------------------------------------------------*/
+#if defined(CONFIG_PLL_270)
+
+const CGU_CLKS_INIT_T const g_cgu_default_clks_3 =
+{
+  /* domain0 [7] - SYS_BASE Domain*/
+  {
+    CGU_FIN_SELECT_HPPLL1,
+    {
+      {{1, 1, 3}, CGU_DEF_DOMAIN0_DIV0},  /*FracDiv0 */
+      {{0, 0, 0}, CGU_DEF_DOMAIN0_DIV1},  /*FracDiv1 */
+      {{1, 1, 3}, CGU_DEF_DOMAIN0_DIV2},  /*FracDiv2 */
+      {{1, 1, 6}, CGU_DEF_DOMAIN0_DIV3},  /*FracDiv3 */
+      {{1, 1, 6}, CGU_DEF_DOMAIN0_DIV4},  /*FracDiv4 */
+      {{1, 1, 3}, CGU_DEF_DOMAIN0_DIV5}, /*FracDiv5*/
+      {{1, 1, 3}, CGU_DEF_DOMAIN0_DIV6}   /*FracDiv6 */
+    }
+  },
+  /* domain1 [2] - AHB0_APB0 ClockDomain*/
+  {
+    CGU_FIN_SELECT_FFAST,
+    {
+      {{1, 1, 38}, CGU_DEF_DOMAIN1_DIV7}, /*FracDiv7 */
+      {{1, 1, 2}, CGU_DEF_DOMAIN1_DIV8}   /*FracDiv8 */
+    }
+  },
+  /* domain2 [2] - AHB0_APB1 ClockDomain*/
+  {
+    CGU_FIN_SELECT_FFAST,
+    {
+      {{1, 1, 2}, CGU_DEF_DOMAIN2_DIV9}, /*FracDiv9  */
+      {{1, 1, 2}, CGU_DEF_DOMAIN2_DIV10} /*FracDiv10 */
+    }
+  },
+  /* domain3 [3] - AHB0_APB2 ClockDomain*/
+  {
+    CGU_FIN_SELECT_HPPLL1,
+    {
+      {{1, 1, 3}, CGU_DEF_DOMAIN3_DIV11}, /*FracDiv11 */
+      {{1, 1, 40}, CGU_DEF_DOMAIN3_DIV12},/*FracDiv12 */
+      {{0, 0, 0}, CGU_DEF_DOMAIN3_DIV13}  /*FracDiv13 */
+    }
+  },
+  /* domain4 [1] - AHB0_APB3 ClockDomain*/
+  {
+    CGU_FIN_SELECT_FFAST,
+    {
+      {{1, 1, 2}, CGU_DEF_DOMAIN4_DIV14} /*FracDiv14 */
+    }
+  },
+  /* domain5 [1] - PCM ClockDomain*/
+  {
+    CGU_FIN_SELECT_HPPLL1,
+    {
+      {{1, 1, 3}, CGU_DEF_DOMAIN5_DIV15} /*FracDiv15 */
+    }
+  },
+  /* domain6 [1] - UART ClockDomain*/
+  {
+    CGU_FIN_SELECT_FFAST,
+    {
+      {{0, 0, 0}, CGU_DEF_DOMAIN6_DIV16} /*FracDiv16 */
+    }
+  },
+  /* domain7 [6] - CLK1024FS ClockDomain*/
+  {
+    CGU_FIN_SELECT_HPPLL0,
+    {
+      {{1, 1, 256}, CGU_DEF_DOMAIN7_DIV17},/*FracDiv17 */
+      {{1, 1, 4}, CGU_DEF_DOMAIN7_DIV18},  /*FracDiv18 */
+      {{1, 1, 2}, CGU_DEF_DOMAIN7_DIV19},  /*FracDiv19 */
+      {{1, 1, 4}, CGU_DEF_DOMAIN7_DIV20},  /*FracDiv20 */
+      {{1, 1, 32}, CGU_DEF_DOMAIN7_DIV21}, /*FracDiv21 */
+      {{1, 1, 2}, CGU_DEF_DOMAIN7_DIV22}   /*FracDiv22 */
+    }
+  },
+  /* domain8  - I2SRX_BCK0 ClockDomain*/
+  {
+    CGU_FIN_SELECT_XT_I2SRX_BCK0
+  },
+
+  /* domain9  - I2SRX_BCK1 ClockDomain*/
+  {
+    CGU_FIN_SELECT_XT_I2SRX_BCK1
+  },
+  /* domain10 [1] - SPI ClockDomain*/
+  {
+    CGU_FIN_SELECT_HPPLL1,
+    {
+      {{1, 1, 3}, CGU_DEF_DOMAIN10_DIV23} /*FracDiv23 */
+    }
+  },
+  /* domain11  - SYSCLK_O ClockDomain*/
+  {
+    CGU_FIN_SELECT_FFAST
+  },
+
+  /* dyn_fdiv_cfg[7]  */
+  {
+    /*For DYN_SEL, the bits below are all configured as 1.*/
+    /*
+       bit 	  Name							    Description:
+
+    	0	simple_dma_trans  			 dma transfers can enable high-speed
+    	1	simple_dma_ready				 dma last transfers can enable high-speed
+    	2	arm926_i_trans  	       arm926ejs_i transfers can enable high-speed
+    	3	arm926_i_ready		       arm926ejs_i_ready last transfers can enable high-speed
+    	4	arm926_d_trans  	       arm926ejs_d transfers can enable high-speed
+    	5	arm926_d_ready		       arm926ejs_d transfers can enable high-speed
+    	6	usb_otg_mst_trans   		 USB OTG transfers can enable high spee
+    	7	usb_otg_mst_ready				 USB OTG last transfers can enable high-speed
+    	8	mpmc_refresh_hispeed_req External SDRAM refresh generator transfers can enable high speed
+    */
+    {
+      0x1FF,
+      {1, 1, 64} /*DynFD0*/
+    },
+    {
+      0x1FF,
+      {0, 0, 0}	/*DynFD1*/
+    },
+    {
+      0x1FF,
+      {1, 1, 3}	/*DynFD2*/
+    },
+    {
+      0x1FF,
+      {1, 1, 6}	/*DynFD3*/
+    },
+    {
+      0x1FF,
+      {0, 0, 0}	/*DynFD4 - SD_MMC clock doesn't like dynamic switching*/
+    },
+    {
+      0x1FF,
+      {1, 1, 6}	/*DynFD5*/
+    },
+    {
+      0x1FF,
+      {1, 1, 3}	/*DynFD6*/
+    }
+  }
+};
+
+#elif defined(CONFIG_PLL_180)
+
+const CGU_CLKS_INIT_T g_cgu_default_clks_2 =
+{
+  /* domain0 [7] - SYS_BASE Domain*/
+  {
+    CGU_FIN_SELECT_HPPLL1,
+    {
+      {{1, 1, 2}, CGU_DEF_DOMAIN0_DIV0},  /*FracDiv0 */
+      {{0, 0, 0}, CGU_DEF_DOMAIN0_DIV1},  /*FracDiv1 */
+      {{1, 1, 2}, CGU_DEF_DOMAIN0_DIV2},  /*FracDiv2 */
+      {{1, 1, 4}, CGU_DEF_DOMAIN0_DIV3},  /*FracDiv3 */
+      {{1, 1, 4}, CGU_DEF_DOMAIN0_DIV4},  /*FracDiv4 */
+      {{1, 1, 2}, CGU_DEF_DOMAIN0_DIV5}, /*FracDiv5*/
+      {{1, 1, 2}, CGU_DEF_DOMAIN0_DIV6}   /*FracDiv6 */
+    }
+  },
+  /* domain1 [2] - AHB0_APB0 ClockDomain*/
+  {
+    CGU_FIN_SELECT_FFAST,
+    {
+      {{1, 1, 38}, CGU_DEF_DOMAIN1_DIV7}, /*FracDiv7 */
+      {{1, 1, 2}, CGU_DEF_DOMAIN1_DIV8}   /*FracDiv8 */
+    }
+  },
+  /* domain2 [2] - AHB0_APB1 ClockDomain*/
+  {
+    CGU_FIN_SELECT_FFAST,
+    {
+      {{1, 1, 2}, CGU_DEF_DOMAIN2_DIV9}, /*FracDiv9  */
+      {{1, 1, 2}, CGU_DEF_DOMAIN2_DIV10} /*FracDiv10 */
+    }
+  },
+  /* domain3 [3] - AHB0_APB2 ClockDomain*/
+  {
+    CGU_FIN_SELECT_HPPLL1,
+    {
+      {{1, 1, 2}, CGU_DEF_DOMAIN3_DIV11}, /*FracDiv11 */
+      {{1, 1, 40}, CGU_DEF_DOMAIN3_DIV12},/*FracDiv12 */
+      {{0, 0, 0}, CGU_DEF_DOMAIN3_DIV13}  /*FracDiv13 */
+    }
+  },
+  /* domain4 [1] - AHB0_APB3 ClockDomain*/
+  {
+    CGU_FIN_SELECT_FFAST,
+    {
+      {{1, 1, 2}, CGU_DEF_DOMAIN4_DIV14} /*FracDiv14 */
+    }
+  },
+  /* domain5 [1] - PCM ClockDomain*/
+  {
+    CGU_FIN_SELECT_HPPLL1,
+    {
+      {{1, 1, 2}, CGU_DEF_DOMAIN5_DIV15} /*FracDiv15 */
+    }
+  },
+  /* domain6 [1] - UART ClockDomain*/
+  {
+    CGU_FIN_SELECT_FFAST,
+    {
+      {{0, 0, 0}, CGU_DEF_DOMAIN6_DIV16} /*FracDiv16 */
+    }
+  },
+  /* domain7 [6] - CLK1024FS ClockDomain*/
+  {
+    CGU_FIN_SELECT_HPPLL0,
+    {
+      {{1, 1, 256}, CGU_DEF_DOMAIN7_DIV17},/*FracDiv17 */
+      {{1, 1, 4}, CGU_DEF_DOMAIN7_DIV18},  /*FracDiv18 */
+      {{0, 0, 0}, CGU_DEF_DOMAIN7_DIV19},  /*FracDiv19 */
+      {{1, 1, 4}, CGU_DEF_DOMAIN7_DIV20},  /*FracDiv20 */
+      {{1, 1, 32}, CGU_DEF_DOMAIN7_DIV21}, /*FracDiv21 */
+      {{1, 1, 2}, CGU_DEF_DOMAIN7_DIV22}   /*FracDiv22 */
+    }
+  },
+  /* domain8  - I2SRX_BCK0 ClockDomain*/
+  {
+    CGU_FIN_SELECT_XT_I2SRX_BCK0
+  },
+
+  /* domain9  - I2SRX_BCK1 ClockDomain*/
+  {
+    CGU_FIN_SELECT_XT_I2SRX_BCK1
+  },
+  /* domain10 [1] - SPI ClockDomain*/
+  {
+    CGU_FIN_SELECT_HPPLL1,
+    {
+      {{1, 1, 2}, CGU_DEF_DOMAIN10_DIV23} /*FracDiv23 */
+    }
+  },
+  /* domain11  - SYSCLK_O ClockDomain*/
+  {
+    CGU_FIN_SELECT_FFAST
+  },
+
+  /* dyn_fdiv_cfg[7]  */
+  {
+    /*For DYN_SEL, the bits below are all configured as 1.*/
+    /*
+       bit 	  Name							    Description:
+
+    	0	simple_dma_trans  			 dma transfers can enable high-speed
+    	1	simple_dma_ready				 dma last transfers can enable high-speed
+    	2	arm926_i_trans  	       arm926ejs_i transfers can enable high-speed
+    	3	arm926_i_ready		       arm926ejs_i_ready last transfers can enable high-speed
+    	4	arm926_d_trans  	       arm926ejs_d transfers can enable high-speed
+    	5	arm926_d_ready		       arm926ejs_d transfers can enable high-speed
+    	6	usb_otg_mst_trans   		 USB OTG transfers can enable high spee
+    	7	usb_otg_mst_ready				 USB OTG last transfers can enable high-speed
+    	8	mpmc_refresh_hispeed_req External SDRAM refresh generator transfers can enable high speed
+    */
+    {
+      0x1FF,
+      {1, 1, 64} /*DynFD0*/
+    },
+    {
+      0x1FF,
+      {0, 0, 0}	/*DynFD1*/
+    },
+    {
+      0x1FF,
+      {1, 1, 2}	/*DynFD2*/
+    },
+    {
+      0x1FF,
+      {1, 1, 4}	/*DynFD3*/
+    },
+    {
+      0x1FF,
+      {0, 0, 0}	/*DynFD4 - SD_MMC clock doesn't like dynamic switching*/
+    },
+    {
+      0x1FF,
+      {1, 1, 4}	/*DynFD5*/
+    },
+    {
+      0x1FF,
+      {1, 1, 2}	/*DynFD6*/
+    }
+  }
+};
+
+#endif
+
+
+
diff -purN apex-1.6.8/src/mach-lpc313x/lpc313x_cgu_driver.c work_1.6.8/src/mach-lpc313x/lpc313x_cgu_driver.c
--- apex-1.6.8/src/mach-lpc313x/lpc313x_cgu_driver.c	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/lpc313x_cgu_driver.c	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,1164 @@
+/*
+   written by Durgesh Pattamatta
+   10 Oct 2008
+
+   Copyright (C) 2008 NXP Semiconductors
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+*/
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <apex.h>
+#include <command.h>
+#include <error.h>
+#include <linux/kernel.h>
+#include <config.h>
+#include "lpc313x.h"
+
+/***********************************************************************
+* CGU driver package data
+***********************************************************************/
+u32* const g_clkin_freq = (u32*) (0x11029000 - CGU_FIN_SELECT_MAX * sizeof(u32));
+
+/***********************************************************************
+* CGU driver private functions
+**********************************************************************/
+/***********************************************************************
+*
+* Function: cgu_fdiv_num_bits
+*
+* Purpose: calculate int(log2(i))+1
+*
+* Processing:
+*     This algorithm is used to calculate the above said formula.
+*     This is used to calculate the madd and msub width in frac div
+*     registers.Reasonably fast.
+*
+* Parameters:
+*     i : Number
+*
+* Outputs: None
+*
+* Returns: int(log2(i))+1
+*
+* Notes: None
+*
+**********************************************************************/
+static u32 __section (.bootstrap) cgu_fdiv_num_bits(unsigned int i)
+{
+  u32 x = 0, y = 16;
+
+  for (; y > 0; y = y >> 1)
+  {
+    if (i >> y)
+    {
+      x += y;
+      i = i >> y;
+    }
+  }
+
+  if (i)
+    x++;
+
+  return x;
+}
+
+/***********************************************************************
+*
+* Function: cgu_clkid2esrid
+*
+* Purpose: Finds ESR Id corresponding to the requested clock Id
+*
+* Processing:
+*     Finds ESR index corresponding to the requested clock Id.
+*
+* Parameters:
+*     clkid : clock Id.
+*
+* Outputs: None
+*
+* Returns: ESR Id corresponding to clock Id
+*
+* Notes: None
+*
+**********************************************************************/
+u32 __section (.bootstrap) cgu_clkid2esrid(CGU_CLOCK_ID_T clkid)
+{
+  u32 esrIndex = (u32)clkid;
+
+  switch (clkid)
+  {
+    case CGU_SB_I2SRX_BCK0_ID:
+    case CGU_SB_I2SRX_BCK1_ID:
+    case CGU_SB_SYSCLK_O_ID:
+      /* invalid esr index. No ESR register for these clocks */
+      esrIndex = CGU_INVALID_ID;
+      break;
+
+    case CGU_SB_SPI_CLK_ID:
+    case CGU_SB_SPI_CLK_GATED_ID:
+      esrIndex = esrIndex - 2;
+      break;
+    default:
+      /* do nothing */
+      break;
+  }
+
+  return esrIndex;
+}
+/***********************************************************************
+*
+* Function: cgu_DomainId2bcrid
+*
+* Purpose: Finds BCR Id corresponding to the requested domain Id
+*
+* Processing:
+*     Finds BCR index corresponding to the requested domain Id.
+*
+* Parameters:
+*     domainid : Domain ID
+*
+* Outputs: None
+*
+* Returns: BCR Id corresponding to domain Id
+*
+* Notes: None
+*
+**********************************************************************/
+u32 __section (.bootstrap) cgu_DomainId2bcrid(CGU_DOMAIN_ID_T domainid)
+{
+  u32 bcridx = CGU_INVALID_ID;
+  switch (domainid)
+  {
+    case CGU_SB_SYS_BASE_ID:
+    case CGU_SB_AHB0_APB0_BASE_ID:
+    case CGU_SB_AHB0_APB1_BASE_ID:
+    case CGU_SB_AHB0_APB2_BASE_ID:
+      bcridx = domainid;
+      break;
+    case CGU_SB_CLK1024FS_BASE_ID:
+      bcridx = CGU_SB_NR_BCR - 1;
+      break;
+    default:
+      bcridx = CGU_INVALID_ID;
+      break;
+  }
+  return bcridx;
+}
+/***********************************************************************
+*
+* Function: cgu_ClkId2DomainId
+*
+* Purpose: Finds domain & sub-domain Ids for requested clock
+*
+* Processing:
+*     Finds domain index and fractional divider index for the requested
+*	   clock.
+*
+* Parameters:
+*     clkid : clock Id.
+*     pDomainId : pointer to domain index.
+*     pSubdomainId : pointer to fractional divider index.
+*
+* Outputs:
+*     pDomainId : pointer to domain index.
+*     pSubdomainId : pointer to fractional divider index.
+*
+* Returns: None
+*
+* Notes: None
+*
+**********************************************************************/
+void __section (.bootstrap) cgu_ClkId2DomainId(CGU_CLOCK_ID_T clkid, CGU_DOMAIN_ID_T* pDomainId,
+                        u32* pSubdomainId)
+{
+  u32 esrIndex, esrReg;
+  u32 fracdiv_base = CGU_INVALID_ID;
+
+  /*    1. Get the domain ID */
+
+  if (clkid <= CGU_SYS_LAST)
+  {
+    *pDomainId = CGU_SB_SYS_BASE_ID;
+    fracdiv_base = CGU_SB_BASE0_FDIV_LOW_ID;
+
+  }
+  else 	if (clkid <= CGU_AHB0APB0_LAST)
+  {
+    *pDomainId = CGU_SB_AHB0_APB0_BASE_ID;
+    fracdiv_base = CGU_SB_BASE1_FDIV_LOW_ID;
+
+  }
+  else 	if (clkid <= CGU_AHB0APB1_LAST)
+  {
+    *pDomainId = CGU_SB_AHB0_APB1_BASE_ID;
+    fracdiv_base = CGU_SB_BASE2_FDIV_LOW_ID;
+
+  }
+  else 	if (clkid <= CGU_AHB0APB2_LAST)
+  {
+    *pDomainId = CGU_SB_AHB0_APB2_BASE_ID;
+    fracdiv_base = CGU_SB_BASE3_FDIV_LOW_ID;
+
+  }
+  else 	if (clkid <= CGU_AHB0APB3_LAST)
+  {
+    *pDomainId = CGU_SB_AHB0_APB3_BASE_ID;
+    fracdiv_base = CGU_SB_BASE4_FDIV_LOW_ID;
+
+  }
+  else 	if (clkid == CGU_PCM_LAST)
+  {
+    *pDomainId = CGU_SB_PCM_BASE_ID;
+    fracdiv_base = CGU_SB_BASE5_FDIV_LOW_ID;
+
+  }
+  else 	if (clkid == CGU_UART_LAST)
+  {
+    *pDomainId = CGU_SB_UART_BASE_ID;
+    fracdiv_base = CGU_SB_BASE6_FDIV_LOW_ID;
+
+  }
+  else 	if (clkid <= CGU_CLK1024FS_LAST)
+  {
+    *pDomainId = CGU_SB_CLK1024FS_BASE_ID;
+    fracdiv_base = CGU_SB_BASE7_FDIV_LOW_ID;
+
+  }
+  else 	if (clkid == CGU_I2SRX_BCK0_LAST)
+  {
+    *pDomainId = CGU_SB_I2SRX_BCK0_BASE_ID;
+    fracdiv_base = CGU_INVALID_ID;
+
+  }
+  else 	if (clkid == CGU_I2SRX_BCK1_LAST)
+  {
+    *pDomainId = CGU_SB_I2SRX_BCK1_BASE_ID;
+    fracdiv_base = CGU_INVALID_ID;
+
+  }
+  else 	if (clkid <= CGU_SPI_LAST)
+  {
+    *pDomainId = CGU_SB_SPI_CLK_BASE_ID;
+    fracdiv_base = CGU_SB_BASE10_FDIV_LOW_ID;
+
+  }
+  else
+  {
+    *pDomainId = CGU_SB_SYSCLK_O_BASE_ID;
+    fracdiv_base = CGU_INVALID_ID;
+  }
+
+  *pSubdomainId = CGU_INVALID_ID;
+
+  /* read the clocks ESR to get the fractional divider */
+  esrIndex = cgu_clkid2esrid(clkid);
+
+  if (CGU_INVALID_ID != esrIndex)
+  {
+    /* read the clocks ESR to get the fractional divider */
+    esrReg = CGU_SB->clk_esr[esrIndex];
+
+    /* A clock may not be connected to any sub-domain and it might be
+    connected directly to domain. This is also a valid combination. So,
+    errror should not be returned */
+    if (esrReg & CGU_SB_ESR_ENABLE)
+    {
+      *pSubdomainId = CGU_SB_ESR_SEL_GET(esrReg) + fracdiv_base;
+    }
+  }
+
+}
+
+/***********************************************************************
+*
+* Function: cgu_fdiv_config
+*
+* Purpose:
+*
+* Processing:
+*     .
+*
+* Parameters:
+*     i : Number
+*
+* Outputs: None
+*
+* Returns:
+*
+* Notes: None
+*
+**********************************************************************/
+/* frac divider config function */
+u32 __section (.bootstrap) cgu_fdiv_config(u32 fdId, 
+					   CGU_FDIV_SETUP_T fdivCfg, 
+					   u32 enable,
+					   u32 dyn_fdc)
+{
+  u32 conf, maddw, msubw, maxw, fdWidth;
+  int madd, msub;
+
+  /* calculating program values to see if they fit in fractional divider*/
+  madd = fdivCfg.m - fdivCfg.n;
+  msub = -fdivCfg.n;
+
+  /* Find required bit width of madd & msub:*/
+  maddw = cgu_fdiv_num_bits((u32)madd);
+  msubw = cgu_fdiv_num_bits((u32)fdivCfg.n);
+  maxw = (maddw > msubw) ? maddw : msubw;
+  fdWidth = CGU_SB_BASE0_FDIV0_W;
+
+  if (fdId == CGU_SB_BASE7_FDIV_LOW_ID)
+  {
+    /* for Frac divider 17 the bit width is 13 */
+    fdWidth = CGU_SB_BASE7_FDIV0_W;
+  }
+
+  /* Calculate Configure parameter:*/
+  conf = ((((1 << fdWidth) - 1) &
+           (msub << (fdWidth - maxw))) <<
+          (fdWidth + CGU_SB_FDC_MADD_POS)) |
+         (madd << (fdWidth - maxw + CGU_SB_FDC_MADD_POS));
+
+  /* check whther 50% duty cycle is needed for this divider*/
+  if (fdivCfg.stretch)
+    conf |= CGU_SB_FDC_STRETCH;
+  /* check whehter to enable the divider immediately */
+  if (enable)
+    conf |= CGU_SB_FDC_RUN;
+
+  /* finally configure the divider*/
+  if (0 == dyn_fdc)
+  {
+	CGU_SB->base_fdc[fdId] = conf;
+  }
+  else
+  {
+	  if (fdId < CGU_SB_NR_DYN_FDIV)
+		CGU_SB->base_dyn_fdc[fdId] = conf | CGU_SB_DYN_FDC_ALLOW;
+  }
+
+  return conf;
+}
+/***********************************************************************
+*
+* Function: cgu_init_domain_clks
+*
+* Purpose:
+*
+* Processing:
+*     .
+*
+* Parameters:
+*     i : Number
+*
+* Outputs: None
+*
+* Returns:
+*
+* Notes: None
+*
+**********************************************************************/
+void __section (.bootstrap) cgu_init_domain_clks(CGU_DOMAIN_CFG_T* pDomain)
+{
+  u32 fd_id, clk_id, esr_id;
+  CGU_SUB_DOMAIN_CFG_T* psub = pDomain->sub;
+  u32 bcr_id = cgu_DomainId2bcrid(pDomain->id);
+  u32 fdiv_conf = 0;
+
+  if (bcr_id != CGU_INVALID_ID)
+  {
+    /* disable BCR for domain */
+    CGU_SB->base_bcr[bcr_id] = 0;
+  }
+
+  /* configure frac divider */
+  for (fd_id = 0; fd_id < pDomain->fdiv_cnt; fd_id++, psub++)
+  {
+    /* set fractional dividers but don't enable them yet*/
+    fdiv_conf = cgu_fdiv_config(fd_id + pDomain->fdiv_min, psub->fdiv_cfg, 0, 0);
+
+    /* enable frac divider only if it has valid settings. Or else it may be unused*/
+    if (fdiv_conf != 0)
+    {
+      /* select frac div for each clock in this sub domain*/
+      for (clk_id = 0; clk_id <= pDomain->clk_cnt; clk_id++)
+      {
+        esr_id = cgu_clkid2esrid((CGU_CLOCK_ID_T)(clk_id + pDomain->clk_min));
+        if (esr_id != CGU_INVALID_ID)
+        {
+          /* check whether clock belongs to this sub-domain */
+          if (psub->clks & _BIT(clk_id))
+          {
+            /* finally configure the clock*/
+            CGU_SB->clk_esr[esr_id] = CGU_SB_ESR_SELECT(fd_id) | CGU_SB_ESR_ENABLE;
+          }
+        }
+      }
+      /* enable frac divider */
+      CGU_SB->base_fdc[fd_id + pDomain->fdiv_min] |= CGU_SB_FDC_RUN;
+    }
+  }
+  if (bcr_id != CGU_INVALID_ID)
+  {
+    /* enable BCR for domain */
+    CGU_SB->base_bcr[bcr_id] = CGU_SB_BCR_FD_RUN;
+  }
+  /* select input for domain*/
+  cgu_set_base_freq(pDomain->id, pDomain->fin_sel);
+}
+
+
+/***********************************************************************
+* CGU driver public functions
+***********************************************************************/
+/***********************************************************************
+*
+* Function: cgu_init
+*
+* Purpose:
+*
+* Processing:
+*     .
+*
+* Parameters:
+*     i : Number
+*
+* Outputs: None
+*
+* Returns:
+*
+* Notes: None
+*
+**********************************************************************/
+void __section (.bootstrap) cgu_init(void)
+{
+    g_clkin_freq[0] = FFAST_CLOCK;
+    g_clkin_freq[1] = 0;
+    g_clkin_freq[2] = 0;
+    g_clkin_freq[3] = 0;
+    g_clkin_freq[4] = 0;
+    g_clkin_freq[5] = 0;
+    g_clkin_freq[6] = 0;
+}
+
+/***********************************************************************
+*
+* Function: cgu_reset_all_clks
+*
+* Purpose:
+*
+* Processing:
+*     .
+*
+* Parameters:
+*     i : Number
+*
+* Outputs: None
+*
+* Returns:
+*
+* Notes: None
+*
+**********************************************************************/
+void __section (.bootstrap) cgu_reset_all_clks(void)
+{
+  CGU_DOMAIN_ID_T domainId;
+  u32 bcrId, esr_id;
+  u32 enable, i;
+
+  /* switch all clocks to FFAST */
+  for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE; domainId++)
+  {
+    /* switch reference clock in to FFAST */
+    cgu_set_base_freq(domainId, CGU_FIN_SELECT_FFAST);
+    /* check if the domain has a BCR*/
+    bcrId = cgu_DomainId2bcrid(domainId);
+    /* disable all BCRs */
+    if (bcrId != CGU_INVALID_ID)
+    {
+      CGU_SB->base_bcr[bcrId] = 0;
+    }
+  }
+  /* disable all clocks except the needed ones */
+  for (i = 0; i < (CGU_SYSCLK_O_LAST + 1); i++)
+  {
+    /* Clear the clocks ESR to deselect fractional divider */
+    esr_id = cgu_clkid2esrid((CGU_CLOCK_ID_T)i);
+
+    if (CGU_INVALID_ID != esr_id)
+    {
+      CGU_SB->clk_esr[esr_id] = 0;
+    }
+
+    if (i < 31)
+    {
+      enable = CGU_DEF_CLKS_0_31 & _BIT(i);
+    }
+    else
+    {
+      if (i < 63)
+      {
+        enable = CGU_DEF_CLKS_32_63 & _BIT(i - 32);
+      }
+      else
+      {
+        enable = CGU_DEF_CLKS_64_92 & _BIT(i - 64);
+      }
+    }
+    /**********************************************************/
+    /* initiliase external enables and ext_outs  */
+    /**********************************************************/
+    /* set external enable for all possible clocks to conserve
+    power. cgu_clk_set_exten() function sets CGU_SB_PCR_EXTEN_EN
+    for allowed clocks only. */
+    cgu_clk_set_exten((CGU_CLOCK_ID_T)i, 1);
+
+    /* set enable-outs for only the following clocks */
+    if ((i == CGU_SB_ARM926_BUSIF_CLK_ID) ||
+        (i == CGU_SB_MPMC_CFG_CLK_ID))
+    {
+      CGU_SB->clk_pcr[i] |= CGU_SB_PCR_ENOUT_EN;
+    }
+    else
+    {
+      CGU_SB->clk_pcr[i] &= ~CGU_SB_PCR_ENOUT_EN;
+    }
+
+    /* disable all clocks except the needed ones */
+    if (enable)
+    {
+      CGU_SB->clk_pcr[i] |= CGU_SB_PCR_RUN;
+    }
+    else
+    {
+      CGU_SB->clk_pcr[i] &= ~CGU_SB_PCR_RUN;
+    }
+  }
+  /* disable all fractional dividers */
+  for (i = 0; i < CGU_SB_NR_FRACDIV; i++)
+  {
+    CGU_SB->base_fdc[i] &= ~CGU_SB_FDC_RUN;
+  }
+}
+
+/***********************************************************************
+*
+* Function: cgu_init_clks
+*
+* Purpose:
+*
+* Processing:
+*     .
+*
+* Parameters:
+*     i : Number
+*
+* Outputs: None
+*
+* Returns:
+*
+* Notes: None
+*
+**********************************************************************/
+/* select frac div for each clk */
+int __section (.bootstrap) cgu_init_clks(const CGU_CLKS_INIT_T* pClksCfg)
+{
+  CGU_DOMAIN_CFG_T domain;
+  int i;
+
+  /* reset all clocks and connect them to FFAST */
+  cgu_reset_all_clks();
+
+  /**********************************************************/
+  /* initiliase Domain0 = SYS_BASE clocks                   */
+  /**********************************************************/
+  domain.id = CGU_SB_SYS_BASE_ID;
+  domain.fin_sel = pClksCfg->domain0.fin_sel;
+  domain.clk_min = CGU_SYS_FIRST;
+  domain.clk_cnt = (CGU_SYS_LAST - CGU_SYS_FIRST) + 1;
+  domain.fdiv_min = CGU_SB_BASE0_FDIV_LOW_ID;
+  domain.fdiv_cnt = CGU_SB_BASE0_FDIV_CNT;
+  domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain0.sub[0];
+  /* initialize all clocks and frac dividers for this domain */
+  cgu_init_domain_clks(&domain);
+
+  /**********************************************************/
+  /* initiliase Domain1 = AHB0APB0_BASE clocks */
+  /**********************************************************/
+  domain.id = CGU_SB_AHB0_APB0_BASE_ID;
+  domain.fin_sel = pClksCfg->domain1.fin_sel;
+  domain.clk_min = CGU_AHB0APB0_FIRST;
+  domain.clk_cnt = (CGU_AHB0APB0_LAST - CGU_AHB0APB0_FIRST) + 1;
+  domain.fdiv_min = CGU_SB_BASE1_FDIV_LOW_ID;
+  domain.fdiv_cnt = CGU_SB_BASE1_FDIV_CNT;
+  domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain1.sub[0];
+  /* initialize all clocks and frac dividers for this domain */
+  cgu_init_domain_clks(&domain);
+
+  /**********************************************************/
+  /* initiliase Domain2 = AHB0APB1_BASE clocks */
+  /**********************************************************/
+  domain.id = CGU_SB_AHB0_APB1_BASE_ID;
+  domain.fin_sel = pClksCfg->domain2.fin_sel;
+  domain.clk_min = CGU_AHB0APB1_FIRST;
+  domain.clk_cnt = (CGU_AHB0APB1_LAST - CGU_AHB0APB1_FIRST) + 1;
+  domain.fdiv_min = CGU_SB_BASE2_FDIV_LOW_ID;
+  domain.fdiv_cnt = CGU_SB_BASE2_FDIV_CNT;
+  domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain2.sub[0];
+  /* initialize all clocks and frac dividers for this domain */
+  cgu_init_domain_clks(&domain);
+
+  /**********************************************************/
+  /* initiliase Domain3 = AHB0APB2_BASE clocks */
+  /**********************************************************/
+  domain.id = CGU_SB_AHB0_APB2_BASE_ID;
+  domain.fin_sel = pClksCfg->domain3.fin_sel;
+  domain.clk_min = CGU_AHB0APB2_FIRST;
+  domain.clk_cnt = (CGU_AHB0APB2_LAST - CGU_AHB0APB2_FIRST) + 1;
+  domain.fdiv_min = CGU_SB_BASE3_FDIV_LOW_ID;
+  domain.fdiv_cnt = CGU_SB_BASE3_FDIV_CNT;
+  domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain3.sub[0];
+  /* initialize all clocks and frac dividers for this domain */
+  cgu_init_domain_clks(&domain);
+
+  /**********************************************************/
+  /* initiliase Domain4 = AHB0APB3_BASE clocks */
+  /**********************************************************/
+  domain.id = CGU_SB_AHB0_APB3_BASE_ID;
+  domain.fin_sel = pClksCfg->domain4.fin_sel;
+  domain.clk_min = CGU_AHB0APB3_FIRST;
+  domain.clk_cnt = (CGU_AHB0APB3_LAST - CGU_AHB0APB3_FIRST) + 1;
+  domain.fdiv_min = CGU_SB_BASE4_FDIV_LOW_ID;
+  domain.fdiv_cnt = CGU_SB_BASE4_FDIV_CNT;
+  domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain4.sub[0];
+  /* initialize all clocks and frac dividers for this domain */
+  cgu_init_domain_clks(&domain);
+
+  /**********************************************************/
+  /* initiliase Domain5 = PCM_BASE clocks */
+  /**********************************************************/
+  domain.id = CGU_SB_PCM_BASE_ID;
+  domain.fin_sel = pClksCfg->domain5.fin_sel;
+  domain.clk_min = CGU_PCM_FIRST;
+  domain.clk_cnt = 1;
+  domain.fdiv_min = CGU_SB_BASE5_FDIV_LOW_ID;
+  domain.fdiv_cnt = CGU_SB_BASE5_FDIV_CNT;
+  domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain5.sub[0];
+  /* initialize all clocks and frac dividers for this domain */
+  cgu_init_domain_clks(&domain);
+
+  /**********************************************************/
+  /* initiliase Domain6 = UART_BASE clocks */
+  /**********************************************************/
+  domain.id = CGU_SB_UART_BASE_ID;
+  domain.fin_sel = pClksCfg->domain6.fin_sel;
+  domain.clk_min = CGU_UART_FIRST;
+  domain.clk_cnt = 1;
+  domain.fdiv_min = CGU_SB_BASE6_FDIV_LOW_ID;
+  domain.fdiv_cnt = CGU_SB_BASE6_FDIV_CNT;
+  domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain6.sub[0];
+  /* initialize all clocks and frac dividers for this domain */
+  cgu_init_domain_clks(&domain);
+
+  /**********************************************************/
+  /* initiliase Domain7 = CLK1024FS_BASE clocks */
+  /**********************************************************/
+  domain.id = CGU_SB_CLK1024FS_BASE_ID;
+  domain.fin_sel = pClksCfg->domain7.fin_sel;
+  domain.clk_min = CGU_CLK1024FS_FIRST;
+  domain.clk_cnt = (CGU_CLK1024FS_LAST - CGU_CLK1024FS_FIRST) + 1;
+  domain.fdiv_min = CGU_SB_BASE7_FDIV_LOW_ID;
+  domain.fdiv_cnt = CGU_SB_BASE7_FDIV_CNT;
+  domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain7.sub[0];
+  /* initialize all clocks and frac dividers for this domain */
+  cgu_init_domain_clks(&domain);
+
+  /**********************************************************/
+  /* initiliase Domain8 = BCK0_BASE clocks */
+  /**********************************************************/
+  /* select input for domain*/
+  cgu_set_base_freq(CGU_SB_I2SRX_BCK0_BASE_ID, pClksCfg->domain8.fin_sel);
+
+  /**********************************************************/
+  /* initiliase Domain9 = BCK1_BASE clocks */
+  /**********************************************************/
+  /* select input for domain*/
+  cgu_set_base_freq(CGU_SB_I2SRX_BCK1_BASE_ID, pClksCfg->domain9.fin_sel);
+
+  /**********************************************************/
+  /* initiliase Domain10 = SPI_BASE clocks */
+  /**********************************************************/
+  domain.id = CGU_SB_SPI_CLK_BASE_ID;
+  domain.fin_sel = pClksCfg->domain10.fin_sel;
+  domain.clk_min = CGU_SPI_FIRST;
+  domain.clk_cnt = (CGU_SPI_LAST - CGU_SPI_FIRST) + 1;
+  domain.fdiv_min = CGU_SB_BASE10_FDIV_LOW_ID;
+  domain.fdiv_cnt = CGU_SB_BASE10_FDIV_CNT;
+  domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain10.sub[0];
+  /* initialize all clocks and frac dividers for this domain */
+  cgu_init_domain_clks(&domain);
+
+  /**********************************************************/
+  /* initiliase Domain11 = SYSCLK_O_BASE clocks */
+  /**********************************************************/
+  /* select input for domain*/
+  cgu_set_base_freq(CGU_SB_SYSCLK_O_BASE_ID, pClksCfg->domain11.fin_sel);
+
+  /**********************************************************/
+  /* initiliase Dynamic fractional dividers TBD */
+  /**********************************************************/
+#if defined(CONFIG_DYNAMIC_CLOCKS)
+  /* disable BCR for domain */
+  CGU_SB->base_bcr[0] = 0;
+  for (i = 0; i < CGU_SB_NR_DYN_FDIV; i++) 
+  {
+	  if (pClksCfg->dyn_fdiv_cfg[i].cfg.n != 0)
+	  {
+		  CGU_SB->base_dyn_sel[i] = pClksCfg->dyn_fdiv_cfg[i].sel;
+		  cgu_fdiv_config(i, pClksCfg->dyn_fdiv_cfg[i].cfg, 1, 1);
+	  }
+	  else
+	  {
+		  CGU_SB->base_dyn_fdc[i] = 0;
+	  }
+
+  }
+
+  CGU_SB->base_bcr[0] = CGU_SB_BCR_FD_RUN;
+#endif
+
+  return 0;
+}
+
+/***********************************************************************
+*
+* Function: cgu_get_base_freq
+*
+* Purpose:
+*
+* Processing:
+*     .
+*
+* Parameters:
+*     i : Number
+*
+* Outputs: None
+*
+* Returns:
+*
+* Notes: None
+*
+**********************************************************************/
+int __section (.bootstrap) cgu_get_base_freq(CGU_DOMAIN_ID_T baseid)
+{
+  int freq;
+
+  /* get base frequency for the domain */
+  freq = g_clkin_freq[CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[baseid])];
+
+  return freq;
+}
+
+/***********************************************************************
+*
+* Function: cgu_set_base_freq
+*
+* Purpose:
+*
+* Processing:
+*     .
+*
+* Parameters:
+*     i : Number
+*
+* Outputs: None
+*
+* Returns:
+*
+* Notes: None
+*
+**********************************************************************/
+void __section (.bootstrap) cgu_set_base_freq(CGU_DOMAIN_ID_T baseid, u32 fin_sel)
+{
+  u32 baseSCR;
+
+  /* Switch configuration register*/
+  baseSCR = CGU_SB->base_scr[baseid] & ~CGU_SB_SCR_FS_MASK;
+  /* If fs1 is currently enabled set refId to fs2 and enable fs2*/
+  if (CGU_SB->base_ssr[baseid] & CGU_SB_SCR_EN1)
+  {
+    /* check if the selcted frequency is same as requested. If not switch.*/
+    if (CGU_SB->base_fs1[baseid] != fin_sel)
+    {
+      CGU_SB->base_fs2[baseid] = fin_sel;
+
+      /* Don't touch stop bit in SCR register*/
+      CGU_SB->base_scr[baseid] = baseSCR | CGU_SB_SCR_EN2;
+    }
+  }
+  else
+  {
+    /* check if the selcted frequency is same as requested. If not switch.*/
+    if (CGU_SB->base_fs2[baseid] != fin_sel)
+    {
+      CGU_SB->base_fs1[baseid] = fin_sel;
+
+      /* Don't touch stop bit in SCR register*/
+      CGU_SB->base_scr[baseid] = baseSCR | CGU_SB_SCR_EN1;
+    }
+  }
+}
+
+/***********************************************************************
+*
+* Function: cgu_hpll_config
+*
+* Purpose:
+*
+* Processing:
+*     .
+*
+* Parameters:
+*     i : Number
+*
+* Outputs: None
+*
+* Returns:
+*
+* Notes: None
+*
+**********************************************************************/
+void __section (.bootstrap) cgu_hpll_config(CGU_HPLL_ID_T pllid, CGU_HPLL_SETUP_T* pllsetup)
+{
+  CGU_HP_CFG_REGS* hppll;
+  u32 switched_domains = 0;
+  CGU_DOMAIN_ID_T domainId;
+
+  /**********************************************************
+  * switch domains connected to HPLL to FFAST automatically
+  ***********************************************************/
+  for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE; domainId++)
+  {
+    if (CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId]) ==
+        (CGU_FIN_SELECT_HPPLL0 + pllid))
+    {
+      /* switch reference clock in to FFAST */
+      cgu_set_base_freq(domainId, CGU_FIN_SELECT_FFAST);
+      /* store the domain id to switch back to HPLL */
+      switched_domains |= _BIT(domainId);
+    }
+  }
+
+  /* get PLL regs */
+  hppll = &CGU_CFG->hp[pllid];
+
+  /* disable clock, disable skew enable, power down pll,
+  * (dis/en)able post divider, (dis/en)able pre-divider,
+  * disable free running mode, disable bandsel,
+  * enable up limmiter, disable bypass
+  */
+  hppll->mode = CGU_HPLL_MODE_PD;
+
+  /* Select fin */
+  hppll->fin_select = pllsetup->fin_select;
+
+  /* M divider */
+  hppll->mdec = pllsetup->mdec & CGU_HPLL_MDEC_MASK;
+
+  /* N divider */
+  hppll->ndec = pllsetup->ndec & CGU_HPLL_NDEC_MSK;
+
+  /* P divider */
+  hppll->pdec = pllsetup->pdec & CGU_HPLL_PDEC_MSK;
+
+  /* Set bandwidth */
+  hppll->selr = pllsetup->selr;
+  hppll->seli = pllsetup->seli;
+  hppll->selp = pllsetup->selp;
+
+  /* Power up pll */
+  hppll->mode = (pllsetup->mode & ~CGU_HPLL_MODE_PD) | CGU_HPLL_MODE_CLKEN;
+
+  /* store the estimated freq in driver data for future clk calcs */
+  g_clkin_freq[CGU_FIN_SELECT_HPPLL0 + pllid] = pllsetup->freq;
+
+  /* wait for PLL to lock */
+  while ((hppll->status & CGU_HPLL_STATUS_LOCK) == 0);
+
+  /**********************************************************
+  * switch domains back to HPLL
+  ***********************************************************/
+  for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE; domainId++)
+  {
+    if (switched_domains & _BIT(domainId))
+    {
+      /* switch reference clock in to HPLL */
+      cgu_set_base_freq(domainId, CGU_FIN_SELECT_HPPLL0 + pllid);
+    }
+  }
+
+}
+
+/***********************************************************************
+*
+* Function: cgu_clk_set_exten
+*
+* Purpose:
+*
+* Processing:
+*     .
+*
+* Parameters:
+*     i : Number
+*
+* Outputs: None
+*
+* Returns:
+*
+* Notes: None
+*
+**********************************************************************/
+void __section (.bootstrap) cgu_clk_set_exten(CGU_CLOCK_ID_T clkid, u32 enable)
+{
+  switch (clkid)
+  {
+    case CGU_SB_OTP_PCLK_ID:
+    case CGU_SB_PCM_APB_PCLK_ID:
+    case CGU_SB_EVENT_ROUTER_PCLK_ID:
+    case CGU_SB_ADC_PCLK_ID:
+    case CGU_SB_IOCONF_PCLK_ID:
+    case CGU_SB_CGU_PCLK_ID:
+    case CGU_SB_SYSCREG_PCLK_ID:
+    case CGU_SB_DMA_CLK_GATED_ID:
+    case CGU_SB_SPI_PCLK_GATED_ID:
+    case CGU_SB_SPI_CLK_GATED_ID:
+    case CGU_SB_PCM_CLK_IP_ID:
+    case CGU_SB_PWM_PCLK_REGS_ID:
+    //case CGU_SB_NANDFLASH_ECC_CLK_ID:
+      if (enable)
+      {
+        CGU_SB->clk_pcr[clkid] |= CGU_SB_PCR_EXTEN_EN;
+      }
+      else
+      {
+        CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_EXTEN_EN;
+      }
+      break;
+      /* force disable for the following clocks */
+    case CGU_SB_I2C0_PCLK_ID:
+    case CGU_SB_I2C1_PCLK_ID:
+    case CGU_SB_WDOG_PCLK_ID:
+    case CGU_SB_UART_APB_CLK_ID:
+    case CGU_SB_LCD_PCLK_ID:
+      CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_EXTEN_EN;
+      break;
+    default:
+      break;
+  }
+}
+
+/***********************************************************************
+*
+* Function: cgu_get_clk_freq
+*
+* Purpose:
+*
+* Processing:
+*     .
+*
+* Parameters:
+*     i : Number
+*
+* Outputs: None
+*
+* Returns:
+*
+* Notes: None
+*
+**********************************************************************/
+u32 __section (.bootstrap) cgu_get_clk_freq(CGU_CLOCK_ID_T clkid)
+{
+  u32 freq = 0;
+  CGU_DOMAIN_ID_T domainId;
+  u32 subDomainId;
+  int n, m;
+  u32 fdcVal;
+
+  /* get domain and frac div info for the clock */
+  cgu_ClkId2DomainId(clkid, &domainId, &subDomainId);
+
+  /* get base frequency for the domain */
+  freq = g_clkin_freq[CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId])];
+
+  /* direct connection  has no fraction divider*/
+  if (subDomainId == CGU_INVALID_ID)
+  {
+    return freq;
+  }
+  /* read frac div control register value */
+  fdcVal = CGU_SB->base_fdc[subDomainId];
+
+  if (fdcVal & CGU_SB_FDC_RUN) /* Is the fracdiv enabled ?*/
+  {
+    /* Yes, so reverse calculation of madd and msub */
+    {
+      int msub, madd;
+
+      if (subDomainId != CGU_SB_BASE7_FDIV_LOW_ID)
+      {
+        msub = CGU_SB_FDC_MSUB_GET(fdcVal);
+        madd = CGU_SB_FDC_MADD_GET(fdcVal);
+      }
+      else
+      {
+        msub = CGU_SB_FDC17_MSUB_GET(fdcVal);
+        madd = CGU_SB_FDC17_MADD_GET(fdcVal);
+      }
+
+      /* remove trailing zeros */
+      while (!(msub & 1)  && !(madd & 1))
+      {
+        madd = madd >> 1;
+        msub = msub >> 1;
+      }
+      /* compute m and n values */
+      n = - msub;
+      m = madd + n;
+    }
+    /* check m and n are non-zero values */
+    if ((n == 0) || (m == 0))
+    {
+      return 0;
+    }
+    /* calculate the frequency based on m and n values */
+    freq = (freq * n) / m ;
+  }
+  /* else There is no fractional divider in the clocks path */
+
+  return  freq;
+}
+
+/***********************************************************************
+*
+* Function: cgu_set_subdomain_freq
+*
+* Purpose:
+*
+* Processing:
+*     .
+*
+* Parameters:
+*     i : Number
+*
+* Outputs: None
+*
+* Returns:
+*
+* Notes: None
+*
+**********************************************************************/
+void __section (.bootstrap) cgu_set_subdomain_freq(CGU_CLOCK_ID_T clkid, CGU_FDIV_SETUP_T fdiv_cfg)
+{
+  CGU_DOMAIN_ID_T domainId;
+  u32 subDomainId, base_freq, bcrId;
+
+  /* get domain and frac div info for the clock */
+  cgu_ClkId2DomainId(clkid, &domainId, &subDomainId);
+
+  /* direct connection  has no fraction divider*/
+  if (subDomainId != CGU_INVALID_ID)
+  {
+    /* store base freq */
+    base_freq = CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId]);
+    /* switch domain to FFAST */
+    cgu_set_base_freq(domainId, CGU_FIN_SELECT_FFAST);
+    /* check if the domain has a BCR*/
+    bcrId = cgu_DomainId2bcrid(domainId);
+    /* disable all BCRs */
+    if (bcrId != CGU_INVALID_ID)
+    {
+      CGU_SB->base_bcr[bcrId] = 0;
+    }
+    /* change fractional divider */
+    cgu_fdiv_config(subDomainId, fdiv_cfg, 1, 0);
+    /* enable BCRs */
+    if (bcrId != CGU_INVALID_ID)
+    {
+      CGU_SB->base_bcr[bcrId] = CGU_SB_BCR_FD_RUN;
+    }
+    /* switch domain to original base frequency */
+    cgu_set_base_freq(domainId, base_freq);
+  }
+}
+
+/***********************************************************************
+*
+* Function: cgu_soft_reset_module
+*
+* Purpose:
+*
+* Processing:
+*     .
+*
+* Parameters:
+*     i : Number
+*
+* Outputs: None
+*
+* Returns:
+*
+* Notes: None
+*
+**********************************************************************/
+void __section (.bootstrap) cgu_soft_reset_module(CGU_MOD_ID_T modId)
+{
+  volatile u32 i;
+
+  /* clear and set the register */
+  CGU_CFG->resetn_soft[modId] = 0;
+  /* introduce some delay */
+  for (i = 0;i < 1000;i++);
+
+  CGU_CFG->resetn_soft[modId] = CGU_CONFIG_SOFT_RESET;
+}
+
+int cmd_clock (int argc, const char** argv)
+{
+	u32 clk_id = CGU_SYS_FIRST;
+	u32 end_id = (CGU_SYSCLK_O_LAST + 1);
+	char* str[2] = { "OFF", " ON"}; 
+
+	if (argc > 1) {
+
+		clk_id = simple_strtoul (argv[1], NULL, 0);
+		end_id = clk_id + 1;
+	}
+
+	while (clk_id < end_id)
+	{
+		printf ("clock[%02d] %s(PSR)/%s(PCR) : %d\r\n", clk_id, 
+			str[(CGU_SB->clk_psr[clk_id] & 0x1)], 
+			str[(CGU_SB->clk_pcr[clk_id] & 0x1)], 
+			cgu_get_clk_freq(clk_id));
+		clk_id++;
+	}
+
+	return 0;
+}
+
+static __command struct command_d c_clk = {
+	.command = "clock",
+	.func = cmd_clock,
+	COMMAND_DESCRIPTION ("Get clock speed")
+	COMMAND_HELP (
+	"clock [clk_id]\n"
+	" clk_id - Clock index 0 to 91\n"
+	" Dumps all clock speeds if nor parameter is passed.\n"
+	"\n")
+};
diff -purN apex-1.6.8/src/mach-lpc313x/lpc313x_cgu.h work_1.6.8/src/mach-lpc313x/lpc313x_cgu.h
--- apex-1.6.8/src/mach-lpc313x/lpc313x_cgu.h	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/lpc313x_cgu.h	2010-03-15 11:45:40.000000000 -0700
@@ -0,0 +1,751 @@
+/*
+   written by Durgesh Pattamatta
+   10 Oct 2008
+
+   Copyright (C) 2008 NXP Semiconductors
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+*/
+
+#ifndef LPC313X_CGU_H
+#define LPC313X_CGU_H
+
+ /***********************************************************************
+ * CGU register definitions
+ **********************************************************************/
+#define CGU_SB_PHYS   (0x13004000)      
+#define CGU_CFG_PHYS  (0x13004c00)
+
+#define CGU_SB_NR_BASE                  12
+#define CGU_SB_NR_CLK                   92
+#define CGU_SB_NR_BCR                   5
+#define CGU_SB_NR_FRACDIV               24
+#define CGU_SB_NR_DYN_FDIV              7
+#define CGU_SB_NR_ESR                   89
+#define CGU_SB_BASE0_FDIV_CNT           7
+#define CGU_SB_BASE0_FDIV_LOW_ID        0
+#define CGU_SB_BASE0_FDIV_HIGH_ID       6
+#define CGU_SB_BASE0_FDIV0_W            8
+
+#define CGU_SB_BASE1_FDIV_CNT           2
+#define CGU_SB_BASE1_FDIV_LOW_ID        7
+#define CGU_SB_BASE1_FDIV_HIGH_ID       8
+
+#define CGU_SB_BASE2_FDIV_CNT           2
+#define CGU_SB_BASE2_FDIV_LOW_ID        9
+#define CGU_SB_BASE2_FDIV_HIGH_ID       10
+
+#define CGU_SB_BASE3_FDIV_CNT           3
+#define CGU_SB_BASE3_FDIV_LOW_ID        11
+#define CGU_SB_BASE3_FDIV_HIGH_ID       13
+
+#define CGU_SB_BASE4_FDIV_CNT           1
+#define CGU_SB_BASE4_FDIV_LOW_ID        14
+#define CGU_SB_BASE4_FDIV_HIGH_ID       14
+
+#define CGU_SB_BASE5_FDIV_CNT           1
+#define CGU_SB_BASE5_FDIV_LOW_ID        15
+#define CGU_SB_BASE5_FDIV_HIGH_ID       15
+
+#define CGU_SB_BASE6_FDIV_CNT           1
+#define CGU_SB_BASE6_FDIV_LOW_ID        16
+#define CGU_SB_BASE6_FDIV_HIGH_ID       16
+
+#define CGU_SB_BASE7_FDIV_CNT           6
+#define CGU_SB_BASE7_FDIV_LOW_ID        17
+#define CGU_SB_BASE7_FDIV_HIGH_ID       22
+#define CGU_SB_BASE7_FDIV0_W            13
+
+#define CGU_SB_BASE10_FDIV_CNT          1
+#define CGU_SB_BASE10_FDIV_LOW_ID       23
+#define CGU_SB_BASE10_FDIV_HIGH_ID      23
+
+
+typedef volatile struct
+{
+  /* Switches controls */
+  volatile u32 base_scr[12]; /* Switch control */
+  volatile u32 base_fs1[12]; /* Frequency select side 1 */
+  volatile u32 base_fs2[12]; /* Frequency select side 2 */
+  volatile u32 base_ssr[12]; /* Switch status */
+  /* Clock enable controls (positive and inverted clock pairs share control register)*/
+  volatile u32 clk_pcr[92]; /* power control */
+  volatile u32 clk_psr[92]; /* power status */
+  /* enable select from fractional dividers (positive and inverted clock pairs share esr)*/
+  volatile u32 clk_esr[89]; /* enable select */
+  /* Base controls, currently only fd_run (base wide fractional divider enable) bit.*/
+  volatile u32 base_bcr[5]; /* Base control */
+  /* Fractional divider controls & configuration*/
+  volatile u32 base_fdc[24]; /* Fractional divider config & ctrl */
+  volatile u32 base_dyn_fdc[7]; /* Fractional divider config & ctrl for dynamic fracdivs */
+  volatile u32 base_dyn_sel[7]; /* Fractional divider register for selecting an external signal to trigger high-speed operation*/
+} CGU_SB_REGS_T;
+
+/* ----------------
+* HP PLL Registers
+* ----------------
+*/
+typedef volatile struct
+{
+  volatile u32 fin_select;
+  volatile u32 mdec;
+  volatile u32 ndec;
+  volatile u32 pdec;
+  volatile u32 mode;
+  volatile u32 status;
+  volatile u32 ack;
+  volatile u32 req;
+  volatile u32 inselr;
+  volatile u32 inseli;
+  volatile u32 inselp;
+  volatile u32 selr;
+  volatile u32 seli;
+  volatile u32 selp;
+} CGU_HP_CFG_REGS, *pCGU_HP_CFG_REGS;
+
+typedef volatile struct
+{
+  volatile u32 powermode;
+  volatile u32 wd_bark;
+  volatile u32 ffast_on;
+  volatile u32 ffast_bypass;
+  volatile u32 resetn_soft[56];
+  CGU_HP_CFG_REGS hp[2];
+} CGU_CONFIG_REGS, *pCGU_CONFIG_REGS;
+
+#define CGU_SB    ((CGU_SB_REGS_T*) (CGU_SB_PHYS))
+#define CGU_CFG   ((CGU_CONFIG_REGS*) (CGU_CFG_PHYS))
+
+
+/* Switch Control Register */
+#define CGU_SB_SCR_EN1              _BIT(0)
+#define CGU_SB_SCR_EN2              _BIT(1)
+#define CGU_SB_SCR_RST              _BIT(2)
+#define CGU_SB_SCR_STOP             _BIT(3)
+#define CGU_SB_SCR_FS_MASK          0x3
+
+/* Switch Status Register */
+#define CGU_SB_SSR_FS_GET(x)        ( ((x) >> 2) & 0x7)
+/* Power Control Register */
+#define CGU_SB_PCR_RUN              _BIT(0)
+#define CGU_SB_PCR_AUTO             _BIT(1)
+#define CGU_SB_PCR_WAKE_EN          _BIT(2)
+#define CGU_SB_PCR_EXTEN_EN         _BIT(3)
+#define CGU_SB_PCR_ENOUT_EN         _BIT(4)
+/* Power Status Register */
+#define CGU_SB_PSR_ACTIVE           _BIT(0)
+#define CGU_SB_PSR_WAKEUP           _BIT(1)
+/* Enable Select Register */
+#define CGU_SB_ESR_ENABLE           _BIT(0)
+#define CGU_SB_ESR_SELECT(x)        _SBF(1, (x))
+#define CGU_SB_ESR_SEL_GET(x)       (((x) >> 1) & 0x7)
+
+/* Base control Register */
+#define CGU_SB_BCR_FD_RUN           _BIT(0)
+/* Fractional Divider Configuration Register */
+#define CGU_SB_FDC_RUN              _BIT(0)
+#define CGU_SB_FDC_RESET            _BIT(1)
+#define CGU_SB_FDC_STRETCH          _BIT(2)
+#define CGU_SB_FDC_MADD(x)          _SBF( 3, ((x) & 0xFF))
+#define CGU_SB_FDC_MSUB(x)          _SBF(11, ((x) & 0xFF))
+#define CGU_SB_FDC17_MADD(x)        _SBF( 3, ((x) & 0x1FFF))
+#define CGU_SB_FDC17_MSUB(x)        _SBF(16, ((x) & 0x1FFF))
+#define CGU_SB_FDC_MADD_GET(x)      (((x) >> 3) & 0xFF)
+#define CGU_SB_FDC_MSUB_GET(x)      ((((x) >> 11) & 0xFF) | 0xFFFFFF00)
+#define CGU_SB_FDC17_MADD_GET(x)    (((x) >> 3) & 0x1FFF)
+#define CGU_SB_FDC17_MSUB_GET(x)    ((((x) >> 16) & 0x1FFF) | 0xFFFFE000)
+#define CGU_SB_FDC_MADD_POS         3
+
+/* Dynamic Fractional Divider Configuration Register */
+#define CGU_SB_DYN_FDC_RUN          _BIT(0)
+#define CGU_SB_DYN_FDC_ALLOW        _BIT(1)
+#define CGU_SB_DYN_FDC_STRETCH      _BIT(2)
+
+/**********************************************************************
+* Register description of POWERMODE
+**********************************************************************/
+#define CGU_POWERMODE_MASK     0x3
+#define CGU_POWERMODE_NORMAL   0x1
+#define CGU_POWERMODE_WAKEUP   0x3
+
+/**********************************************************************
+* Register description of WD_BARK
+**********************************************************************/
+#define CGU_WD_BARK            0x1
+
+/**********************************************************************
+* Register description of FFAST_ON
+**********************************************************************/
+#define CGU_FFAST_ON           0x1
+
+/**********************************************************************
+* Register description of FFAST_BYPASS
+**********************************************************************/
+#define CGU_FFAST_BYPASS       0x1
+
+/**********************************************************************
+* Register description of soft reset registers
+**********************************************************************/
+#define CGU_CONFIG_SOFT_RESET  0x1
+
+/**********************************************************************
+* Register description of HPll REGISTERS
+**********************************************************************/
+//#define CGU_HPLL0_ID      0
+//#define CGU_HPLL1_ID      1
+
+/**********************************************************************
+* Register description of HP_FIN_SELECT
+**********************************************************************/
+#define CGU_HPLL_FIN_SEL_MASK         0xf
+#define CGU_FIN_SELECT_FFAST          0x0
+#define CGU_FIN_SELECT_XT_I2SRX_BCK0  0x1
+#define CGU_FIN_SELECT_XT_I2SRX_WS0   0x2
+#define CGU_FIN_SELECT_XT_I2SRX_BCK1  0x3
+#define CGU_FIN_SELECT_XT_I2SRX_WS1   0x4
+#define CGU_FIN_SELECT_HPPLL0         0x5
+#define CGU_FIN_SELECT_HPPLL1         0x6
+#define CGU_FIN_SELECT_MAX            7
+
+/**********************************************************************
+* Register description of HP_MDEC
+**********************************************************************/
+#define CGU_HPLL_MDEC_MASK          0x1ffff
+/**********************************************************************
+* Register description of HP_NDEC
+**********************************************************************/
+#define CGU_HPLL_NDEC_MSK           0x3ff
+/**********************************************************************
+* Register description of HP_PDEC
+**********************************************************************/
+#define CGU_HPLL_PDEC_MSK           0x7f
+/**********************************************************************
+* Register description of HP_MODE
+**********************************************************************/
+#define CGU_HPLL_MODE_POR_VAL       0x6
+#define CGU_HPLL_MODE_CLKEN         _BIT(0)
+#define CGU_HPLL_MODE_SKEWEN        _BIT(1)
+#define CGU_HPLL_MODE_PD            _BIT(2)
+#define CGU_HPLL_MODE_DIRECTO       _BIT(3)
+#define CGU_HPLL_MODE_DIRECTI       _BIT(4)
+#define CGU_HPLL_MODE_FRM           _BIT(5)
+#define CGU_HPLL_MODE_BANDSEL       _BIT(6)
+#define CGU_HPLL_MODE_LIMUP_OFF     _BIT(7)
+#define CGU_HPLL_MODE_BYPASS        _BIT(8)
+
+/**********************************************************************
+* Register description of HP1_STATUS
+**********************************************************************/
+#define CGU_HPLL_STATUS_FR          _BIT(1)
+#define CGU_HPLL_STATUS_LOCK        _BIT(0)
+
+/**********************************************************************
+* Register description of HP_ACK & HP_REQ
+**********************************************************************/
+#define CGU_HPLL_ACK_P              _BIT(2)
+#define CGU_HPLL_ACK_N              _BIT(1)
+#define CGU_HPLL_ACK_M              _BIT(0)
+
+/**********************************************************************
+* Register description of HP1_INSELR
+**********************************************************************/
+#define CGU_HPLL_INSELR_MASK        0xf
+/**********************************************************************
+* Register description of HP1_INSELI
+**********************************************************************/
+#define CGU_HPLL_INSELI_MASK        0x3f
+/**********************************************************************
+* Register description of HP1_INSELP
+**********************************************************************/
+#define CGU_HPLL_INSELP_MASK        0x1f
+/**********************************************************************
+* Register description of HP1_SELR
+**********************************************************************/
+#define CGU_HPLL_SELR_MASK          0xf
+/**********************************************************************
+* Register description of HP1_SELI
+**********************************************************************/
+#define CGU_HPLL_SELI_MASK          0x3f
+/**********************************************************************
+* Register description of HP1_SELP
+**********************************************************************/
+#define CGU_HPLL_SELP_MASK          0x1f
+
+/***********************************************************************
+* Clock domain base id's
+***********************************************************************/
+typedef enum
+{
+  CGU_SB_SYS_BASE_ID = 0,
+  CGU_SB_BASE_FIRST = CGU_SB_SYS_BASE_ID,
+  CGU_SB_AHB0_APB0_BASE_ID,
+  CGU_SB_AHB0_APB1_BASE_ID,
+  CGU_SB_AHB0_APB2_BASE_ID,
+  CGU_SB_AHB0_APB3_BASE_ID,
+  CGU_SB_PCM_BASE_ID,
+  CGU_SB_UART_BASE_ID,
+  CGU_SB_CLK1024FS_BASE_ID,
+  CGU_SB_I2SRX_BCK0_BASE_ID,
+  CGU_SB_I2SRX_BCK1_BASE_ID,
+  CGU_SB_SPI_CLK_BASE_ID,
+  CGU_SB_SYSCLK_O_BASE_ID,
+  CGU_SB_BASE_LAST = CGU_SB_SYSCLK_O_BASE_ID
+} CGU_DOMAIN_ID_T;
+
+/***********************************************************************
+// Clock id's (= clkid in address calculation)
+***********************************************************************/
+typedef enum
+{
+  /* domain 0 = SYS_BASE */
+  CGU_SB_APB0_CLK_ID = 0,
+  CGU_SYS_FIRST = CGU_SB_APB0_CLK_ID,
+  CGU_SB_APB1_CLK_ID,
+  CGU_SB_APB2_CLK_ID,
+  CGU_SB_APB3_CLK_ID,
+  CGU_SB_APB4_CLK_ID,
+  CGU_SB_AHB2INTC_CLK_ID,
+  CGU_SB_AHB0_CLK_ID,
+  CGU_SB_EBI_CLK_ID,
+  CGU_SB_DMA_PCLK_ID,
+  CGU_SB_DMA_CLK_GATED_ID,
+  CGU_SB_NANDFLASH_S0_CLK_ID,
+  CGU_SB_NANDFLASH_ECC_CLK_ID,
+  CGU_SB_NANDFLASH_AES_CLK_ID, /* valid on LPC3153 & LPC3154 only */
+  CGU_SB_NANDFLASH_NAND_CLK_ID,
+  CGU_SB_NANDFLASH_PCLK_ID,
+  CGU_SB_CLOCK_OUT_ID,
+  CGU_SB_ARM926_CORE_CLK_ID,
+  CGU_SB_ARM926_BUSIF_CLK_ID,
+  CGU_SB_ARM926_RETIME_CLK_ID,
+  CGU_SB_SD_MMC_HCLK_ID,
+  CGU_SB_SD_MMC_CCLK_IN_ID,
+  CGU_SB_USB_OTG_AHB_CLK_ID,
+  CGU_SB_ISRAM0_CLK_ID,
+  CGU_SB_RED_CTL_RSCLK_ID,
+  CGU_SB_ISRAM1_CLK_ID,
+  CGU_SB_ISROM_CLK_ID,
+  CGU_SB_MPMC_CFG_CLK_ID,
+  CGU_SB_MPMC_CFG_CLK2_ID,
+  CGU_SB_MPMC_CFG_CLK3_ID,
+  CGU_SB_INTC_CLK_ID,
+  CGU_SYS_LAST = CGU_SB_INTC_CLK_ID,
+
+  /* domain 1 = AHB0APB0_BASE */
+  CGU_SB_AHB2APB0_ASYNC_PCLK_ID,
+  CGU_AHB0APB0_FIRST = CGU_SB_AHB2APB0_ASYNC_PCLK_ID,
+  CGU_SB_EVENT_ROUTER_PCLK_ID,
+  CGU_SB_ADC_PCLK_ID,
+  CGU_SB_ADC_CLK_ID,
+  CGU_SB_WDOG_PCLK_ID,
+  CGU_SB_IOCONF_PCLK_ID,
+  CGU_SB_CGU_PCLK_ID,
+  CGU_SB_SYSCREG_PCLK_ID,
+  CGU_SB_OTP_PCLK_ID, /* valid on LPC315x series only */
+  CGU_SB_RNG_PCLK_ID,
+  CGU_AHB0APB0_LAST = CGU_SB_RNG_PCLK_ID,
+
+
+  /* domain 2 = AHB0APB1_BASE */
+  CGU_SB_AHB2APB1_ASYNC_PCLK_ID,
+  CGU_AHB0APB1_FIRST = CGU_SB_AHB2APB1_ASYNC_PCLK_ID,
+  CGU_SB_TIMER0_PCLK_ID,
+  CGU_SB_TIMER1_PCLK_ID,
+  CGU_SB_TIMER2_PCLK_ID,
+  CGU_SB_TIMER3_PCLK_ID,
+  CGU_SB_PWM_PCLK_ID,
+  CGU_SB_PWM_PCLK_REGS_ID,
+  CGU_SB_PWM_CLK_ID,
+  CGU_SB_I2C0_PCLK_ID,
+  CGU_SB_I2C1_PCLK_ID,
+  CGU_AHB0APB1_LAST = CGU_SB_I2C1_PCLK_ID,
+
+  /* domain 3 = AHB0APB2_BASE */
+  CGU_SB_AHB2APB2_ASYNC_PCLK_ID,
+  CGU_AHB0APB2_FIRST = CGU_SB_AHB2APB2_ASYNC_PCLK_ID,
+  CGU_SB_PCM_PCLK_ID,
+  CGU_SB_PCM_APB_PCLK_ID,
+  CGU_SB_UART_APB_CLK_ID,
+  CGU_SB_LCD_PCLK_ID,
+  CGU_SB_LCD_CLK_ID,
+  CGU_SB_SPI_PCLK_ID,
+  CGU_SB_SPI_PCLK_GATED_ID,
+  CGU_AHB0APB2_LAST = CGU_SB_SPI_PCLK_GATED_ID,
+
+  /* domain 4 = AHB0APB3_BASE */
+  CGU_SB_AHB2APB3_ASYNC_PCLK_ID,
+  CGU_AHB0APB3_FIRST = CGU_SB_AHB2APB3_ASYNC_PCLK_ID,
+  CGU_SB_I2S_CFG_PCLK_ID,
+  CGU_SB_EDGE_DET_PCLK_ID,
+  CGU_SB_I2STX_FIFO_0_PCLK_ID,
+  CGU_SB_I2STX_IF_0_PCLK_ID,
+  CGU_SB_I2STX_FIFO_1_PCLK_ID,
+  CGU_SB_I2STX_IF_1_PCLK_ID,
+  CGU_SB_I2SRX_FIFO_0_PCLK_ID,
+  CGU_SB_I2SRX_IF_0_PCLK_ID,
+  CGU_SB_I2SRX_FIFO_1_PCLK_ID,
+  CGU_SB_I2SRX_IF_1_PCLK_ID,
+  CGU_SB_RSVD69_ID,
+  CGU_SB_AHB2APB3_RSVD_ID,
+  CGU_AHB0APB3_LAST = CGU_SB_AHB2APB3_RSVD_ID,
+
+  /* domain 5 = PCM_BASE */
+  CGU_SB_PCM_CLK_IP_ID,
+  CGU_PCM_FIRST = CGU_SB_PCM_CLK_IP_ID,
+  CGU_PCM_LAST = CGU_SB_PCM_CLK_IP_ID,
+
+  /* domain 6 = UART_BASE */
+  CGU_SB_UART_U_CLK_ID,
+  CGU_UART_FIRST = CGU_SB_UART_U_CLK_ID,
+  CGU_UART_LAST = CGU_SB_UART_U_CLK_ID,
+
+  /* domain 7 = CLK1024FS_BASE */
+  CGU_SB_I2S_EDGE_DETECT_CLK_ID,
+  CGU_CLK1024FS_FIRST = CGU_SB_I2S_EDGE_DETECT_CLK_ID,
+  CGU_SB_I2STX_BCK0_N_ID,
+  CGU_SB_I2STX_WS0_ID,
+  CGU_SB_I2STX_CLK0_ID,
+  CGU_SB_I2STX_BCK1_N_ID,
+  CGU_SB_I2STX_WS1_ID,
+  CGU_SB_CLK_256FS_ID,
+  CGU_SB_I2SRX_BCK0_N_ID,
+  CGU_SB_I2SRX_WS0_ID,
+  CGU_SB_I2SRX_BCK1_N_ID,
+  CGU_SB_I2SRX_WS1_ID,
+  CGU_SB_RSVD84_ID,
+  CGU_SB_RSVD85_ID,
+  CGU_SB_RSVD86_ID,
+  CGU_CLK1024FS_LAST = CGU_SB_RSVD86_ID,
+
+  /* domain 8 = BCK0_BASE */
+  CGU_SB_I2SRX_BCK0_ID,
+  CGU_I2SRX_BCK0_FIRST = CGU_SB_I2SRX_BCK0_ID,
+  CGU_I2SRX_BCK0_LAST = CGU_SB_I2SRX_BCK0_ID,
+
+  /* domain 9 = BCK1_BASE */
+  CGU_SB_I2SRX_BCK1_ID,
+  CGU_I2SRX_BCK1_FIRST = CGU_SB_I2SRX_BCK1_ID,
+  CGU_I2SRX_BCK1_LAST = CGU_SB_I2SRX_BCK1_ID,
+
+  /* domain 10 = SPI_BASE */
+  CGU_SB_SPI_CLK_ID,
+  CGU_SPI_FIRST = CGU_SB_SPI_CLK_ID,
+  CGU_SB_SPI_CLK_GATED_ID,
+  CGU_SPI_LAST = CGU_SB_SPI_CLK_GATED_ID,
+
+  /* domain 11 = SYSCLKO_BASE */
+  CGU_SB_SYSCLK_O_ID,
+  CGU_SYSCLK_O_FIRST = CGU_SB_SYSCLK_O_ID,
+  CGU_SYSCLK_O_LAST = CGU_SB_SYSCLK_O_ID,
+
+  CGU_SB_INVALID_CLK_ID = -1
+} CGU_CLOCK_ID_T;
+
+
+/***********************************************************************
+* CGU driver defines - MACROS & constants
+**********************************************************************/
+#define CGU_INVALID_ID  0xFFFF
+
+/* Following clocks are enabled after init.
+CGU_DEF_CLKS_0_31 contains bits for clocks with id between 0 & 31
+CGU_DEF_CLKS_32_63 contains bits for clocks with id between 32 & 63
+CGU_DEF_CLKS_64_92 contains bits for clocks with id between 64 & 92
+*/
+#define CGU_DEF_CLKS_0_31   ( _BIT(CGU_SB_APB0_CLK_ID) | _BIT(CGU_SB_APB1_CLK_ID) | \
+                              _BIT(CGU_SB_APB2_CLK_ID) | _BIT(CGU_SB_APB3_CLK_ID) |_BIT(CGU_SB_APB4_CLK_ID) | \
+                              _BIT(CGU_SB_AHB2INTC_CLK_ID) | _BIT(CGU_SB_AHB0_CLK_ID) | \
+                              _BIT(CGU_SB_ARM926_CORE_CLK_ID) | _BIT(CGU_SB_ARM926_BUSIF_CLK_ID) | \
+                              _BIT(CGU_SB_ARM926_RETIME_CLK_ID) | _BIT(CGU_SB_ISRAM0_CLK_ID) | \
+                              _BIT(CGU_SB_ISRAM1_CLK_ID) | _BIT(CGU_SB_ISROM_CLK_ID) | \
+                              _BIT(CGU_SB_INTC_CLK_ID) | _BIT(CGU_SB_AHB2APB0_ASYNC_PCLK_ID) | \
+                              _BIT(CGU_SB_EVENT_ROUTER_PCLK_ID) | _BIT(CGU_SB_CLOCK_OUT_ID))
+
+#if defined(CONFIG_HAS_ANALOG_DIE)
+#define CGU_DEF_CLKS_32_63 ( _BIT(CGU_SB_IOCONF_PCLK_ID - 32) | _BIT(CGU_SB_CGU_PCLK_ID - 32) | \
+                             _BIT(CGU_SB_SYSCREG_PCLK_ID - 32) | _BIT(CGU_SB_OTP_PCLK_ID - 32) | \
+                             _BIT(CGU_SB_AHB2APB1_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_AHB2APB2_ASYNC_PCLK_ID - 32) | \
+                             _BIT(CGU_SB_AHB2APB3_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_TIMER1_PCLK_ID - 32) | \
+                             _BIT(CGU_SB_I2C1_PCLK_ID - 32))
+#define CGU_DEF_CLKS_64_92 (_BIT(CGU_SB_SYSCLK_O_ID - 64))
+#else
+#define CGU_DEF_CLKS_32_63 ( _BIT(CGU_SB_IOCONF_PCLK_ID - 32) | _BIT(CGU_SB_CGU_PCLK_ID - 32) | \
+                             _BIT(CGU_SB_SYSCREG_PCLK_ID - 32) | _BIT(CGU_SB_OTP_PCLK_ID - 32) | \
+                             _BIT(CGU_SB_AHB2APB1_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_AHB2APB2_ASYNC_PCLK_ID - 32) | \
+                             _BIT(CGU_SB_AHB2APB3_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_TIMER1_PCLK_ID - 32))
+#define CGU_DEF_CLKS_64_92 (0)
+#endif
+
+
+/* Following macros are used to define clocks belonging to different
+   sub-domains with-in each domain. */
+#define D0_BIT(clkid)   _BIT(clkid)
+#define D1_BIT(clkid)   _BIT((clkid) - CGU_AHB0APB0_FIRST)
+#define D2_BIT(clkid)   _BIT((clkid) - CGU_AHB0APB1_FIRST)
+#define D3_BIT(clkid)   _BIT((clkid) - CGU_AHB0APB2_FIRST)
+#define D4_BIT(clkid)   _BIT((clkid) - CGU_AHB0APB3_FIRST)
+#define D5_BIT(clkid)   _BIT((clkid) - CGU_PCM_FIRST)
+#define D6_BIT(clkid)   _BIT((clkid) - CGU_UART_FIRST)
+#define D7_BIT(clkid)   _BIT((clkid) - CGU_CLK1024FS_FIRST)
+/* 8 & 9 have one clk per domain so no macros */
+#define D10_BIT(clkid)  _BIT((clkid) - CGU_SPI_FIRST)
+
+
+/***********************************************************************
+* CGU driver enumerations
+**********************************************************************/
+/* Possible HPLL ids */
+typedef enum {CGU_HPLL0_ID, CGU_HPLL1_ID} CGU_HPLL_ID_T;
+
+/* CGU soft reset module ID enumerations */
+typedef enum
+{
+  APB0_RST_SOFT = 0,
+  AHB2APB0_PNRES_SOFT,
+  APB1_RST_SOFT,
+  AHB2APB1_PNRES_SOFT,
+  APB2_RESETN_SOFT,
+  AHB2APB2_PNRES_SOFT,
+  APB3_RESETN_SOFT,
+  AHB2APB3_PNRES_SOFT,
+  APB4_RESETN_SOFT,
+  AHB2INTC_RESETN_SOFT,
+  AHB0_RESETN_SOFT,
+  EBI_RESETN_SOFT,
+  PCM_PNRES_SOFT,
+  PCM_RESET_N_SOFT,
+  PCM_RESET_ASYNC_N_SOFT,
+  TIMER0_PNRES_SOFT,
+  TIMER1_PNRES_SOFT,
+  TIMER2_PNRES_SOFT,
+  TIMER3_PNRES_SOFT,
+  ADC_PRESETN_SOFT,
+  ADC_RESETN_ADC10BITS_SOFT,
+  PWM_RESET_AN_SOFT,
+  UART_SYS_RST_AN_SOFT,
+  I2C0_PNRES_SOFT,
+  I2C1_PNRES_SOFT,
+  I2S_CFG_RST_N_SOFT,
+  I2S_NSOF_RST_N_SOFT,
+  EDGE_DET_RST_N_SOFT,
+  I2STX_FIFO_0_RST_N_SOFT,
+  I2STX_IF_0_RST_N_SOFT,
+  I2STX_FIFO_1_RST_N_SOFT,
+  I2STX_IF_1_RST_N_SOFT,
+  I2SRX_FIFO_0_RST_N_SOFT,
+  I2SRX_IF_0_RST_N_SOFT,
+  I2SRX_FIFO_1_RST_N_SOFT,
+  I2SRX_IF_1_RST_N_SOFT,
+
+  LCD_INTERFACE_PNRES_SOFT = I2SRX_IF_1_RST_N_SOFT + 6,
+  SPI_PNRES_APB_SOFT,
+  SPI_PNRES_IP_SOFT,
+  DMA_PNRES_SOFT,
+  NANDFLASH_ECC_RESET_N_SOFT,
+  NANDFLASH_AES_RESET_N_SOFT,
+  NANDFLASH_NAND_RESET_N_SOFT,
+  RNG_RESETN_SOFT,
+  SD_MMC_PNRES_SOFT,
+  SD_MMC_NRES_CCLK_IN_SOFT,
+  USB_OTG_AHB_RST_N_SOFT,
+  RED_CTL_RESET_N_SOFT,
+  AHB_MPMC_HRESETN_SOFT,
+  AHB_MPMC_REFRESH_RESETN_SOFT,
+  INTC_RESETN_SOFT
+} CGU_MOD_ID_T;
+
+/***********************************************************************
+* CGU driver structures
+**********************************************************************/
+/* CGU HPLL config settings structure type */
+typedef struct
+{
+  u32 fin_select;
+  u32 ndec;
+  u32 mdec;
+  u32 pdec;
+  u32 selr;
+  u32 seli;
+  u32 selp;
+  u32 mode;
+  u32 freq; /* in MHz for driver internal data */
+} CGU_HPLL_SETUP_T;
+
+/* CGU fractional divider settings structure type */
+typedef struct
+{
+  u8 stretch; /* Fractional divider stretch enable. */
+  u8 n;       /* Fractional divider nominal nominator */
+  u16 m;      /* Fractional divider nominal denominator */
+} CGU_FDIV_SETUP_T;
+
+/* CGU clocks state */
+typedef struct
+{
+  u32 clks_0_31;
+  u32 clks_32_63;
+  u32 clks_64_92;
+} CGU_CLKS_STATE_T;
+
+/* CGU sub-domain settings structure type */
+typedef struct
+{
+  CGU_FDIV_SETUP_T fdiv_cfg;  /* Fractional divider settings */
+  u32 clks; /* all clocks belonging to the sub-domain */
+} CGU_SUB_DOMAIN_CFG_T;
+
+/* CGU domain settings structure type */
+typedef struct
+{
+  CGU_DOMAIN_ID_T id;
+  u32 fin_sel;
+  u32 clk_min;
+  u32 clk_cnt;
+  u32 fdiv_min;
+  u32 fdiv_cnt;
+  CGU_SUB_DOMAIN_CFG_T* sub;  /* pointer to array */
+} CGU_DOMAIN_CFG_T;
+
+/* CGU clks initilisation structure */
+typedef struct
+{
+  struct _DOMAIN0_T
+  {
+    u32 fin_sel;
+    CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE0_FDIV_CNT];
+  } domain0;
+
+  struct _DOMAIN1_T
+  {
+    u32 fin_sel;
+    CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE1_FDIV_CNT];
+  } domain1;
+
+  struct _DOMAIN2_T
+  {
+    u32 fin_sel;
+    CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE2_FDIV_CNT];
+  } domain2;
+
+  struct _DOMAIN3_T
+  {
+    u32 fin_sel;
+    CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE3_FDIV_CNT];
+  } domain3;
+
+  struct _DOMAIN4_T
+  {
+    u32 fin_sel;
+    CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE4_FDIV_CNT];
+  } domain4;
+
+  struct _DOMAIN5_T
+  {
+    u32 fin_sel;
+    CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE5_FDIV_CNT];
+  } domain5;
+
+  struct _DOMAIN6_T
+  {
+    u32 fin_sel;
+    CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE6_FDIV_CNT];
+  } domain6;
+
+  struct _DOMAIN7_T
+  {
+    u32 fin_sel;
+    CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE7_FDIV_CNT];
+  } domain7;
+
+  struct _DOMAIN8_T
+  {
+    u32 fin_sel;
+  } domain8;
+
+  struct _DOMAIN9_T
+  {
+    u32 fin_sel;
+  } domain9;
+
+  struct _DOMAIN10_T
+  {
+    u32 fin_sel;
+    CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE10_FDIV_CNT];
+  } domain10;
+
+  struct _DOMAIN11_T
+  {
+    u32 fin_sel;
+  } domain11;
+
+  struct _DYN_FDIV_CFG_T
+  {
+    u32  sel;
+    CGU_FDIV_SETUP_T cfg;
+  } dyn_fdiv_cfg[CGU_SB_NR_DYN_FDIV];
+} CGU_CLKS_INIT_T;
+
+/***********************************************************************
+* CGU driver functions
+**********************************************************************/
+/* init CGU module */
+void cgu_init(void);
+
+/* Reset all clocks to be sourced from FFAST.  */
+void cgu_reset_all_clks(void);
+
+/* Initialize all clocks at startup using the defaults structure */
+int cgu_init_clks(const CGU_CLKS_INIT_T* pClksCfg);
+
+/* Return the current base frequecy of the requested domain*/
+int cgu_get_base_freq(CGU_DOMAIN_ID_T baseid);
+
+/* Change the base frequency for the requested domain */
+void cgu_set_base_freq(CGU_DOMAIN_ID_T baseid, u32 fin_sel);
+
+/* Return the current frequecy of the requested clock*/
+u32 cgu_get_clk_freq(CGU_CLOCK_ID_T clkid);
+
+/* Change the sub-domain frequency for the requested clock */
+void cgu_set_subdomain_freq(CGU_CLOCK_ID_T clkid, CGU_FDIV_SETUP_T fdiv_cfg);
+
+/* Configure the selected HPLL */
+void cgu_hpll_config(CGU_HPLL_ID_T id, CGU_HPLL_SETUP_T* pllsetup);
+
+/* Get selected HPLL status */
+u32 cgu_hpll_status(CGU_HPLL_ID_T id);
+
+/* Issue a software reset to the requested module */
+void cgu_soft_reset_module(CGU_MOD_ID_T mod);
+
+/* enable / disable external enabling of the requested clock in CGU */
+void cgu_clk_set_exten(CGU_CLOCK_ID_T clkid, u32 enable);
+
+
+/***********************************************************************
+* CGU driver inline (ANSI C99 based) functions
+**********************************************************************/
+/* enable / disable the requested clock in CGU */
+static inline void cgu_clk_en_dis(CGU_CLOCK_ID_T clkid, u32 enable)
+{
+  if (enable)
+  {
+    CGU_SB->clk_pcr[clkid] |= CGU_SB_PCR_RUN;
+  }
+  else
+  {
+    CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_RUN;
+  }
+
+}
+
+/***********************************************************************
+* CGU driver exported global data
+**********************************************************************/
+extern const CGU_CLKS_INIT_T g_cgu_default_clks;
+
+#endif /* LPC313X_CGU_DRIVER_H */
diff -purN apex-1.6.8/src/mach-lpc313x/lpc313x.h work_1.6.8/src/mach-lpc313x/lpc313x.h
--- apex-1.6.8/src/mach-lpc313x/lpc313x.h	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/lpc313x.h	2010-03-15 14:28:20.000000000 -0700
@@ -0,0 +1,754 @@
+/* lpc313x.h
+
+   written by Durgesh Pattamatta
+   10 Oct 2008
+
+   Copyright (C) 2008 NXP Semiconductors
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+   -----------
+   DESCRIPTION
+   -----------
+
+*/
+
+#if !defined (__LPC313X_H__)
+#    define   __LPC313X_H__
+
+/* ----- Includes */
+#include <apex.h>
+
+#include <asm/reg.h>
+
+/* ----- Types */
+
+/* ----- Globals */
+#define _BIT(n)	  ((1) << (n))
+/* shift bit field */
+#define _SBF(f,v) ((v) << (f))
+
+/* ----- Prototypes */
+
+	/* Registers */
+/***********************************************************************
+ * WDT register definitions
+ **********************************************************************/
+#define WDT_PHYS      (0x13002400)
+#define WDT_IR       __REG (WDT_PHYS + 0x00)
+#define WDT_TCR      __REG (WDT_PHYS + 0x04)
+#define WDT_TC       __REG (WDT_PHYS + 0x08)
+#define WDT_PR       __REG (WDT_PHYS + 0x0c)
+#define WDT_MCR      __REG (WDT_PHYS + 0x14)
+#define WDT_MR0      __REG (WDT_PHYS + 0x18)
+#define WDT_MR1      __REG (WDT_PHYS + 0x1c)
+#define WDT_EMR      __REG (WDT_PHYS + 0x3c)
+
+#define WDT_IR_MR1        _BIT(1)
+#define WDT_IR_MR0        _BIT(0)
+#define WDT_TCR_CNT_RESET _BIT(1)
+#define WDT_TCR_CNT_EN    _BIT(0)
+#define WDT_MCR_STOP_MR1  _BIT(5)
+#define WDT_MCR_RESET_MR1 _BIT(4)
+#define WDT_MCR_INT_MR1   _BIT(3)
+#define WDT_MCR_STOP_MR0  _BIT(2)
+#define WDT_MCR_RESET_MR0 _BIT(1)
+#define WDT_MCR_INT_MR0   _BIT(0)
+#define WDT_EMR_CTRL0(n)  _SBF(4,((n) &0x3))
+#define WDT_EMR_CTRL1(n)  _SBF(6,((n) &0x3))
+#define WDT_EMR_M1        _BIT(1)
+#define WDT_EMR_M0        _BIT(0)
+
+/***********************************************************************
+ * Timer register definitions
+ **********************************************************************/
+#define TIMER0_PHYS     (0x13008000)
+#define TIMER1_PHYS     (0x13008400)
+#define TIMER2_PHYS     (0x13008800)
+#define TIMER3_PHYS     (0x13008c00)
+#define TIMER_LOAD      0x00
+#define TIMER_VALUE     0x04
+#define TIMER_CONTROL   0x08
+#define TIMER_CLEAR     0x0c
+
+#define TM_CTRL_ENABLE    _BIT(7)
+#define TM_CTRL_MODE      _BIT(6)
+#define TM_CTRL_PERIODIC  _BIT(6)
+#define TM_CTRL_PS1       _SBF(2, 0)
+#define TM_CTRL_PS16      _SBF(2, 1)
+#define TM_CTRL_PS256     _SBF(2, 2)
+#define TM_CTRL_PS_MASK   _SBF(2, 0x3)
+
+/***********************************************************************
+ * UART register definitions
+ **********************************************************************/
+#define UART_PHYS     (0x15001000)
+#define UART_DLL      __REG (UART_PHYS + 0x00)
+#define UART_FIFO     __REG (UART_PHYS + 0x00)
+#define UART_IE       __REG (UART_PHYS + 0x04)
+#define UART_DLM      __REG (UART_PHYS + 0x04)
+#define UART_IIR      __REG (UART_PHYS + 0x08)
+#define UART_FCR      __REG (UART_PHYS + 0x08)
+#define UART_LCR      __REG (UART_PHYS + 0x0c)
+#define UART_MCR      __REG (UART_PHYS + 0x10)
+#define UART_LSR      __REG (UART_PHYS + 0x14)
+#define UART_MSR      __REG (UART_PHYS + 0x18)
+#define UART_SCR      __REG (UART_PHYS + 0x1c)
+#define UART_ACR      __REG (UART_PHYS + 0x20)
+#define UART_ICR      __REG (UART_PHYS + 0x24)
+#define UART_FDR      __REG (UART_PHYS + 0x28)
+
+
+#define UART_LOAD_DLL(div)          ((div) & 0xFF)
+#define UART_LOAD_DLM(div)          (((div) >> 8) & 0xFF)
+#define UART_LCR_DIVLATCH_EN       _BIT(7)
+#define UART_LCR_WLEN_8BITS        _SBF(0, 3)
+#define UART_FCR_DMA_MODE          _BIT(3)
+#define UART_FCR_TXFIFO_FLUSH      _BIT(2)
+#define UART_FCR_RXFIFO_FLUSH      _BIT(1)
+#define UART_FCR_FIFO_EN           _BIT(0)
+#define UART_LSR_FIFORX_ERR        _BIT(7)
+#define UART_LSR_TEMT              _BIT(6)
+#define UART_LSR_FR                _BIT(3)
+#define UART_LSR_PE                _BIT(2)
+#define UART_LSR_OE                _BIT(1)
+#define UART_LSR_RDR               _BIT(0)
+
+/***********************************************************************
+ * SYS_REG register definitions
+ **********************************************************************/
+#define SYS_PHYS            (0x13002800)
+#define SYS_SDMMC_DELAYMODES   __REG (SYS_PHYS + 0x2C)
+#define SYS_USB_ATX_PLL_PD_REG __REG (SYS_PHYS + 0x30)
+#define SYS_USB_OTG_CFG        __REG (SYS_PHYS + 0x34)
+#define SYS_USB_OTG_LED_CTL    __REG (SYS_PHYS + 0x38)
+#define SYS_USB_PLL_NDEC       __REG (SYS_PHYS + 0x40)
+#define SYS_USB_PLL_MDEC       __REG (SYS_PHYS + 0x44)
+#define SYS_USB_PLL_PDEC       __REG (SYS_PHYS + 0x48)
+#define SYS_USB_PLL_SELR       __REG (SYS_PHYS + 0x4C)
+#define SYS_USB_PLL_SELI       __REG (SYS_PHYS + 0x50)
+#define SYS_USB_PLL_SELP       __REG (SYS_PHYS + 0x54)
+
+#define SYS_MPMC_DELAY      __REG (SYS_PHYS + 0x68)
+#define SYS_MPMC_WTD_DEL0   __REG (SYS_PHYS + 0x6C)
+#define SYS_MPMC_WTD_DEL1   __REG (SYS_PHYS + 0x70)
+#define SYS_MPMC_TESTMODE0  __REG (SYS_PHYS + 0x78)
+#define SYS_MPMC_TESTMODE1  __REG (SYS_PHYS + 0x7C)
+#define SYS_REMAP_ADDR      __REG (SYS_PHYS + 0x84)
+#define SYS_MUX_LCD_EBI     __REG (SYS_PHYS + 0x90)
+#define SYS_MUX_GPIO_MCI    __REG (SYS_PHYS + 0x94)
+#define SYS_MUX_NAND_MCI    __REG (SYS_PHYS + 0x98)
+
+/***********************************************************************
+ * GPIO register definitions
+ **********************************************************************/
+#define GPIO_PHYS            (0x13003000)
+#define GPIO_STATE(port)     __REG (GPIO_PHYS + (port) + 0x00)
+#define GPIO_M0_SET(port)    __REG (GPIO_PHYS + (port) + 0x14)
+#define GPIO_M0_RESET(port)  __REG (GPIO_PHYS + (port) + 0x18)
+#define GPIO_M1_SET(port)    __REG (GPIO_PHYS + (port) + 0x24)
+#define GPIO_M1_RESET(port)  __REG (GPIO_PHYS + (port) + 0x28)
+
+#define GPIO_OUT_LOW(port, pin)  do { GPIO_M1_SET(port) = pin; GPIO_M0_RESET(port) = pin;} while(0)
+#define GPIO_OUT_HIGH(port, pin) do { GPIO_M1_SET(port) = pin; GPIO_M0_SET(port) = pin;} while(0)
+#define GPIO_IN(port, pin)       do { GPIO_M1_RESET(port) = pin; GPIO_M0_RESET(port) = pin;} while(0)
+#define GPIO_DRV_IP(port, pin)   do { GPIO_M1_RESET(port) = pin; GPIO_M0_SET(port) = pin;} while(0)
+
+#define IOCONF_EBI_MCI       (0x000)
+#define IOCONF_EBI_I2STX_0   (0x040)
+#define IOCONF_CGU           (0x080)
+#define IOCONF_I2SRX_0       (0x0c0)
+#define IOCONF_I2SRX_1       (0x100)
+#define IOCONF_I2STX_1       (0x140)
+#define IOCONF_EBI           (0x180)
+#define IOCONF_GPIO          (0x1c0)
+#define IOCONF_I2C1          (0x200)
+#define IOCONF_SPI           (0x240)
+#define IOCONF_NAND_CTRL     (0x280)
+#define IOCONF_PWM           (0x2c0)
+#define IOCONF_UART          (0x300)
+
+/***********************************************************************
+ * Event router register definitions
+ **********************************************************************/
+#define EVTR_PHYS            (0x13000000)
+#define EVRT_INT_PEND(bank)  __REG (EVTR_PHYS + 0xC00 + ((bank) << 2))
+#define EVRT_INT_CLR(bank)   __REG (EVTR_PHYS + 0xC20 + ((bank) << 2))
+#define EVRT_INT_SET(bank)   __REG (EVTR_PHYS + 0xC40 + ((bank) << 2))
+#define EVRT_MASK(bank)      __REG (EVTR_PHYS + 0xC60 + ((bank) << 2))
+#define EVRT_MASK_CLR(bank)  __REG (EVTR_PHYS + 0xC80 + ((bank) << 2))
+#define EVRT_MASK_SET(bank)  __REG (EVTR_PHYS + 0xCA0 + ((bank) << 2))
+#define EVRT_APR(bank)       __REG (EVTR_PHYS + 0xCC0 + ((bank) << 2))
+#define EVRT_ATR(bank)       __REG (EVTR_PHYS + 0xCE0 + ((bank) << 2))
+#define EVRT_RSR(bank)       __REG (EVTR_PHYS + 0xD20 + ((bank) << 2))
+#define EVRT_OUT_PEND(vec,bank)     __REG (EVTR_PHYS + 0x1000 + ((vec) << 5) + ((bank) << 2))
+#define EVRT_OUT_MASK(vec,bank)     __REG (EVTR_PHYS + 0x1400 + ((vec) << 5) + ((bank) << 2))
+#define EVRT_OUT_MASK_CLR(vec,bank) __REG (EVTR_PHYS + 0x1800 + ((vec) << 5) + ((bank) << 2))
+#define EVRT_OUT_MASK_SET(vec,bank) __REG (EVTR_PHYS + 0x1C00 + ((vec) << 5) + ((bank) << 2))
+
+/***********************************************************************
+ * MPMC memory controller register definitions
+ **********************************************************************/
+#define MPMC_PHYS           (0x17008000)
+#define MPMC_CTRL           __REG (MPMC_PHYS + 0x000)
+#define MPMC_STATUS         __REG (MPMC_PHYS + 0x004)
+#define MPMC_CONFIG         __REG (MPMC_PHYS + 0x008)
+#define MPMC_DYNCTL         __REG (MPMC_PHYS + 0x020)
+#define MPMC_DYNREF         __REG (MPMC_PHYS + 0x024)
+#define MPMC_DYRDCFG        __REG (MPMC_PHYS + 0x028)
+#define MPMC_DYTRP          __REG (MPMC_PHYS + 0x030)
+#define MPMC_DYTRAS         __REG (MPMC_PHYS + 0x034)
+#define MPMC_DYTSREX        __REG (MPMC_PHYS + 0x038)
+#define MPMC_DYTAPR         __REG (MPMC_PHYS + 0x03C)
+#define MPMC_DYTDAL         __REG (MPMC_PHYS + 0x040)
+#define MPMC_DYTWR          __REG (MPMC_PHYS + 0x044)
+#define MPMC_DYTRC          __REG (MPMC_PHYS + 0x048)
+#define MPMC_DYTRFC         __REG (MPMC_PHYS + 0x04C)
+#define MPMC_DYTXSR         __REG (MPMC_PHYS + 0x050)
+#define MPMC_DYTRRD         __REG (MPMC_PHYS + 0x054)
+#define MPMC_DYTMRD         __REG (MPMC_PHYS + 0x058)
+#define MPMC_STEXDWT        __REG (MPMC_PHYS + 0x080)
+#define MPMC_DYCONFIG       __REG (MPMC_PHYS + 0x100)
+#define MPMC_DYRASCAS       __REG (MPMC_PHYS + 0x104)
+#define MPMC_STCONFIG0      __REG (MPMC_PHYS + 0x200)
+#define MPMC_STWTWEN0       __REG (MPMC_PHYS + 0x204)
+#define MPMC_STWTOEN0       __REG (MPMC_PHYS + 0x208)
+#define MPMC_STWTRD0        __REG (MPMC_PHYS + 0x20C)
+#define MPMC_STWTPG0        __REG (MPMC_PHYS + 0x210)
+#define MPMC_STWTWR0        __REG (MPMC_PHYS + 0x214)
+#define MPMC_STWTTURN0      __REG (MPMC_PHYS + 0x218)
+#define MPMC_STCONFIG1      __REG (MPMC_PHYS + 0x220)
+#define MPMC_STWTWEN1       __REG (MPMC_PHYS + 0x224)
+#define MPMC_STWTOEN1       __REG (MPMC_PHYS + 0x228)
+#define MPMC_STWTRD1        __REG (MPMC_PHYS + 0x22C)
+#define MPMC_STWTPG1        __REG (MPMC_PHYS + 0x230)
+#define MPMC_STWTWR1        __REG (MPMC_PHYS + 0x234)
+#define MPMC_STWTTURN1      __REG (MPMC_PHYS + 0x238)
+
+#define NS_TO_MPMCCLK(ns, clk)	(((ns)*((clk + 500)/1000) + 500000)/1000000)
+/* MPMC Controller Bit Field constants*/
+#define MPMC_CTL_LOW_PWR               _BIT(2)
+#define MPMC_CTL_ENABLE                _BIT(0)
+/* MPMC status Bit Field constants*/
+#define MPMC_STATUS_SA                 _BIT(2)
+#define MPMC_STATUS_WR_BUF             _BIT(1)
+#define MPMC_STATUS_BUSY               _BIT(0)
+/* MPMC config Bit Field constants*/
+#define MPMC_CFG_SDCCLK_1_2            _BIT(8)
+#define MPMC_CFG_SDCCLK_1_1            (0)
+/* SDRAM Controller Bit Field constants*/
+#define MPMC_SDRAMC_CTL_DP             _BIT(13)
+#define MPMC_SDRAMC_CTL_NORMAL_CMD     _SBF(7,0)
+#define MPMC_SDRAMC_CTL_MODE_CMD       _SBF(7,1)
+#define MPMC_SDRAMC_CTL_PALL_CMD       _SBF(7,2)
+#define MPMC_SDRAMC_CTL_NOP_CMD        _SBF(7,3)
+#define MPMC_SDRAMC_CTL_MCC            _BIT(5)
+#define MPMC_SDRAMC_CTL_SR             _BIT(2)
+#define MPMC_SDRAMC_CTL_CS             _BIT(1)
+#define MPMC_SDRAMC_CTL_CE             _BIT(0)
+/* SDRAM Config Bit Field constants*/
+#define MPMC_SDRAMC_CFG_SDRAM_MD       _SBF(3,0)
+#define MPMC_SDRAMC_CFG_LOW_PWR_MD     _SBF(3,1)
+#define MPMC_SDRAMC_CFG_SYNC_FLASH     _SBF(3,2)
+#define MPMC_SDRAMC_CFG_BUF_EN         _BIT(19)
+#define MPMC_SDRAMC_CFG_WP             _BIT(20)
+/*16-bit external bus high-performance address mapping */
+/*16Mb (2Mx8), 2 banks, row length = 11, column length = 9*/
+#define SDRAMC_16HP_2Mx8_2B_R11_C9    (_SBF(7,0x00))
+/*16Mb (1Mx16), 2 banks, row length = 11, column length = 8*/
+#define SDRAMC_16HP_1Mx16_2B_R11_C8   (_SBF(7,0x01))
+/*64Mb (8Mx8), 4 banks, row length = 12, column length = 9*/
+#define SDRAMC_16HP_8Mx8_4B_R12_C9    (_SBF(7,0x04))
+/*64Mb (4Mx16), 4 banks, row length = 12, column length = 8*/
+#define SDRAMC_16HP_4Mx16_4B_R12_C8   (_SBF(7,0x05))
+/*128Mb (16Mx8), 4 banks, row length = 12, column length = 10*/
+#define SDRAMC_16HP_16Mx8_4B_R12_C10  (_SBF(7,0x08))
+/*128Mb (8Mx16), 4 banks, row length = 12, column length = 9*/
+#define SDRAMC_16HP_8Mx16_4B_R12_C9   (_SBF(7,0x09))
+/*256Mb (32Mx8), 4 banks, row length = 13, column length = 10*/
+#define SDRAMC_16HP_32Mx8_4B_R13_C10  (_SBF(7,0x0C))
+/*256Mb (16Mx16), 4 banks, row length = 13, column length = 9*/
+#define SDRAMC_16HP_16Mx16_4B_R13_C9  (_SBF(7,0x0D))
+/*512Mb (64Mx8), 4 banks, row length = 13, column length = 11*/
+#define SDRAMC_16HP_64Mx8_4B_R13_C11  (_SBF(7,0x10))
+/*512Mb (32Mx16), 4 banks, row length = 13, column length = 10*/
+#define SDRAMC_16HP_32Mx16_4B_R13_C10 (_SBF(7,0x11))
+
+/*16-bit external bus low power SDRAM address mapping */
+/*16Mb (2Mx8), 2 banks, row length = 11, column length = 9*/
+#define SDRAMC_16LP_2Mx8_2B_R11_C9    (_SBF(7,0x20))
+/*16Mb (1Mx16), 2 banks, row length = 11, column length = 8*/
+#define SDRAMC_16LP_1Mx16_2B_R11_C8   (_SBF(7,0x21))
+/*64Mb (8Mx8), 4 banks, row length = 12, column length = 9*/
+#define SDRAMC_16LP_8Mx8_4B_R12_C9    (_SBF(7,0x24))
+/*64Mb (4Mx16), 4 banks, row length = 12, column length = 8*/
+#define SDRAMC_16LP_4Mx16_4B_R12_C8   (_SBF(7,0x25))
+/*128Mb (16Mx8), 4 banks, row length = 12, column length = 10*/
+#define SDRAMC_16LP_16Mx8_4B_R12_C10  (_SBF(7,0x28))
+/*128Mb (8Mx16), 4 banks, row length = 12, column length = 9*/
+#define SDRAMC_16LP_8Mx16_4B_R12_C9   (_SBF(7,0x29))
+/*256Mb (32Mx8), 4 banks, row length = 13, column length = 10*/
+#define SDRAMC_16LP_32Mx8_4B_R13_C10  (_SBF(7,0x2C))
+/*256Mb (16Mx16), 4 banks, row length = 13, column length = 9*/
+#define SDRAMC_16LP_16Mx16_4B_R13_C9  (_SBF(7,0x2D))
+/*512Mb (64Mx8), 4 banks, row length = 13, column length = 11*/
+#define SDRAMC_16LP_64Mx8_4B_R13_C11  (_SBF(7,0x30))
+/*512Mb (32Mx16), 4 banks, row length = 13, column length = 10*/
+#define SDRAMC_16LP_32Mx16_4B_R13_C10 (_SBF(7,0x31))
+
+
+/* SDRAM Read Config Bit Field constants*/
+#define MPMC_SDRAMC_RDCFG_CLKOUTDELAY_STG       _SBF(0,0)
+#define MPMC_SDRAMC_RDCFG_CMDDELAY_STG          _SBF(0,1)
+#define MPMC_SDRAMC_RDCFG_CMDDELAY_P1_STG       _SBF(0,2)
+#define MPMC_SDRAMC_RDCFG_CMDDELAY_P2_STG       _SBF(0,3)
+/* SDRAM RASCAS Bit Field constants*/
+#define MPMC_SDRAMC_RASCAS_CAS0        _SBF(8,0)
+#define MPMC_SDRAMC_RASCAS_CAS1        _SBF(8,1)
+#define MPMC_SDRAMC_RASCAS_CAS2        _SBF(8,2)
+#define MPMC_SDRAMC_RASCAS_CAS3        _SBF(8,3)
+#define MPMC_SDRAMC_RASCAS_RAS0        _SBF(0,0)
+#define MPMC_SDRAMC_RASCAS_RAS1        _SBF(0,1)
+#define MPMC_SDRAMC_RASCAS_RAS2        _SBF(0,2)
+#define MPMC_SDRAMC_RASCAS_RAS3        _SBF(0,3)
+
+
+/***********************************************************************
+* NAND Flash controller Register Structures
+**********************************************************************/
+#define NANDC_PHYS           (0x17000800)
+#define NANDC_RAM0_PHYS	     (0x70000000)
+#define NANDC_RAM1_PHYS	     (0x70000400)
+#define NANDC_BUF_SZ         512
+#define NANDC_IRQ_STS        __REG (NANDC_PHYS + 0x000)
+#define NANDC_IRQ_MSK        __REG (NANDC_PHYS + 0x004)
+#define NANDC_IRQ_STS_RAW    __REG (NANDC_PHYS + 0x008)
+#define NANDC_CFG            __REG (NANDC_PHYS + 0x00C)
+#define NANDC_IRQ_IO_CFG     __REG (NANDC_PHYS + 0x010)
+#define NANDC_IRQ_TIMING1    __REG (NANDC_PHYS + 0x014)
+#define NANDC_IRQ_TIMING2    __REG (NANDC_PHYS + 0x018)
+#define NANDC_SET_CMD        __REG (NANDC_PHYS + 0x020)
+#define NANDC_SET_ADDR       __REG (NANDC_PHYS + 0x024)
+#define NANDC_WRITE_DATA     __REG (NANDC_PHYS + 0x028)
+#define NANDC_SET_CE         __REG (NANDC_PHYS + 0x02C)
+#define NANDC_READ_DATA      __REG (NANDC_PHYS + 0x030)
+#define NANDC_CHECK_STS      __REG (NANDC_PHYS + 0x034)
+#define NANDC_CTRL_FLOW      __REG (NANDC_PHYS + 0x038)
+#define NANDC_GPIO1          __REG (NANDC_PHYS + 0x040)
+#define NANDC_GPIO2          __REG (NANDC_PHYS + 0x044)
+#define NANDC_IRQ_STS2       __REG (NANDC_PHYS + 0x048)
+#define NANDC_IRQ_MSK2       __REG (NANDC_PHYS + 0x04C)
+#define NANDC_IRQ_STS_RAW2   __REG (NANDC_PHYS + 0x050)
+
+/* Register description of irq_status */
+#define NAND_IRQ_RB3_POS_EDGE       _BIT(31)
+#define NAND_IRQ_RB2_POS_EDGE       _BIT(30)
+#define NAND_IRQ_RB1_POS_EDGE       _BIT(29)
+#define NAND_IRQ_RB0_POS_EDGE       _BIT(28)
+#define NAND_IRQ_RB_POS_EDGE(cs)    _BIT(28 + (cs))
+#define NAND_IRQ_ERASED_RAM1        _BIT(27)
+#define NAND_IRQ_ERASED_RAM0        _BIT(26)
+#define NAND_IRQ_WR_RAM1            _BIT(25)
+#define NAND_IRQ_WR_RAM0            _BIT(24)
+#define NAND_IRQ_RD_RAM1            _BIT(23)
+#define NAND_IRQ_RD_RAM0            _BIT(22)
+#define NAND_IRQ_ECC_DEC_RAM0       _BIT(21)
+#define NAND_IRQ_ECC_ENC_RAM0       _BIT(20)
+#define NAND_IRQ_ECC_DEC_RAM1       _BIT(19)
+#define NAND_IRQ_ECC_ENC_RAM1       _BIT(18)
+#define NAND_IRQ_NOERR_RAM0         _BIT(17)
+#define NAND_IRQ_ERR1_RAM0          _BIT(16)
+#define NAND_IRQ_ERR2_RAM0          _BIT(15)
+#define NAND_IRQ_ERR3_RAM0          _BIT(14)
+#define NAND_IRQ_ERR4_RAM0          _BIT(13)
+#define NAND_IRQ_ERR5_RAM0          _BIT(12)
+#define NAND_IRQ_ERR_UNR_RAM0       _BIT(11)
+#define NAND_IRQ_NOERR_RAM1         _BIT(10)
+#define NAND_IRQ_ERR1_RAM1          _BIT(9)
+#define NAND_IRQ_ERR2_RAM1          _BIT(8)
+#define NAND_IRQ_ERR3_RAM1          _BIT(7)
+#define NAND_IRQ_ERR4_RAM1          _BIT(6)
+#define NAND_IRQ_ERR5_RAM1          _BIT(5)
+#define NAND_IRQ_ERR_UNR_RAM1       _BIT(4)
+#define NAND_IRQ_AES_DONE_RAM1      _BIT(1)
+#define NAND_IRQ_AES_DONE_RAM0      _BIT(0)
+
+/* Register description of config */
+#define NAND_CFG_ECGC		    _BIT(13)
+#define NAND_CFG_8BIT_ECC           _BIT(12)
+#define NAND_CFG_TL_528             _SBF(10, 0x0)
+#define NAND_CFG_TL_516             _SBF(10, 0x1)
+#define NAND_CFG_TL_512             _SBF(10, 0x2)
+#define NAND_CFG_TL_MASK            _SBF(10, 0x3)
+#define NAND_CFG_EO                 _BIT(9)
+#define NAND_CFG_DC                 _BIT(8)
+#define NAND_CFG_M                  _BIT(7)
+#define NAND_CFG_LC_0               _SBF(5, 0x0)
+#define NAND_CFG_LC_1               _SBF(5, 0x1)
+#define NAND_CFG_LC_2               _SBF(5, 0x2)
+#define NAND_CFG_LC_MASK            _SBF(5, 0x3)
+#define NAND_CFG_ES                 _BIT(4)
+#define NAND_CFG_DE                 _BIT(3)
+#define NAND_CFG_AO                 _BIT(2)
+#define NAND_CFG_WD                 _BIT(1)
+#define NAND_CFG_EC                 _BIT(0)
+
+/* Register description of io_config */
+#define NAND_IO_CFG_IO_DRIVE        _BIT(24)
+#define NAND_IO_CFG_DATA_DEF(n)     _SBF(8, ((n) & 0xFFFF))
+#define NAND_IO_CFG_CLE_1           _SBF(6, 0x01)
+#define NAND_IO_CFG_ALE_1           _SBF(4, 0x01)
+#define NAND_IO_CFG_WE_1            _SBF(2, 0x01)
+#define NAND_IO_CFG_RE_1            _SBF(0, 0x01)
+
+/* Register description of timing1 */
+#define NAND_TIM1_TSRD(n)           _SBF(20, ((n) & 0x3))
+#define NAND_TIM1_TALS(n)           _SBF(16, ((n) & 0x7))
+#define NAND_TIM1_TALH(n)           _SBF(12, ((n) & 0x7))
+#define NAND_TIM1_TCLS(n)           _SBF(4, ((n) & 0x7))
+#define NAND_TIM1_TCLH(n)           ((n) & 0x7)
+
+/* Register description of timing2 */
+#define NAND_TIM2_TDRD(n)           _SBF(28, ((n) & 0x7))
+#define NAND_TIM2_TEBI(n)           _SBF(24, ((n) & 0x7))
+#define NAND_TIM2_TCH(n)            _SBF(20, ((n) & 0x7))
+#define NAND_TIM2_TCS(n)            _SBF(16, ((n) & 0x7))
+#define NAND_TIM2_TRH(n)            _SBF(12, ((n) & 0x7))
+#define NAND_TIM2_TRP(n)            _SBF(8, ((n) & 0x7))
+#define NAND_TIM2_TWH(n)            _SBF(4, ((n) & 0x7))
+#define NAND_TIM2_TWP(n)            ((n) & 0x7)
+
+/* Register description of set_ce */
+#define NAND_SETCE_OVR_EN(n)        _BIT(((n) & 0x3) + 12)
+#define NAND_SETCE_OVR_V(n)         _BIT(((n) & 0x3) + 8)
+#define NAND_SETCE_WP               _BIT(4)
+#define NAND_SETCE_CV_MASK          0x0F
+#define NAND_SETCE_CV(n)            (0x0F & ~_BIT(((n) & 0x3)))
+
+/* Register description of check_sts */
+#define NAND_CHK_STS_RB3_EDGE       _BIT(8)
+#define NAND_CHK_STS_RB2_EDGE       _BIT(7)
+#define NAND_CHK_STS_RB1_EDGE       _BIT(6)
+#define NAND_CHK_STS_RB0_EDGE       _BIT(5)
+#define NAND_CHK_STS_RB_EDGE(n)     _BIT((n) + 5)
+#define NAND_CHK_STS_RB4_LVL        _BIT(4)
+#define NAND_CHK_STS_RB3_LVL        _BIT(3)
+#define NAND_CHK_STS_RB2_LVL        _BIT(2)
+#define NAND_CHK_STS_RB1_LVL        _BIT(1)
+#define NAND_CHK_STS_APB_BSY        _BIT(0)
+
+/* Resegister description of control_flow */
+#define NAND_CTRLFLW_WRITE_RAM1     _BIT(5)
+#define NAND_CTRLFLW_WRITE_RAM0     _BIT(4)
+#define NAND_CTRLFLW_READ_RAM1      _BIT(1)
+#define NAND_CTRLFLW_READ_RAM0      _BIT(0)
+/***********************************************************************
+ * SD/MMC MCI register definitions
+ **********************************************************************/
+#define SDMMC_PHYS            (0x18000000)
+#define SDMMC_CTRL            __REG (SDMMC_PHYS + 0x000)
+#define SDMMC_PWREN           __REG (SDMMC_PHYS + 0x004)
+#define SDMMC_CLKDIV          __REG (SDMMC_PHYS + 0x008)
+#define SDMMC_CLKSRC          __REG (SDMMC_PHYS + 0x00c)
+#define SDMMC_CLKENA          __REG (SDMMC_PHYS + 0x010)
+#define SDMMC_TMOUT           __REG (SDMMC_PHYS + 0x014)
+#define SDMMC_CTYPE           __REG (SDMMC_PHYS + 0x018)
+#define SDMMC_BLKSIZ          __REG (SDMMC_PHYS + 0x01c)
+#define SDMMC_BYTCNT          __REG (SDMMC_PHYS + 0x020)
+#define SDMMC_INTMASK         __REG (SDMMC_PHYS + 0x024)
+#define SDMMC_CMDARG          __REG (SDMMC_PHYS + 0x028)
+#define SDMMC_CMD             __REG (SDMMC_PHYS + 0x02c)
+#define SDMMC_RESP0           __REG (SDMMC_PHYS + 0x030)
+#define SDMMC_RESP1           __REG (SDMMC_PHYS + 0x034)
+#define SDMMC_RESP2           __REG (SDMMC_PHYS + 0x038)
+#define SDMMC_RESP3           __REG (SDMMC_PHYS + 0x03c)
+#define SDMMC_MINTSTS         __REG (SDMMC_PHYS + 0x040)
+#define SDMMC_RINTSTS         __REG (SDMMC_PHYS + 0x044)
+#define SDMMC_STATUS          __REG (SDMMC_PHYS + 0x048)
+#define SDMMC_FIFOTH          __REG (SDMMC_PHYS + 0x04c)
+#define SDMMC_TCBCNT          __REG (SDMMC_PHYS + 0x05c)
+#define SDMMC_TBBCNT          __REG (SDMMC_PHYS + 0x060)
+#define SDMMC_DEBNCE          __REG (SDMMC_PHYS + 0x064)
+#define SDMMC_USRID           __REG (SDMMC_PHYS + 0x068)
+#define SDMMC_VERID           __REG (SDMMC_PHYS + 0x06c)
+#define SDMMC_HCON            __REG (SDMMC_PHYS + 0x070)
+#define SDMMC_DATA            __REG (SDMMC_PHYS + 0x100)
+#define SDMMC_DATA_ADR        (SDMMC_PHYS + 0x100)
+
+/* Control register defines */
+#define SDMMC_CTRL_CEATA_INT_EN   _BIT(11)
+#define SDMMC_CTRL_SEND_AS_CCSD   _BIT(10)
+#define SDMMC_CTRL_SEND_CCSD      _BIT(9)
+#define SDMMC_CTRL_ABRT_READ_DATA _BIT(8)
+#define SDMMC_CTRL_SEND_IRQ_RESP  _BIT(7)
+#define SDMMC_CTRL_READ_WAIT      _BIT(6)
+#define SDMMC_CTRL_DMA_ENABLE     _BIT(5)
+#define SDMMC_CTRL_INT_ENABLE     _BIT(4)
+#define SDMMC_CTRL_DMA_RESET      _BIT(2)
+#define SDMMC_CTRL_FIFO_RESET     _BIT(1)
+#define SDMMC_CTRL_RESET          _BIT(0)
+/* Clock Enable register defines */
+#define SDMMC_CLKEN_LOW_PWR      _BIT(16)
+#define SDMMC_CLKEN_ENABLE       _BIT(0)
+/* time-out register defines */
+#define SDMMC_TMOUT_DATA(n)      _SBF(8, (n))
+#define SDMMC_TMOUT_DATA_MSK     0xFFFFFF00
+#define SDMMC_TMOUT_RESP(n)      ((n) & 0xFF)
+#define SDMMC_TMOUT_RESP_MSK     0xFF
+/* card-type register defines */
+#define SDMMC_CTYPE_8BIT         _BIT(16)
+#define SDMMC_CTYPE_4BIT         _BIT(0)
+/* Interrupt status & mask register defines */
+#define SDMMC_INT_SDIO           _BIT(16)
+#define SDMMC_INT_EBE            _BIT(15)
+#define SDMMC_INT_ACD            _BIT(14)
+#define SDMMC_INT_SBE            _BIT(13)
+#define SDMMC_INT_HLE            _BIT(12)
+#define SDMMC_INT_FRUN           _BIT(11)
+#define SDMMC_INT_HTO            _BIT(10)
+#define SDMMC_INT_DTO            _BIT(9)
+#define SDMMC_INT_RTO            _BIT(8)
+#define SDMMC_INT_DCRC           _BIT(7)
+#define SDMMC_INT_RCRC           _BIT(6)
+#define SDMMC_INT_RXDR           _BIT(5)
+#define SDMMC_INT_TXDR           _BIT(4)
+#define SDMMC_INT_DATA_OVER      _BIT(3)
+#define SDMMC_INT_CMD_DONE       _BIT(2)
+#define SDMMC_INT_RESP_ERR       _BIT(1)
+#define SDMMC_INT_CD             _BIT(0)
+#define SDMMC_INT_ERROR          0xbfc2
+/* Command register defines */
+#define SDMMC_CMD_START         _BIT(31)
+#define SDMMC_CMD_CCS_EXP       _BIT(23)
+#define SDMMC_CMD_CEATA_RD      _BIT(22)
+#define SDMMC_CMD_UPD_CLK       _BIT(21)
+#define SDMMC_CMD_INIT          _BIT(15)
+#define SDMMC_CMD_STOP          _BIT(14)
+#define SDMMC_CMD_PRV_DAT_WAIT  _BIT(13)
+#define SDMMC_CMD_SEND_STOP     _BIT(12)
+#define SDMMC_CMD_STRM_MODE     _BIT(11)
+#define SDMMC_CMD_DAT_WR        _BIT(10)
+#define SDMMC_CMD_DAT_EXP       _BIT(9)
+#define SDMMC_CMD_RESP_CRC      _BIT(8)
+#define SDMMC_CMD_RESP_LONG     _BIT(7)
+#define SDMMC_CMD_RESP_EXP      _BIT(6)
+#define SDMMC_CMD_INDX(n)       ((n) & 0x1F)
+/* Status register defines */
+#define SDMMC_GET_FCNT(x)      (((x)>>17) & 0x1FF)
+#define SDMMC_FIFO_SZ           128
+
+/***********************************************************************
+ * SPI register definitions
+ **********************************************************************/
+#define SPI_PHYS              (0x15002000)
+#define SPI_CONFIG_REG        __REG (SPI_PHYS + 0x00)
+#define SPI_SLV_ENAB_REG      __REG (SPI_PHYS + 0x04)
+#define SPI_TXF_FLUSH_REG     __REG (SPI_PHYS + 0x08)
+#define SPI_FIFO_DATA_REG     __REG (SPI_PHYS + 0x0C)
+#define SPI_NHP_POP_REG       __REG (SPI_PHYS + 0x10)
+#define SPI_NHP_MODE_REG      __REG (SPI_PHYS + 0x14)
+#define SPI_DMA_SET_REG       __REG (SPI_PHYS + 0x18)
+#define SPI_STS_REG           __REG (SPI_PHYS + 0x1C)
+#define SPI_HWINFO_REG        __REG (SPI_PHYS + 0x20)
+#define SPI_SLV_SET1_REG(slv) __REG (SPI_PHYS + 0x24 + (8 * slv))
+#define SPI_SLV_SET2_REG(slv) __REG (SPI_PHYS + 0x28 + (8 * slv))
+#define SPI_INT_TRSH_REG      __REG (SPI_PHYS + 0xFD4)
+#define SPI_INT_CLRE_REG      __REG (SPI_PHYS + 0xFD8)
+#define SPI_INT_SETE_REG      __REG (SPI_PHYS + 0xFDC)
+#define SPI_INT_STS_REG       __REG (SPI_PHYS + 0xFE0)
+#define SPI_INT_ENAB_REG      __REG (SPI_PHYS + 0xFE4)
+#define SPI_INT_CLRS_REG      __REG (SPI_PHYS + 0xFE8)
+#define SPI_INT_SETS_REG      __REG (SPI_PHYS + 0xFEC)
+#define SPI_MOD_ID_REG        __REG (SPI_PHYS + 0xFFC)
+
+/* SPI device contants */
+#define SPI_FIFO_DEPTH  64 /* 64 words (16bit) deep */
+#define SPI_NUM_SLAVES  3  /* number of slaves supported */
+#define SPI_MAX_DIV2    254
+#define SPI_MAX_DIVIDER 65024 /* = 254 * (255 + 1) */
+#define SPI_MIN_DIVIDER 2
+
+/* SPI Configuration register definitions (SPI_CONFIG_REG) */
+#define SPI_CFG_INTER_DLY(n)      _SBF(16, ((n) & 0xFFFF))
+#define SPI_CFG_INTER_DLY_GET(n)  (((n) >> 16) & 0xFFFF)
+#define SPI_CFG_UPDATE_EN         _BIT(7)
+#define SPI_CFG_SW_RESET          _BIT(6)
+#define SPI_CFG_SLAVE_DISABLE     _BIT(4)
+#define SPI_CFG_MULTI_SLAVE       _BIT(3)
+#define SPI_CFG_LOOPBACK          _BIT(2)
+#define SPI_CFG_SLAVE_MODE        _BIT(1)
+#define SPI_CFG_ENABLE            _BIT(0)
+
+/* SPI slave_enable register definitions (SPI_SLV_ENAB_REG) */
+#define SPI_SLV_EN(n)             _SBF(((n) << 1), 0x1)
+#define SPI_SLV_SUSPEND(n)        _SBF(((n) << 1), 0x3)
+
+/* SPI tx_fifo_flush register definitions (SPI_TXF_FLUSH_REG) */
+#define SPI_TXFF_FLUSH            _BIT(1)
+
+/* SPI dma_settings register definitions (SPI_DMA_SET_REG) */
+#define SPI_DMA_TX_EN             _BIT(1)
+#define SPI_DMA_RX_EN             _BIT(0)
+
+/* SPI status register definitions (SPI_STS_REG) */
+#define SPI_ST_SMS_BUSY           _BIT(5)
+#define SPI_ST_BUSY               _BIT(4)
+#define SPI_ST_RX_FF              _BIT(3)
+#define SPI_ST_RX_EMPTY           _BIT(2)
+#define SPI_ST_TX_FF              _BIT(1)
+#define SPI_ST_TX_EMPTY           _BIT(0)
+
+/* SPI slv_setting registers definitions (SPI_SLV_SET1_REG) */
+#define SPI_SLV1_INTER_TX_DLY(n)  _SBF(24, ((n) & 0xFF))
+#define SPI_SLV1_NUM_WORDS(n)     _SBF(16, ((n) & 0xFF))
+#define SPI_SLV1_CLK_PS(n)        _SBF(8, ((n) & 0xFF))
+#define SPI_SLV1_CLK_PS_GET(n)    (((n) >> 8) & 0xFF)
+#define SPI_SLV1_CLK_DIV1(n)      ((n) & 0xFF)
+#define SPI_SLV1_CLK_DIV1_GET(n)  ((n) & 0xFF)
+
+/* SPI slv_setting registers definitions (SPI_SLV_SET2_REG) */
+#define SPI_SLV2_PPCS_DLY(n)      _SBF(9, ((n) & 0xFF))
+#define SPI_SLV2_CS_HIGH          _BIT(8)
+#define SPI_SLV2_SSI_MODE         _BIT(7)
+#define SPI_SLV2_SPO              _BIT(6)
+#define SPI_SLV2_SPH              _BIT(5)
+#define SPI_SLV2_WD_SZ(n)         ((n) & 0x1F)
+
+/* SPI int_threshold registers definitions (SPI_INT_TRSH_REG) */
+#define SPI_INT_TSHLD_TX(n)       _SBF(8, ((n) & 0xFF))
+#define SPI_INT_TSHLD_RX(n)       ((n) & 0xFF)
+
+/* SPI intterrupt registers definitions ( SPI_INT_xxx) */
+#define SPI_SMS_INT               _BIT(4)
+#define SPI_TX_INT                _BIT(3)
+#define SPI_RX_INT                _BIT(2)
+#define SPI_TO_INT                _BIT(1)
+#define SPI_OVR_INT               _BIT(0)
+#define SPI_ALL_INTS              (SPI_SMS_INT | SPI_TX_INT | SPI_RX_INT | SPI_TO_INT | SPI_OVR_INT)
+
+
+/***********************************************************************
+ * I2C register definitions
+ **********************************************************************/
+#define I2C0_PHYS            (0x1300A000)
+#define I2C1_PHYS            (0x1300A400)
+#define I2C_REG_RX(a)	      __REG ((a) + 0x000)	/* Rx FIFO reg (RO) */
+#define I2C_REG_TX(a)	      __REG ((a) + 0x000)		/* Tx FIFO reg (WO) */
+#define I2C_REG_STS(a)	      __REG ((a) + 0x04)	/* Status reg (RO) */
+#define I2C_REG_CTL(a)	      __REG ((a) + 0x08)	/* Ctl reg */
+#define I2C_REG_CKH(a)	      __REG ((a) + 0x0C)	/* Clock divider high */
+#define I2C_REG_CKL(a)	      __REG ((a) + 0x10)	/* Clock divider low */
+#define I2C_REG_ADR(a)	      __REG ((a) + 0x14)	/* I2C address */
+#define I2C_REG_RFL(a)	      __REG ((a) + 0x18)	/* Rx FIFO level (RO) */
+#define I2C_REG_TFL(a)	      __REG ((a) + 0x1c)	/* Tx FIFO level (RO) */
+#define I2C_REG_RXB(a)	      __REG ((a) + 0x20)	/* Num of bytes Rx-ed (RO) */
+#define I2C_REG_TXB(a)	      __REG ((a) + 0x24)	/* Num of bytes Tx-ed (RO) */
+#define I2C_REG_TXS(a)	      __REG ((a) + 0x28)	/* Tx slave FIFO (RO) */
+#define I2C_REG_STFL(a)	      __REG ((a) + 0x2c)	/* Tx slave FIFO level (RO) */
+/* I2C Tx FIFO register definitions*/
+#define I2C_TXFF_STOP_CND   _BIT(9)
+#define I2C_TXFF_START_CND  _BIT(8)
+#define I2C_TXFF_DATA_MSK   0xFF
+
+/* I2C status register definitions*/
+#define I2C_STS_TFES        _BIT(13)
+#define I2C_STS_TFFS        _BIT(12)
+#define I2C_STS_TFE         _BIT(11)
+#define I2C_STS_TFF         _BIT(10)
+#define I2C_STS_RFE         _BIT(9)
+#define I2C_STS_RFF         _BIT(8)
+#define I2C_STS_SDA         _BIT(7)
+#define I2C_STS_SCL         _BIT(6)
+#define I2C_STS_ACTIVE      _BIT(5)
+#define I2C_STS_DRSI        _BIT(4)
+#define I2C_STS_DRMI        _BIT(3)
+#define I2C_STS_NAI         _BIT(2)
+#define I2C_STS_AFI         _BIT(1)
+#define I2C_STS_TDI         _BIT(0)
+
+/* I2C control register definitions*/
+#define I2C_CTL_TFFSIE       _BIT(10)
+// #define I2C_CTL_SEVEN        _BIT(9) /* Seven-bit slave address */
+#define I2C_CTL_SOFT_RESET   _BIT(8)
+#define I2C_CTL_TFFIE        _BIT(7)
+#define I2C_CTL_DAIE         _BIT(6)
+#define I2C_CTL_RFFIE        _BIT(5)
+#define I2C_CTL_DRSIE        _BIT(4)
+#define I2C_CTL_DRMIE        _BIT(3)
+#define I2C_CTL_NAIE         _BIT(2)
+#define I2C_CTL_AFIE         _BIT(1)
+#define I2C_CTL_TDIE         _BIT(0)
+
+/***********************************************************************
+* LPC315x Analog die I2C constants
+**********************************************************************/
+#define AD_I2C_WRITE_ADR    (_SBF(1, 0xC) | I2C_TXFF_START_CND)
+#define AD_I2C_READ_ADR     (_SBF(1, 0xC) | 0x1 | I2C_TXFF_START_CND)
+
+/* Analog die I2C Register offsets*/
+#define AD_REG_OTGDCLIC_RW                            0x0000
+#define AD_REG_DCDCLIC_RO                             0x0001
+#define AD_REG_CGU_RW                                 0x0002
+#define AD_REG_AIN_0_RW                               0x0010
+#define AD_REG_AIN_1_RW                               0x0011
+#define AD_REG_AOUT_RW                                0x0012
+#define AD_REG_DEC_RW                                 0x0013
+#define AD_REG_INT_0_RW                               0x0014
+#define AD_REG_INT_1_RW                               0x0015
+#define AD_REG_DAIOMUX_RW                             0x0016
+#define AD_REG_AOUTDECINT_RO                          0x0017
+#define AD_REG_RTC_TIME                               0x0020
+#define AD_REG_RTC_ALARM_TIME                         0x0021
+#define AD_REG_RTC_STATUS                             0x0022
+#define AD_REG_RTC_SET_ENA_STAT                       0x0023
+#define AD_REG_RTC_CLR_ENA_STAT                       0x0024
+#define AD_REG_MOD_ID                                 0x03FF
+
+/* 3v3 IO voltage rail adjustments */
+#define DCDC1_3_20                   0
+#define DCDC1_3_09                   1
+#define DCDC1_2_97                   2
+#define DCDC1_2_86                   3
+#define DCDC1_2_74                   4
+#define DCDC1_2_63                   5
+#define DCDC1_2_51                   6
+#define DCDC1_2_40                   7
+/* 1v2 core voltage rail adjustments */
+#define DCDC2_1_40                   0
+#define DCDC2_1_33                   1
+#define DCDC2_1_26                   2
+#define DCDC2_1_19                   3
+#define DCDC2_1_11                   4
+#define DCDC2_1_04                   5
+#define DCDC2_0_97                   6
+#define DCDC2_0_90                   7
+/* 1v4 io voltage rail adjustments */
+#define PSU_VOUT3_1_40               0
+#define PSU_VOUT3_1_80               _BIT(16)
+
+/***********************************************************************
+ * Memory definitions
+ **********************************************************************/
+#define EXT_SDRAM_PHYS		0x30000000
+#define EXT_SRAM0_PHYS		0x20000000
+#define EXT_SRAM1_PHYS		0x20020000
+#define ISRAM0_PHYS             0x11028000
+#define ISRAM0_LENGTH	        0x00018000
+#define ISRAM1_PHYS             0x11040000
+#define ISRAM1_LENGTH           0x00018000
+
+/***********************************************************************
+ * XTAL clock definitions
+ **********************************************************************/
+#define XTAL_CLOCK        CONFIG_OSC_FREQ
+#define FFAST_CLOCK       XTAL_CLOCK
+
+/* include CGU header */
+#include "lpc313x_cgu.h"
+#include "event_router.h"
+
+
+#endif  /* __LPC313X_H__ */
diff -purN apex-1.6.8/src/mach-lpc313x/lpc315x_ad.c work_1.6.8/src/mach-lpc313x/lpc315x_ad.c
--- apex-1.6.8/src/mach-lpc313x/lpc315x_ad.c	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/lpc315x_ad.c	2010-03-22 10:40:02.000000000 -0700
@@ -0,0 +1,170 @@
+/* lpc315x_ad.c
+
+   written by Durgesh Pattamatta
+   1 Nov 2004
+
+   Copyright (C) 2008 NXP Semiconductors
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+   -----------
+   DESCRIPTION
+   -----------
+   This implementation assumes the I2C1 clock is sourced by 12MHz FFAST_IN
+   clock in CGU. 
+   
+
+*/
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <apex.h>
+#include <command.h>
+#include <error.h>
+#include <linux/kernel.h>
+#include <config.h>
+#include <environment.h>
+#include <service.h>
+#include <mach/lpc313x.h>
+#include <mach/hardware.h>
+#include "lpc313x_cgu.h"
+
+
+
+#define I2C_CLK_DIV_12MHZ           (60)
+#define PSU_VOLT_US_DELAY           (10000)
+
+void __section (.bootstrap) analog_reg_init(void)
+{
+	cgu_clk_en_dis(CGU_SB_SYSCLK_O_ID, 1);
+	cgu_clk_en_dis(CGU_SB_I2C1_PCLK_ID, 1);
+	I2C_REG_CKH(I2C1_PHYS) = I2C_CLK_DIV_12MHZ;
+	I2C_REG_CKL(I2C1_PHYS) = I2C_CLK_DIV_12MHZ;
+
+	I2C_REG_CTL(I2C1_PHYS) = I2C_CTL_SOFT_RESET;  //Issue soft reset of the block
+}
+
+void __section (.bootstrap) analog_reg_read(u32 reg_addr, u32 * pReg_value)
+{
+	u32   status = 0;
+
+	// Write dummy value 
+	*pReg_value = 0;
+
+	I2C_REG_TX(I2C1_PHYS) = AD_I2C_WRITE_ADR;           // Send write address of the AD I2C slave with the start condition
+	I2C_REG_TX(I2C1_PHYS) = ((reg_addr >> 8) & 0xFF);   // Send the high byte of the register address
+	I2C_REG_TX(I2C1_PHYS) = (reg_addr & 0xFF);          // Send the low byte of the register address
+	I2C_REG_TX(I2C1_PHYS) = AD_I2C_READ_ADR;            // Send read address of the AD I2C slave with the (re)start condition
+	I2C_REG_TX(I2C1_PHYS) = 0xff;                       // Dummy 1
+	I2C_REG_TX(I2C1_PHYS) = 0xff;                       // Dummy 2
+	I2C_REG_TX(I2C1_PHYS) = 0xff;                       // Dummy 3
+	I2C_REG_TX(I2C1_PHYS) = 0xff | I2C_TXFF_STOP_CND;   // Dummy 4 with the stop condition
+
+	while ((status & (I2C_STS_NAI | I2C_STS_TDI)) == 0) {
+		status = I2C_REG_STS(I2C1_PHYS);
+	}
+
+	if (status & I2C_STS_TDI) {
+		// Clear the TDI status
+		I2C_REG_STS(I2C1_PHYS) = I2C_STS_TDI;
+
+		// Read out the register value
+		*pReg_value = (((I2C_REG_RX(I2C1_PHYS)) & 0xFF) << 24);
+		*pReg_value |= (((I2C_REG_RX(I2C1_PHYS)) & 0xFF) << 16);
+		*pReg_value |= (((I2C_REG_RX(I2C1_PHYS)) & 0xFF) << 8);
+		*pReg_value |= ((I2C_REG_RX(I2C1_PHYS)) & 0xFF);
+	}
+}
+
+void __section (.bootstrap) analog_reg_write(u32 reg_addr, u32 reg_value)
+{
+	u32   status = 0;
+
+	I2C_REG_TX(I2C1_PHYS) = AD_I2C_WRITE_ADR;           // Send write address of the AD I2C slave with the start condition
+	I2C_REG_TX(I2C1_PHYS) = ((reg_addr >> 8) & 0xFF);   // Send the high byte of the register address
+	I2C_REG_TX(I2C1_PHYS) = (reg_addr & 0xFF);          // Send the low byte of the register address
+	I2C_REG_TX(I2C1_PHYS) = (reg_value >> 24);          // Send MSB of the register value
+	I2C_REG_TX(I2C1_PHYS) = ((reg_value >> 16) & 0xFF); // Send Byte 2
+	I2C_REG_TX(I2C1_PHYS) = ((reg_value >> 8) & 0xFF);  // Sent Byte1
+	I2C_REG_TX(I2C1_PHYS) = ((reg_value & 0xFF)         // Send LSB of the register value
+		     | I2C_TXFF_STOP_CND);   // ... with the stop condition
+
+	while ((status & (I2C_STS_NAI | I2C_STS_TDI)) == 0) {
+		status = I2C_REG_STS(I2C1_PHYS);
+	}
+
+	if (status & I2C_STS_TDI) 	{
+		// Clear the TDI status
+		I2C_REG_STS(I2C1_PHYS) = I2C_STS_TDI;
+	}
+}
+
+void __section (.bootstrap) psu_set_voltage(u32 rail, u32 volt)
+{
+	u32 reg_val;
+	int bit_pos;
+
+	/* read PSU register */
+	analog_reg_read (AD_REG_OTGDCLIC_RW, &reg_val);
+	/* check if this is to set VOUT3 rail */
+	if (ANALOG_1V8_RAIL == rail) {
+		reg_val |= (volt)?_BIT(16):0;
+	} else {
+		/* for 1v2 bitpos is 17 and for 3v3 bit pos 20 */
+		bit_pos = (rail)? 17 : 20;
+
+		if (volt > 0x7)
+			volt = 0x7;
+
+		/* zero the dcdc1 adjust bits */
+		reg_val &= ~(0x7 << bit_pos);
+		/* write the new adjust value */
+		reg_val |= (volt << bit_pos);
+	}
+
+
+	analog_reg_write (AD_REG_OTGDCLIC_RW, reg_val);
+	return;
+
+}
+
+static int cmd_adset (int argc, const char** argv)
+{
+	u32 rail = 0;
+	u32 volt = 0;
+
+	if (argc != 3)
+		return ERROR_PARAM;
+
+	if (*argv[1] != '0') {
+		rail = 1;
+	}
+	volt = simple_strtoul (argv[2], NULL, 0);
+
+	if (volt > 7)
+		return ERROR_PARAM;
+
+	psu_set_voltage(rail, volt);
+
+	return 0;
+}
+
+static __command struct command_d c_pause = {
+	.command = "adset",
+	.func = cmd_adset,
+	COMMAND_DESCRIPTION ("Analog die set voltage")
+	COMMAND_HELP(
+	"adset rail voltage\n"
+	"  Set voltage for selected rail.\n"
+	"  rail =  \n"
+	"	- 0 ANALOG_3V3_RAIL \n"
+	"	- 1 ANALOG_1V2_RAIL \n"
+	"  voltage param range is 0 to 7 \n"
+	"    3V3  - 3.2(0), 3.09(1), 2.97, 2.86, 2.74, 2.63, 2.51, 2.40(7)\n"
+	"    1V2  - 1.4(0), 1.33(1), 1.26, 1.19, 1.11, 1.04, 0.97, 0.90(7)\n"
+	)
+};
+
diff -purN apex-1.6.8/src/mach-lpc313x/Makefile work_1.6.8/src/mach-lpc313x/Makefile
--- apex-1.6.8/src/mach-lpc313x/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/Makefile	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,24 @@
+#
+# Makefile for APEX loader
+#
+#   Copyright (C) 2004 Marc Singer
+#
+#   This program is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU General Public License
+#   version 2 as published by the Free Software Foundation.
+#   Please refer to the file debian/copyright for further details.
+#
+
+obj-y := initialize.o serial.o timer.o env.o lpc313x_cgu_default.o lpc313x_cgu_driver.o drv-crc32.o
+obj-y += cmd-reset.o
+obj-y += drv-mmc.o
+obj-$(CONFIG_DRIVER_NAND)	+= drv-lpcnand.o
+obj-$(CONFIG_DRIVER_SPINOR)	+= drv-spinor.o
+obj-$(CONFIG_HAS_ANALOG_DIE)	+= lpc315x_ad.o
+obj-$(CONFIG_USB_BOOT)		+= usb/usbmsc.d
+
+obj-y += $(obj-xyy)
+
+CFLAGS_env.o	     += -DBUILDDATE=\"$(BUILDDATE)\"
+CFLAGS_env.o	     += -DAPEXVERSION=\"$(APEXVERSION)\"
+
diff -purN apex-1.6.8/src/mach-lpc313x/memory.h work_1.6.8/src/mach-lpc313x/memory.h
--- apex-1.6.8/src/mach-lpc313x/memory.h	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/memory.h	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,31 @@
+/* memory.h
+   
+   written by Durgesh Pattamatta
+   10 Oct 2008
+
+   Copyright (C) 2008 NXP Semiconductors
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+   -----------
+   DESCRIPTION
+   -----------
+
+*/
+
+#if !defined (__MEMORY_H__)
+#    define   __MEMORY_H__
+
+/* ----- Includes */
+
+#include <config.h>
+#include <mach/hardware.h>
+
+/* ----- Constants */
+# define RAM_BANK0_START	EXT_SDRAM_PHYS
+# define RAM_BANK0_LENGTH	0x10000000
+
+#endif  /* __MEMORY_H__ */
diff -purN apex-1.6.8/src/mach-lpc313x/serial.c work_1.6.8/src/mach-lpc313x/serial.c
--- apex-1.6.8/src/mach-lpc313x/serial.c	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/serial.c	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,145 @@
+/* serial.c
+
+   written by Durgesh Pattamatta
+   1 Nov 2004
+
+   Copyright (C) 2008 NXP Semiconductors
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+   -----------
+   DESCRIPTION
+   -----------
+   This implementation assumes the UART clock is sourced by 12MHz FFAST_IN
+   clock in CGU. 
+
+*/
+
+#include <driver.h>
+#include <service.h>
+#include <apex.h>		/* printf, only */
+#include "lpc313x.h"
+#include "lpc313x_cgu.h"
+
+
+//#include <debug_ll.h>
+#if (CONFIG_OSC_FREQ == 24000000)
+#define UART_BRD_115200		(13)
+#define UART_FDR_115200		((1 << 4) | (0 << 0))
+#else
+#define UART_BRD_115200		(6)
+#define UART_FDR_115200		((12 << 4) | (1 << 0))
+#endif
+
+#define UART_RX_ERR (UART_LSR_FIFORX_ERR | UART_LSR_FR | UART_LSR_PE | UART_LSR_OE)
+
+extern struct driver_d* console_driver;
+
+static struct driver_d lpx313x_serial_driver;
+
+void lpx313x_serial_init (void)
+{
+  /* enable UART clocks */
+  cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
+  cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 1);
+
+  /* enable access to the Divisor latch registers */
+  UART_LCR  = UART_LCR_DIVLATCH_EN;          
+  /* set LSByte of Divisor */
+  UART_DLL  = UART_LOAD_DLL(UART_BRD_115200); 
+  /* set MSByte of Divisor */
+  UART_DLM  = UART_LOAD_DLM(UART_BRD_115200); 
+  /* disable acces to Divisor latch registers, set 8bit data, 1 stop, no parity */
+  UART_LCR  = UART_LCR_WLEN_8BITS;          
+  /* configure fractional divider */
+  UART_FDR  = UART_FDR_115200;			
+  /* disable modem control stuff */
+  UART_MCR  = 0x00;          
+  /* enable fifo. clear Tx and Rx fifos and holding registers. */
+  UART_FCR  = UART_FCR_FIFO_EN | UART_FCR_TXFIFO_FLUSH | UART_FCR_RXFIFO_FLUSH;
+  /* disable Tx and Rx interrupts */          
+  UART_IE  = 0x00;          
+
+  if (console_driver == 0)
+    console_driver = &lpx313x_serial_driver;
+
+//  lpx313x_serial_driver.write (NULL, "serial console initialized\r\n", 28);
+//  printf ("Really, it is\n");
+}
+
+void lpx313x_serial_release (void)
+{
+	/* flush serial output */
+  while (!(UART_LSR & UART_LSR_TEMT))
+    ;
+}
+
+ssize_t lpx313x_serial_poll (struct descriptor_d* d, size_t cb)
+{
+  return (UART_LSR & UART_LSR_RDR);
+}
+
+ssize_t lpx313x_serial_read (struct descriptor_d* d, void* pv, size_t cb)
+{
+  ssize_t cRead = 0;
+  unsigned char* pb;
+  for (pb = (unsigned char*) pv; cb--; ++pb) {
+
+    while (!(UART_LSR & (UART_LSR_RDR | UART_RX_ERR)))
+      ;				/* block until character is available */
+
+    if (UART_LSR & UART_RX_ERR)
+      return -1;		/* -ESERIAL */
+    
+    *pb = UART_FIFO;
+    ++cRead;
+  }
+
+  return cRead;
+}
+
+ssize_t lpx313x_serial_write (struct descriptor_d* d,
+			      const void* pv, size_t cb)
+{
+  ssize_t cWrote = 0;
+  int n_bytes = 0;
+  const unsigned char* pb = pv;
+  for (pb = (unsigned char*) pv; cb--; ++pb) {
+
+	  /* wait until FIFO is empty */
+	  if (n_bytes == 0) {
+	  
+      while (!(UART_LSR & UART_LSR_TEMT))
+        ;
+       /* FIFO is empty so we can write upto 32 bytes */ 
+       n_bytes = 32;
+     }
+
+    UART_FIFO = *pb;
+    --n_bytes;
+    ++cWrote;
+  }
+
+  /* wait until FIFO is empty */
+  while (!(UART_LSR & UART_LSR_TEMT))
+    ;
+
+  return cWrote;
+}
+
+static __driver_0 struct driver_d lpx313x_serial_driver = {
+  .name = "serial-lpx313x",
+  .description = "lpx313x serial driver",
+  .flags = DRIVER_SERIAL | DRIVER_CONSOLE,
+  .read = lpx313x_serial_read,
+  .write = lpx313x_serial_write,
+  .poll = lpx313x_serial_poll,
+};
+
+static __service_3 struct service_d lpx313x_serial_service = {
+  .init = lpx313x_serial_init,
+  .release = lpx313x_serial_release,
+};
diff -purN apex-1.6.8/src/mach-lpc313x/timer.c work_1.6.8/src/mach-lpc313x/timer.c
--- apex-1.6.8/src/mach-lpc313x/timer.c	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/timer.c	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,64 @@
+/* timer.c
+
+   written by Durgesh Pattamatta
+   1 Nov 2004
+
+   Copyright (C) 2008 NXP Semiconductors
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   version 2 as published by the Free Software Foundation.
+   Please refer to the file debian/copyright for further details.
+
+   -----------
+   DESCRIPTION
+   -----------
+   This implementation assumes the TIMER1 clock is sourced by 12MHz FFAST_IN
+   clock in CGU. 
+   
+
+*/
+
+#include <service.h>
+#include "lpc313x.h"
+#include "lpc313x_cgu.h"
+
+#define TICKS_PER_MSEC      (XTAL_CLOCK/(256 * 1000))
+
+static void lpc313x_timer_init (void)
+{
+  /* enable Timer0 clocks */
+  cgu_clk_en_dis(CGU_SB_TIMER0_PCLK_ID, 1);
+	
+  __REG (TIMER0_PHYS + TIMER_CONTROL) = TM_CTRL_PS256 | TM_CTRL_ENABLE;
+  __REG (TIMER0_PHYS + TIMER_LOAD) = 0xffffffff;
+  __REG (TIMER1_PHYS + TIMER_CONTROL) = 0;
+  __REG (TIMER2_PHYS + TIMER_CONTROL) = 0;
+  __REG (TIMER3_PHYS + TIMER_CONTROL) = 0;
+}
+
+static void lpc313x_timer_release (void)
+{
+  __REG (TIMER0_PHYS + TIMER_CONTROL) = 0;
+}
+
+unsigned long timer_read (void)
+{
+  return (0xFFFFFFFF - __REG (TIMER0_PHYS + TIMER_VALUE));
+}
+
+/* timer_delta
+
+   returns the difference in time in milliseconds.
+
+ */
+
+unsigned long timer_delta (unsigned long start, unsigned long end)
+{
+  return (end - start)/TICKS_PER_MSEC;
+}
+
+static __service_2 struct service_d lpc313x_timer_service = {
+  .init    = lpc313x_timer_init,
+  .release = lpc313x_timer_release,
+};
diff -purN apex-1.6.8/src/mach-lpc313x/val314x_config work_1.6.8/src/mach-lpc313x/val314x_config
--- apex-1.6.8/src/mach-lpc313x/val314x_config	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/val314x_config	2010-03-03 14:23:31.000000000 -0800
@@ -0,0 +1,173 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: KERNELVERSION
+# Thu Feb 25 09:28:36 2010
+#
+CONFIG_ARM=y
+CONFIG_CPU_ARMV5=y
+CONFIG_CPU_ARM9=y
+CONFIG_CPU_ARM926T=y
+# CONFIG_ARCH_LH7952X is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_IXP42X is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_MX3 is not set
+# CONFIG_ARCH_ORION5X is not set
+CONFIG_ARCH_LPC313X=y
+# CONFIG_EXPERIMENTAL is not set
+# CONFIG_SMALL is not set
+
+#
+# General Setup
+#
+CONFIG_TARGET_DESCRIPTION="Unspecified target"
+CONFIG_CROSS_COMPILE="arm-linux-"
+CONFIG_AEABI=y
+# CONFIG_DRIVER_LONG_LONG_SIZE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_CC_OPTIMIZE_FOR_SPEED is not set
+# CONFIG_CC_NO_OPTIMIZATION is not set
+# CONFIG_STARTUP_UART is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_SPINNER=y
+CONFIG_ATAG=y
+# CONFIG_MMU is not set
+CONFIG_DISABLE_MMU_AT_BOOT=y
+CONFIG_SDRAMBOOT_REPORT=y
+CONFIG_STACK_SIZE=0x1000
+# CONFIG_BOOTSTRAP_MEMTEST is not set
+CONFIG_ATAG_PHYS=0x30000100
+CONFIG_ARCH_NUMBER=9999
+CONFIG_APEX_VMA=0x11029000
+CONFIG_KERNEL_LMA=0x30008000
+CONFIG_USE_RAMDISK=y
+CONFIG_RAMDISK_LMA=0x32000000
+CONFIG_MACH="lpc313x"
+CONFIG_RAMDISK_SIZE=0x00300000
+CONFIG_MACH_VAL3153=y
+# CONFIG_MACH_VAL3154 is not set
+# CONFIG_MACH_EA313x_V1 is not set
+# CONFIG_MACH_EA313x_V2 is not set
+
+#
+# Platform Setup
+#
+CONFIG_OSC_FREQ=12000000
+# CONFIG_PLL_180 is not set
+CONFIG_PLL_270=y
+CONFIG_DYNAMIC_CLOCKS=y
+# CONFIG_USB_BOOT is not set
+CONFIG_AUTOFORMAT_BLOCK0=y
+# CONFIG_MICRON_MT29F2G08 is not set
+CONFIG_MICRON_MT29F4G08=y
+# CONFIG_SAMSUNG_K9K8G is not set
+# CONFIG_TOSHIBA_TC58DVM82A is not set
+CONFIG_DRIVER_SPINOR=y
+CONFIG_SPINOR_AT45DB=y
+CONFIG_USES_SPINOR=y
+
+#
+# Commands
+#
+CONFIG_ALLHELP=y
+CONFIG_ALPHABETIZE_COMMANDS=y
+CONFIG_PARTIAL_MATCHES=y
+CONFIG_DEL_IS_BS=y
+CONFIG_ANSI_KEYS=y
+CONFIG_COMMAND_HISTORY=y
+CONFIG_COMMAND_EDITING=y
+# CONFIG_TIME_COMMANDS is not set
+CONFIG_CMD_ALIAS=y
+CONFIG_CMD_CHECKSUM=y
+CONFIG_CMD_COPY=y
+CONFIG_CMD_COMPARE=y
+CONFIG_CMD_DRVINFO=y
+CONFIG_CMD_DUMP=y
+CONFIG_CMD_ENV=y
+CONFIG_CMD_IMAGE=y
+CONFIG_CMD_IMAGE_APEX=y
+# CONFIG_CMD_IMAGE_UBOOT is not set
+CONFIG_CMD_IMAGE_SHOW=y
+CONFIG_CMD_SETENV=y
+CONFIG_CMD_ERASE=y
+CONFIG_CMD_FILL=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_INFO=y
+# CONFIG_CMD_PARSE is not set
+# CONFIG_CMD_PAUSE is not set
+# CONFIG_CMD_FLASHUSAGE is not set
+CONFIG_CMD_WAIT=y
+CONFIG_CMD_XRECEIVE=y
+# CONFIG_CMD_MEMLIMIT is not set
+# CONFIG_CMD_MEMSCAN is not set
+# CONFIG_CMD_MEMTEST is not set
+CONFIG_CMD_NAND=y
+# CONFIG_CRC32_LSB is not set
+
+#
+# Generic Drivers
+#
+CONFIG_DRIVER_FAT=y
+CONFIG_DRIVER_FAT_BLOCKDEVICE="mmc"
+CONFIG_DRIVER_EXT2=y
+CONFIG_DRIVER_EXT2_BLOCKDEVICE="mmc"
+# CONFIG_DRIVER_JFFS2 is not set
+# CONFIG_DRIVER_FIS is not set
+CONFIG_DRIVER_NAND=y
+# CONFIG_DRIVER_NAND_TYPE_TOSHIBA is not set
+# CONFIG_DRIVER_NAND_TYPE_ST is not set
+CONFIG_DRIVER_NAND_TYPE_MICRON=y
+CONFIG_DRIVER_NAND_ADDRESS_BYTES=2
+# CONFIG_DRIVER_ONENAND is not set
+CONFIG_DRIVER_CS8900=y
+CONFIG_USES_NAND=y
+CONFIG_USES_PATHNAME_PARSER=y
+CONFIG_USES_CS8900=y
+
+#
+# Ethernet Networking
+#
+CONFIG_ETHERNET=y
+CONFIG_CMD_IPCONFIG=y
+CONFIG_CMD_IPCONFIG_STATIC=y
+CONFIG_CMD_IPCONFIG_RARP=y
+CONFIG_CMD_IPCONFIG_BOOTP=y
+# CONFIG_CMD_IPCONFIG_DHCP is not set
+CONFIG_PROTO_ICMP_ECHO=y
+CONFIG_CMD_PING=y
+# CONFIG_CMD_ARP is not set
+CONFIG_CMD_TFTP=y
+CONFIG_USE_ETHERNET=y
+
+#
+# Environment
+#
+CONFIG_ENV=y
+CONFIG_ENV_MUTABLE=y
+CONFIG_ENV_REGION="lnand:512k+256k"
+# CONFIG_ENV_SAVEATONCE is not set
+CONFIG_ENV_CHECK_LEN=1024
+# CONFIG_VARIATIONS is not set
+CONFIG_NO_BOOTSTRAP=y
+# CONFIG_NOR_BOOT is not set
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_COMPANION_EVT1_BOOT is not set
+# CONFIG_COMPANION_EVT2_BOOT is not set
+CONFIG_ENV_STARTUP_PREFIX_P=y
+CONFIG_ENV_STARTUP_PREFIX="ipconfig rarp"
+
+#
+# Regions
+#
+CONFIG_ENV_REGION_KERNEL="tftp://$serverip/zImage"
+CONFIG_ENV_REGION_RAMDISK="tftp://$serverip/ramdisk_image.gz"
+
+#
+# Overrides
+#
+# CONFIG_ENV_DEFAULT_CMDLINE_OVERRIDE is not set
+CONFIG_ENV_DEFAULT_STARTUP_OVERRIDE=y
+CONFIG_ENV_DEFAULT_STARTUP="ipconfig rarp; copy $kernelsrc $bootaddr;copy $ramdisksrc $ramdiskaddr; boot"
+CONFIG_RELOCATE_SIMPLE=y
+CONFIG_ALIASES=y
diff -purN apex-1.6.8/src/mach-lpc313x/val3154_config work_1.6.8/src/mach-lpc313x/val3154_config
--- apex-1.6.8/src/mach-lpc313x/val3154_config	1969-12-31 16:00:00.000000000 -0800
+++ work_1.6.8/src/mach-lpc313x/val3154_config	2010-01-22 14:23:30.000000000 -0800
@@ -0,0 +1,144 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: KERNELVERSION
+# Wed May 27 11:13:10 2009
+#
+CONFIG_ARM=y
+CONFIG_CPU_ARMV5=y
+CONFIG_CPU_ARM9=y
+CONFIG_CPU_ARM926T=y
+# CONFIG_ARCH_LH7952X is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_IXP42X is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_MX3 is not set
+# CONFIG_ARCH_ORION5X is not set
+CONFIG_ARCH_LPC313X=y
+# CONFIG_EXPERIMENTAL is not set
+# CONFIG_SMALL is not set
+
+#
+# General Setup
+#
+CONFIG_TARGET_DESCRIPTION="Unspecified target"
+CONFIG_CROSS_COMPILE="arm-linux-"
+CONFIG_AEABI=y
+# CONFIG_DRIVER_LONG_LONG_SIZE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_CC_OPTIMIZE_FOR_SPEED is not set
+# CONFIG_CC_NO_OPTIMIZATION is not set
+# CONFIG_STARTUP_UART is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_SPINNER=y
+CONFIG_ATAG=y
+# CONFIG_MMU is not set
+CONFIG_DISABLE_MMU_AT_BOOT=y
+CONFIG_SDRAMBOOT_REPORT=y
+CONFIG_STACK_SIZE=0x1000
+# CONFIG_BOOTSTRAP_MEMTEST is not set
+CONFIG_ATAG_PHYS=0x30000100
+CONFIG_ARCH_NUMBER=9997
+CONFIG_APEX_VMA=0x11029000
+CONFIG_KERNEL_LMA=0x30008000
+CONFIG_USE_RAMDISK=y
+CONFIG_RAMDISK_LMA=0x32000000
+CONFIG_MACH="lpc313x"
+CONFIG_RAMDISK_SIZE=0x00300000
+# CONFIG_MACH_VAL3153 is not set
+CONFIG_MACH_VAL3154=y
+# CONFIG_MACH_EA313x_V1 is not set
+# CONFIG_MACH_EA313x_V2 is not set
+
+#
+# Platform Setup
+#
+CONFIG_OSC_FREQ=12000000
+CONFIG_PLL_180=y
+# CONFIG_PLL_270 is not set
+# CONFIG_USB_BOOT is not set
+# CONFIG_MICRON_MT29F2G08 is not set
+CONFIG_SAMSUNG_K9K8G=y
+CONFIG_HAS_ANALOG_DIE=y
+
+#
+# Commands
+#
+CONFIG_ALLHELP=y
+CONFIG_ALPHABETIZE_COMMANDS=y
+CONFIG_PARTIAL_MATCHES=y
+CONFIG_DEL_IS_BS=y
+CONFIG_ANSI_KEYS=y
+CONFIG_COMMAND_HISTORY=y
+CONFIG_COMMAND_EDITING=y
+# CONFIG_TIME_COMMANDS is not set
+CONFIG_CMD_ALIAS=y
+CONFIG_CMD_CHECKSUM=y
+CONFIG_CMD_COPY=y
+CONFIG_CMD_COMPARE=y
+CONFIG_CMD_DRVINFO=y
+CONFIG_CMD_DUMP=y
+CONFIG_CMD_ENV=y
+CONFIG_CMD_IMAGE=y
+CONFIG_CMD_IMAGE_APEX=y
+# CONFIG_CMD_IMAGE_UBOOT is not set
+CONFIG_CMD_IMAGE_SHOW=y
+CONFIG_CMD_SETENV=y
+CONFIG_CMD_ERASE=y
+CONFIG_CMD_FILL=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_INFO=y
+# CONFIG_CMD_PARSE is not set
+# CONFIG_CMD_PAUSE is not set
+# CONFIG_CMD_FLASHUSAGE is not set
+CONFIG_CMD_WAIT=y
+CONFIG_CMD_XRECEIVE=y
+# CONFIG_CMD_MEMLIMIT is not set
+# CONFIG_CMD_MEMSCAN is not set
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CRC32_LSB is not set
+
+#
+# Generic Drivers
+#
+# CONFIG_DRIVER_FAT is not set
+CONFIG_DRIVER_EXT2=y
+CONFIG_DRIVER_EXT2_BLOCKDEVICE="mmc"
+# CONFIG_DRIVER_JFFS2 is not set
+# CONFIG_DRIVER_FIS is not set
+# CONFIG_DRIVER_NAND is not set
+# CONFIG_DRIVER_ONENAND is not set
+CONFIG_USES_NAND=y
+CONFIG_USES_PATHNAME_PARSER=y
+
+#
+# Environment
+#
+CONFIG_ENV=y
+CONFIG_ENV_MUTABLE=y
+CONFIG_ENV_REGION="lnand:512k+256k"
+CONFIG_ENV_SAVEATONCE=y
+CONFIG_ENV_SIZE=16384
+CONFIG_ENV_CHECK_LEN=1024
+# CONFIG_VARIATIONS is not set
+CONFIG_NO_BOOTSTRAP=y
+# CONFIG_NOR_BOOT is not set
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_COMPANION_EVT1_BOOT is not set
+# CONFIG_COMPANION_EVT2_BOOT is not set
+# CONFIG_ENV_STARTUP_PREFIX_P is not set
+
+#
+# Regions
+#
+CONFIG_ENV_REGION_KERNEL="ext2://1/zImage"
+CONFIG_ENV_REGION_RAMDISK="ext2://1/ramdisk_image.gz"
+
+#
+# Overrides
+#
+# CONFIG_ENV_DEFAULT_CMDLINE_OVERRIDE is not set
+CONFIG_ENV_DEFAULT_STARTUP_OVERRIDE=y
+CONFIG_ENV_DEFAULT_STARTUP="copy $kernelsrc $bootaddr;copy $ramdisksrc $ramdiskaddr; boot"
+CONFIG_RELOCATE_SIMPLE=y
+CONFIG_ALIASES=y
diff -purN apex-1.6.8/src/net/ethernet.c work_1.6.8/src/net/ethernet.c
--- apex-1.6.8/src/net/ethernet.c	2009-01-23 09:27:43.000000000 -0800
+++ work_1.6.8/src/net/ethernet.c	2010-01-22 14:23:30.000000000 -0800
@@ -420,15 +420,15 @@ void ethernet_receive (struct descriptor
     return;			/* Not for us. */
 #endif
 
-  /* Check for a valid IP address.  At present, this isn't strictly
-     correct since we don't check for broadcast addresses.  Adding
-     support for such shouldn't be difficult.  It just requires some
-     bookkeeping. */
-
-  if (ETH_F (frame)->protocol == HTONS (ETH_PROTO_IP)
-      && memcmp (IPV4_F (frame)->destination_ip, host_ip_address, 4))
-    return;			/* Not for us */
-
+  if (!UNCONFIGURED_IP) {
+    /* Check for a valid IP address.  At present, this isn't strictly
+       correct since we don't check for broadcast addresses.  Adding
+       support for such shouldn't be difficult.  It just requires some
+       bookkeeping. */
+    if (ETH_F (frame)->protocol == HTONS (ETH_PROTO_IP)
+        && memcmp (IPV4_F (frame)->destination_ip, host_ip_address, 4))
+      return;			/* Not for us */
+  }
 	/* Invoke receivers */
   {
     int i;
diff -purN apex-1.6.8/src/net/ipconfig.c work_1.6.8/src/net/ipconfig.c
--- apex-1.6.8/src/net/ipconfig.c	2009-01-23 09:27:43.000000000 -0800
+++ work_1.6.8/src/net/ipconfig.c	2010-01-22 14:23:30.000000000 -0800
@@ -251,6 +251,178 @@ int cmd_ipconfig_rarp (int argc, const c
 
 #endif
 
+#if defined CONFIG_CMD_IPCONFIG_BOOTP
+
+static u16 _checksum (u32* sum, void* pv, int cb)
+{
+  u16* p = (u16*) pv;
+  for (; cb > 0; cb -= 2) {
+    unsigned short s = *p++;
+    *sum += HTONS (s);
+  }
+
+  return ~ ((*sum & 0xffff) + (*sum >> 16));
+}
+
+static int bootp_receiver (struct descriptor_d* d,
+			  struct ethernet_frame* frame,
+			  void* context)
+{
+  /* Vet the frame */
+  if (frame->cb
+      < (sizeof (struct header_ethernet) + sizeof (struct header_ipv4)
+	 + sizeof (struct header_udp) + sizeof (struct header_bootp)))
+    return 0;			/* runt */
+
+  if (ETH_F (frame)->protocol != HTONS (ETH_PROTO_IP))
+    return 0;
+
+  if (IPV4_F (frame)->protocol != IP_PROTO_UDP)
+    return 0;
+
+  if (UDP_F (frame)->source_port != HTONS (PORT_BOOTP_SERVER))
+    return 0;
+
+  if (UDP_F (frame)->destination_port != HTONS (PORT_BOOTP_CLIENT))
+    return 0;
+
+  if (BOOTP_F (frame)->op != 0x02)
+    return 0;
+
+  memcpy (host_ip_address, BOOTP_F (frame)->yiaddr, 4);
+	/* Add ARP entry for the server */
+  arp_cache_update ((char*) ETH_F (frame)->source_address,
+		    (char*) IPV4_F (frame)->source_ip,
+		    1);
+  memcpy (server_ip_address, BOOTP_F (frame)->siaddr, 4);
+  memcpy (gw_ip_address, BOOTP_F (frame)->giaddr, 4);
+  set_aliases ();
+
+  return 1;
+}
+
+int cmd_ipconfig_bootp (int argc, const char** argv)
+{
+  struct descriptor_d d;
+  int result;
+  struct ethernet_frame* frame;
+  int tries = 0;
+
+  if (   (result = parse_descriptor (szNetDriver, &d))
+      || (result = open_descriptor (&d)))
+    return result;
+
+  DBG (2,"%s: open %s -> %d\n", __FUNCTION__, szNetDriver, result);
+
+  frame = ethernet_frame_allocate ();
+
+  DBG (2,"%s: setup ethernet header %p\n", __FUNCTION__, frame);
+
+  memset (IPV4_F (frame), 0,
+	  sizeof (struct header_ipv4) + sizeof (struct header_udp));
+  
+  memset (ETH_F (frame)->destination_address, 0xff, 6);
+  memcpy (ETH_F (frame)->source_address, host_mac_address, 6);
+  ETH_F (frame)->protocol = HTONS (ETH_PROTO_IP);
+
+  DBG (2,"%s: setup ipv4 header\n", __FUNCTION__);
+
+  IPV4_F (frame)->version_ihl = 4<<4 | 5;
+  IPV4_F (frame)->length
+    = htons (  sizeof (struct header_ipv4)
+	     + sizeof (struct header_udp)
+	     + sizeof (struct header_bootp));
+  IPV4_F (frame)->ttl = 64;
+  IPV4_F (frame)->protocol = IP_PROTO_UDP;
+  memset (IPV4_F (frame)->source_ip, 0xff, 4);
+  memset (IPV4_F (frame)->destination_ip, 0xff, 4);
+  IPV4_F (frame)->checksum = 0;
+
+  DBG (2,"%s: setup bootp header\n", __FUNCTION__);
+
+  BOOTP_F (frame)->op = 0x01;
+  BOOTP_F (frame)->htype = 0x01;
+  BOOTP_F (frame)->hlen = 0x06;
+  BOOTP_F (frame)->hops = 0x00;
+  BOOTP_F (frame)->xid = HTONS (0x3903F326);
+  BOOTP_F (frame)->secs = HTONS (0x0000);
+  BOOTP_F (frame)->flags = HTONS (0x0000);
+  memset (BOOTP_F (frame)->ciaddr, 0x00, 4);
+  memset (BOOTP_F (frame)->yiaddr, 0x00, 4);
+  memset (BOOTP_F (frame)->siaddr, 0x00, 4);
+  memset (BOOTP_F (frame)->giaddr, 0x00, 4);
+  memset (BOOTP_F (frame)->chaddr, 0x00, 16);
+  memcpy (BOOTP_F (frame)->chaddr, host_mac_address, 6);
+  memset (BOOTP_F (frame)->sname, 0x00, 64);
+  memset (BOOTP_F (frame)->file, 0x00, 128);
+
+  /* This must be at the end because the UDP checksum includs the data */
+  DBG (2,"%s: setup udp header\n", __FUNCTION__);
+
+  UDP_F (frame)->source_port = HTONS (PORT_BOOTP_CLIENT);
+  UDP_F (frame)->destination_port = HTONS (PORT_BOOTP_SERVER);
+  UDP_F (frame)->length = htons (sizeof (struct header_udp) + sizeof (struct header_bootp));
+  {
+    /* UDP Checksum use part of IPv4 header*/
+    u32 sum = 0;
+    u16 length = htons (sizeof (struct header_udp) + sizeof (struct header_bootp));
+    u8 rgb[2] = { 0, IPV4_F (frame)->protocol };
+    _checksum (&sum, IPV4_F (frame)->source_ip, 8);
+    _checksum (&sum, rgb, 2);
+    _checksum (&sum, &length, 2);
+    UDP_F (frame)->checksum
+      = htons (_checksum (&sum, UDP_F (frame),
+			  sizeof (struct header_udp) + sizeof (struct header_bootp)));
+  }
+
+  IPV4_F (frame)->checksum
+    = htons (checksum (IPV4_F (frame), sizeof (struct header_ipv4)));
+
+  frame->cb = sizeof (struct header_ethernet)
+	    + sizeof (struct header_ipv4)
+	    + sizeof (struct header_udp)
+	    + sizeof (struct header_bootp);
+//  dump (frame->rgb, frame->cb, 0);
+
+  register_ethernet_receiver (100, bootp_receiver, NULL);
+
+  goto flush;		/* Receive pending packets before first transmit  */
+  do {
+    struct ethernet_timeout_context timeout;
+
+    DBG (1,"%s: send frame\n", __FUNCTION__);
+    d.driver->write (&d, frame->rgb,
+		     sizeof (struct header_ethernet)
+		     + sizeof (struct header_ipv4)
+		     + sizeof (struct header_udp)
+		     + sizeof (struct header_bootp));
+    ++tries;
+
+  flush:
+    memset (&timeout, 0, sizeof (timeout));
+    timeout.ms_timeout = MS_TIMEOUT;
+    result = ethernet_service (&d, ipconfig_terminate, &timeout);
+
+    /* result == 1 on success, -1 on timeout, -2 on user abort  */
+  } while (result != ERROR_BREAK && result <= 0 && tries < TRIES_MAX);
+
+  unregister_ethernet_receiver (bootp_receiver, NULL);
+
+  printf ("\r");
+  if (UNCONFIGURED_IP)
+    printf ("BOOTP failed\n");
+  else
+    show_ip_config ();
+
+  ethernet_frame_release (frame);
+
+  close_descriptor (&d);
+
+  return result < 0 ? result : 0;
+}
+
+#endif
+
 int cmd_ipconfig (int argc, const char** argv)
 {
   int result;
